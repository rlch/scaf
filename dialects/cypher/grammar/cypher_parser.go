// Code generated from CypherParser.g4 by ANTLR 4.13.2. DO NOT EDIT.

package cyphergrammar
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type CypherParser struct {
	*antlr.BaseParser
}

var CypherParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func cypherparserParserInit() {
	staticData := &CypherParserParserStaticData
	staticData.LiteralNames = []string{
		"", "'='", "'+='", "'<='", "'>='", "'>'", "'<'", "'<>'", "'..'", "';'",
		"'.'", "','", "'('", "')'", "'{'", "'}'", "'['", "']'", "'-'", "'+'",
		"'/'", "'%'", "'^'", "'*'", "'`'", "':'", "'|'", "'$'", "'CALL'", "'YIELD'",
		"'FILTER'", "'EXTRACT'", "'COUNT'", "'ANY'", "'NONE'", "'SINGLE'", "'ALL'",
		"'ASC'", "'ASCENDING'", "'BY'", "'CREATE'", "'DELETE'", "'DESC'", "'DESCENDING'",
		"'DETACH'", "'EXISTS'", "'LIMIT'", "'MATCH'", "'MERGE'", "'ON'", "'OPTIONAL'",
		"'ORDER'", "'REMOVE'", "'RETURN'", "'SET'", "'SKIP'", "'WHERE'", "'WITH'",
		"'UNION'", "'UNWIND'", "'AND'", "'AS'", "'CONTAINS'", "'DISTINCT'",
		"'ENDS'", "'IN'", "'IS'", "'NOT'", "'OR'", "'STARTS'", "'XOR'", "'FALSE'",
		"'TRUE'", "'NULL'", "'CONSTRAINT'", "'DO'", "'FOR'", "'REQUIRE'", "'UNIQUE'",
		"'CASE'", "'WHEN'", "'THEN'", "'ELSE'", "'END'", "'MANDATORY'", "'SCALAR'",
		"'OF'", "'ADD'", "'DROP'",
	}
	staticData.SymbolicNames = []string{
		"", "ASSIGN", "ADD_ASSIGN", "LE", "GE", "GT", "LT", "NOT_EQUAL", "RANGE",
		"SEMI", "DOT", "COMMA", "LPAREN", "RPAREN", "LBRACE", "RBRACE", "LBRACK",
		"RBRACK", "SUB", "PLUS", "DIV", "MOD", "CARET", "MULT", "ESC", "COLON",
		"STICK", "DOLLAR", "CALL", "YIELD", "FILTER", "EXTRACT", "COUNT", "ANY",
		"NONE", "SINGLE", "ALL", "ASC", "ASCENDING", "BY", "CREATE", "DELETE",
		"DESC", "DESCENDING", "DETACH", "EXISTS", "LIMIT", "MATCH", "MERGE",
		"ON", "OPTIONAL", "ORDER", "REMOVE", "RETURN", "SET", "SKIP_W", "WHERE",
		"WITH", "UNION", "UNWIND", "AND", "AS", "CONTAINS", "DISTINCT", "ENDS",
		"IN", "IS", "NOT", "OR", "STARTS", "XOR", "FALSE", "TRUE", "NULL_W",
		"CONSTRAINT", "DO", "FOR", "REQUIRE", "UNIQUE", "CASE", "WHEN", "THEN",
		"ELSE", "END", "MANDATORY", "SCALAR", "OF", "ADD", "DROP", "ID", "ESC_LITERAL",
		"CHAR_LITERAL", "STRING_LITERAL", "DIGIT", "FLOAT", "WS", "COMMENT",
		"LINE_COMMENT", "ERRCHAR", "Letter",
	}
	staticData.RuleNames = []string{
		"script", "query", "regularQuery", "singleQuery", "standaloneCall",
		"returnSt", "withSt", "skipSt", "limitSt", "projectionBody", "projectionItems",
		"projectionItem", "orderItem", "orderSt", "singlePartQ", "multiPartQ",
		"matchSt", "unwindSt", "readingStatement", "updatingStatement", "deleteSt",
		"removeSt", "removeItem", "queryCallSt", "parenExpressionChain", "yieldItems",
		"yieldItem", "mergeSt", "mergeAction", "setSt", "setItem", "nodeLabels",
		"createSt", "patternWhere", "where", "pattern", "expression", "xorExpression",
		"andExpression", "notExpression", "comparisonExpression", "comparisonSigns",
		"addSubExpression", "multDivExpression", "powerExpression", "unaryAddSubExpression",
		"atomicExpression", "listExpression", "stringExpression", "stringExpPrefix",
		"nullExpression", "propertyOrLabelExpression", "propertyExpression",
		"patternPart", "patternElem", "patternElemChain", "properties", "nodePattern",
		"atom", "lhs", "relationshipPattern", "relationDetail", "relationshipTypes",
		"unionSt", "subqueryExist", "invocationName", "functionInvocation",
		"parenthesizedExpression", "filterWith", "patternComprehension", "relationshipsChainPattern",
		"listComprehension", "filterExpression", "countAll", "expressionChain",
		"caseExpression", "parameter", "literal", "rangeLit", "boolLit", "numLit",
		"stringLit", "charLit", "listLit", "mapLit", "mapPair", "name", "symbol",
		"reservedWord",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 99, 830, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68,
		7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7,
		73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78,
		2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 2,
		84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 1, 0,
		1, 0, 3, 0, 181, 8, 0, 1, 0, 1, 0, 1, 1, 1, 1, 3, 1, 187, 8, 1, 1, 2, 1,
		2, 5, 2, 191, 8, 2, 10, 2, 12, 2, 194, 9, 2, 1, 3, 1, 3, 3, 3, 198, 8,
		3, 1, 4, 1, 4, 1, 4, 3, 4, 203, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 208, 8, 4,
		3, 4, 210, 8, 4, 1, 5, 1, 5, 1, 5, 1, 6, 1, 6, 1, 6, 3, 6, 218, 8, 6, 1,
		7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 1, 9, 3, 9, 227, 8, 9, 1, 9, 1, 9, 3,
		9, 231, 8, 9, 1, 9, 3, 9, 234, 8, 9, 1, 9, 3, 9, 237, 8, 9, 1, 10, 1, 10,
		3, 10, 241, 8, 10, 1, 10, 1, 10, 5, 10, 245, 8, 10, 10, 10, 12, 10, 248,
		9, 10, 1, 11, 1, 11, 1, 11, 3, 11, 253, 8, 11, 1, 12, 1, 12, 3, 12, 257,
		8, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 5, 13, 264, 8, 13, 10, 13, 12,
		13, 267, 9, 13, 1, 14, 5, 14, 270, 8, 14, 10, 14, 12, 14, 273, 9, 14, 1,
		14, 1, 14, 4, 14, 277, 8, 14, 11, 14, 12, 14, 278, 1, 14, 3, 14, 282, 8,
		14, 3, 14, 284, 8, 14, 1, 15, 5, 15, 287, 8, 15, 10, 15, 12, 15, 290, 9,
		15, 1, 15, 5, 15, 293, 8, 15, 10, 15, 12, 15, 296, 9, 15, 1, 15, 4, 15,
		299, 8, 15, 11, 15, 12, 15, 300, 1, 15, 1, 15, 1, 16, 3, 16, 306, 8, 16,
		1, 16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1,
		18, 3, 18, 319, 8, 18, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 326, 8,
		19, 1, 20, 3, 20, 329, 8, 20, 1, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21,
		1, 21, 5, 21, 338, 8, 21, 10, 21, 12, 21, 341, 9, 21, 1, 22, 1, 22, 1,
		22, 1, 22, 3, 22, 347, 8, 22, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 3, 23,
		354, 8, 23, 1, 24, 1, 24, 3, 24, 358, 8, 24, 1, 24, 1, 24, 1, 25, 1, 25,
		1, 25, 5, 25, 365, 8, 25, 10, 25, 12, 25, 368, 9, 25, 1, 25, 3, 25, 371,
		8, 25, 1, 26, 1, 26, 1, 26, 3, 26, 376, 8, 26, 1, 26, 1, 26, 1, 27, 1,
		27, 1, 27, 5, 27, 383, 8, 27, 10, 27, 12, 27, 386, 9, 27, 1, 28, 1, 28,
		1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 1, 29, 5, 29, 396, 8, 29, 10, 29, 12,
		29, 399, 9, 29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30,
		1, 30, 1, 30, 1, 30, 3, 30, 412, 8, 30, 1, 31, 1, 31, 4, 31, 416, 8, 31,
		11, 31, 12, 31, 417, 1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 3, 33, 425, 8,
		33, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35, 5, 35, 433, 8, 35, 10, 35,
		12, 35, 436, 9, 35, 1, 36, 1, 36, 1, 36, 5, 36, 441, 8, 36, 10, 36, 12,
		36, 444, 9, 36, 1, 37, 1, 37, 1, 37, 5, 37, 449, 8, 37, 10, 37, 12, 37,
		452, 9, 37, 1, 38, 1, 38, 1, 38, 5, 38, 457, 8, 38, 10, 38, 12, 38, 460,
		9, 38, 1, 39, 3, 39, 463, 8, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 1,
		40, 5, 40, 471, 8, 40, 10, 40, 12, 40, 474, 9, 40, 1, 41, 1, 41, 1, 42,
		1, 42, 1, 42, 5, 42, 481, 8, 42, 10, 42, 12, 42, 484, 9, 42, 1, 43, 1,
		43, 1, 43, 5, 43, 489, 8, 43, 10, 43, 12, 43, 492, 9, 43, 1, 44, 1, 44,
		1, 44, 5, 44, 497, 8, 44, 10, 44, 12, 44, 500, 9, 44, 1, 45, 3, 45, 503,
		8, 45, 1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 1, 46, 5, 46, 511, 8, 46, 10,
		46, 12, 46, 514, 9, 46, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 520, 8, 47,
		1, 47, 1, 47, 3, 47, 524, 8, 47, 1, 47, 3, 47, 527, 8, 47, 1, 47, 3, 47,
		530, 8, 47, 1, 48, 1, 48, 1, 48, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3,
		49, 540, 8, 49, 1, 50, 1, 50, 3, 50, 544, 8, 50, 1, 50, 1, 50, 1, 51, 1,
		51, 3, 51, 550, 8, 51, 1, 52, 1, 52, 1, 52, 5, 52, 555, 8, 52, 10, 52,
		12, 52, 558, 9, 52, 1, 53, 1, 53, 1, 53, 3, 53, 563, 8, 53, 1, 53, 1, 53,
		1, 54, 1, 54, 5, 54, 569, 8, 54, 10, 54, 12, 54, 572, 9, 54, 1, 54, 1,
		54, 1, 54, 1, 54, 3, 54, 578, 8, 54, 1, 55, 1, 55, 1, 55, 1, 56, 1, 56,
		3, 56, 585, 8, 56, 1, 57, 1, 57, 3, 57, 589, 8, 57, 1, 57, 3, 57, 592,
		8, 57, 1, 57, 3, 57, 595, 8, 57, 1, 57, 1, 57, 1, 58, 1, 58, 1, 58, 1,
		58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 611,
		8, 58, 1, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 3, 60, 619, 8, 60, 1,
		60, 1, 60, 3, 60, 623, 8, 60, 1, 60, 1, 60, 3, 60, 627, 8, 60, 1, 60, 1,
		60, 3, 60, 631, 8, 60, 3, 60, 633, 8, 60, 1, 61, 1, 61, 3, 61, 637, 8,
		61, 1, 61, 3, 61, 640, 8, 61, 1, 61, 3, 61, 643, 8, 61, 1, 61, 3, 61, 646,
		8, 61, 1, 61, 1, 61, 1, 62, 1, 62, 1, 62, 1, 62, 3, 62, 654, 8, 62, 1,
		62, 5, 62, 657, 8, 62, 10, 62, 12, 62, 660, 9, 62, 1, 63, 1, 63, 3, 63,
		664, 8, 63, 1, 63, 1, 63, 1, 64, 1, 64, 1, 64, 1, 64, 3, 64, 672, 8, 64,
		1, 64, 1, 64, 1, 65, 1, 65, 1, 65, 5, 65, 679, 8, 65, 10, 65, 12, 65, 682,
		9, 65, 1, 66, 1, 66, 1, 66, 3, 66, 687, 8, 66, 1, 66, 3, 66, 690, 8, 66,
		1, 66, 1, 66, 1, 67, 1, 67, 1, 67, 1, 67, 1, 68, 1, 68, 1, 68, 1, 68, 1,
		68, 1, 69, 1, 69, 3, 69, 705, 8, 69, 1, 69, 1, 69, 3, 69, 709, 8, 69, 1,
		69, 1, 69, 1, 69, 1, 69, 1, 70, 1, 70, 4, 70, 717, 8, 70, 11, 70, 12, 70,
		718, 1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 725, 8, 71, 1, 71, 1, 71, 1, 72,
		1, 72, 1, 72, 1, 72, 3, 72, 733, 8, 72, 1, 73, 1, 73, 1, 73, 1, 73, 1,
		73, 1, 74, 1, 74, 1, 74, 5, 74, 743, 8, 74, 10, 74, 12, 74, 746, 9, 74,
		1, 75, 1, 75, 3, 75, 750, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 4,
		75, 757, 8, 75, 11, 75, 12, 75, 758, 1, 75, 1, 75, 3, 75, 763, 8, 75, 1,
		75, 1, 75, 1, 76, 1, 76, 1, 76, 3, 76, 770, 8, 76, 1, 77, 1, 77, 1, 77,
		1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 779, 8, 77, 1, 78, 1, 78, 3, 78, 783,
		8, 78, 1, 78, 1, 78, 3, 78, 787, 8, 78, 3, 78, 789, 8, 78, 1, 79, 1, 79,
		1, 80, 1, 80, 1, 81, 1, 81, 1, 82, 1, 82, 1, 83, 1, 83, 3, 83, 801, 8,
		83, 1, 83, 1, 83, 1, 84, 1, 84, 1, 84, 1, 84, 5, 84, 809, 8, 84, 10, 84,
		12, 84, 812, 9, 84, 3, 84, 814, 8, 84, 1, 84, 1, 84, 1, 85, 1, 85, 1, 85,
		1, 85, 1, 86, 1, 86, 3, 86, 824, 8, 86, 1, 87, 1, 87, 1, 88, 1, 88, 1,
		88, 0, 0, 89, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30,
		32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66,
		68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102,
		104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132,
		134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162,
		164, 166, 168, 170, 172, 174, 176, 0, 10, 2, 0, 37, 38, 42, 43, 2, 0, 40,
		40, 47, 47, 1, 0, 1, 2, 2, 0, 1, 1, 3, 7, 1, 0, 18, 19, 2, 0, 20, 21, 23,
		23, 1, 0, 33, 36, 1, 0, 71, 72, 2, 0, 30, 35, 89, 90, 1, 0, 36, 88, 864,
		0, 178, 1, 0, 0, 0, 2, 186, 1, 0, 0, 0, 4, 188, 1, 0, 0, 0, 6, 197, 1,
		0, 0, 0, 8, 199, 1, 0, 0, 0, 10, 211, 1, 0, 0, 0, 12, 214, 1, 0, 0, 0,
		14, 219, 1, 0, 0, 0, 16, 222, 1, 0, 0, 0, 18, 226, 1, 0, 0, 0, 20, 240,
		1, 0, 0, 0, 22, 249, 1, 0, 0, 0, 24, 254, 1, 0, 0, 0, 26, 258, 1, 0, 0,
		0, 28, 271, 1, 0, 0, 0, 30, 288, 1, 0, 0, 0, 32, 305, 1, 0, 0, 0, 34, 310,
		1, 0, 0, 0, 36, 318, 1, 0, 0, 0, 38, 325, 1, 0, 0, 0, 40, 328, 1, 0, 0,
		0, 42, 333, 1, 0, 0, 0, 44, 346, 1, 0, 0, 0, 46, 348, 1, 0, 0, 0, 48, 355,
		1, 0, 0, 0, 50, 361, 1, 0, 0, 0, 52, 375, 1, 0, 0, 0, 54, 379, 1, 0, 0,
		0, 56, 387, 1, 0, 0, 0, 58, 391, 1, 0, 0, 0, 60, 411, 1, 0, 0, 0, 62, 415,
		1, 0, 0, 0, 64, 419, 1, 0, 0, 0, 66, 422, 1, 0, 0, 0, 68, 426, 1, 0, 0,
		0, 70, 429, 1, 0, 0, 0, 72, 437, 1, 0, 0, 0, 74, 445, 1, 0, 0, 0, 76, 453,
		1, 0, 0, 0, 78, 462, 1, 0, 0, 0, 80, 466, 1, 0, 0, 0, 82, 475, 1, 0, 0,
		0, 84, 477, 1, 0, 0, 0, 86, 485, 1, 0, 0, 0, 88, 493, 1, 0, 0, 0, 90, 502,
		1, 0, 0, 0, 92, 506, 1, 0, 0, 0, 94, 529, 1, 0, 0, 0, 96, 531, 1, 0, 0,
		0, 98, 539, 1, 0, 0, 0, 100, 541, 1, 0, 0, 0, 102, 547, 1, 0, 0, 0, 104,
		551, 1, 0, 0, 0, 106, 562, 1, 0, 0, 0, 108, 577, 1, 0, 0, 0, 110, 579,
		1, 0, 0, 0, 112, 584, 1, 0, 0, 0, 114, 586, 1, 0, 0, 0, 116, 610, 1, 0,
		0, 0, 118, 612, 1, 0, 0, 0, 120, 632, 1, 0, 0, 0, 122, 634, 1, 0, 0, 0,
		124, 649, 1, 0, 0, 0, 126, 661, 1, 0, 0, 0, 128, 667, 1, 0, 0, 0, 130,
		675, 1, 0, 0, 0, 132, 683, 1, 0, 0, 0, 134, 693, 1, 0, 0, 0, 136, 697,
		1, 0, 0, 0, 138, 702, 1, 0, 0, 0, 140, 714, 1, 0, 0, 0, 142, 720, 1, 0,
		0, 0, 144, 728, 1, 0, 0, 0, 146, 734, 1, 0, 0, 0, 148, 739, 1, 0, 0, 0,
		150, 747, 1, 0, 0, 0, 152, 766, 1, 0, 0, 0, 154, 778, 1, 0, 0, 0, 156,
		780, 1, 0, 0, 0, 158, 790, 1, 0, 0, 0, 160, 792, 1, 0, 0, 0, 162, 794,
		1, 0, 0, 0, 164, 796, 1, 0, 0, 0, 166, 798, 1, 0, 0, 0, 168, 804, 1, 0,
		0, 0, 170, 817, 1, 0, 0, 0, 172, 823, 1, 0, 0, 0, 174, 825, 1, 0, 0, 0,
		176, 827, 1, 0, 0, 0, 178, 180, 3, 2, 1, 0, 179, 181, 5, 9, 0, 0, 180,
		179, 1, 0, 0, 0, 180, 181, 1, 0, 0, 0, 181, 182, 1, 0, 0, 0, 182, 183,
		5, 0, 0, 1, 183, 1, 1, 0, 0, 0, 184, 187, 3, 4, 2, 0, 185, 187, 3, 8, 4,
		0, 186, 184, 1, 0, 0, 0, 186, 185, 1, 0, 0, 0, 187, 3, 1, 0, 0, 0, 188,
		192, 3, 6, 3, 0, 189, 191, 3, 126, 63, 0, 190, 189, 1, 0, 0, 0, 191, 194,
		1, 0, 0, 0, 192, 190, 1, 0, 0, 0, 192, 193, 1, 0, 0, 0, 193, 5, 1, 0, 0,
		0, 194, 192, 1, 0, 0, 0, 195, 198, 3, 28, 14, 0, 196, 198, 3, 30, 15, 0,
		197, 195, 1, 0, 0, 0, 197, 196, 1, 0, 0, 0, 198, 7, 1, 0, 0, 0, 199, 200,
		5, 28, 0, 0, 200, 202, 3, 130, 65, 0, 201, 203, 3, 48, 24, 0, 202, 201,
		1, 0, 0, 0, 202, 203, 1, 0, 0, 0, 203, 209, 1, 0, 0, 0, 204, 207, 5, 29,
		0, 0, 205, 208, 5, 23, 0, 0, 206, 208, 3, 50, 25, 0, 207, 205, 1, 0, 0,
		0, 207, 206, 1, 0, 0, 0, 208, 210, 1, 0, 0, 0, 209, 204, 1, 0, 0, 0, 209,
		210, 1, 0, 0, 0, 210, 9, 1, 0, 0, 0, 211, 212, 5, 53, 0, 0, 212, 213, 3,
		18, 9, 0, 213, 11, 1, 0, 0, 0, 214, 215, 5, 57, 0, 0, 215, 217, 3, 18,
		9, 0, 216, 218, 3, 68, 34, 0, 217, 216, 1, 0, 0, 0, 217, 218, 1, 0, 0,
		0, 218, 13, 1, 0, 0, 0, 219, 220, 5, 55, 0, 0, 220, 221, 3, 72, 36, 0,
		221, 15, 1, 0, 0, 0, 222, 223, 5, 46, 0, 0, 223, 224, 3, 72, 36, 0, 224,
		17, 1, 0, 0, 0, 225, 227, 5, 63, 0, 0, 226, 225, 1, 0, 0, 0, 226, 227,
		1, 0, 0, 0, 227, 228, 1, 0, 0, 0, 228, 230, 3, 20, 10, 0, 229, 231, 3,
		26, 13, 0, 230, 229, 1, 0, 0, 0, 230, 231, 1, 0, 0, 0, 231, 233, 1, 0,
		0, 0, 232, 234, 3, 14, 7, 0, 233, 232, 1, 0, 0, 0, 233, 234, 1, 0, 0, 0,
		234, 236, 1, 0, 0, 0, 235, 237, 3, 16, 8, 0, 236, 235, 1, 0, 0, 0, 236,
		237, 1, 0, 0, 0, 237, 19, 1, 0, 0, 0, 238, 241, 5, 23, 0, 0, 239, 241,
		3, 22, 11, 0, 240, 238, 1, 0, 0, 0, 240, 239, 1, 0, 0, 0, 241, 246, 1,
		0, 0, 0, 242, 243, 5, 11, 0, 0, 243, 245, 3, 22, 11, 0, 244, 242, 1, 0,
		0, 0, 245, 248, 1, 0, 0, 0, 246, 244, 1, 0, 0, 0, 246, 247, 1, 0, 0, 0,
		247, 21, 1, 0, 0, 0, 248, 246, 1, 0, 0, 0, 249, 252, 3, 72, 36, 0, 250,
		251, 5, 61, 0, 0, 251, 253, 3, 174, 87, 0, 252, 250, 1, 0, 0, 0, 252, 253,
		1, 0, 0, 0, 253, 23, 1, 0, 0, 0, 254, 256, 3, 72, 36, 0, 255, 257, 7, 0,
		0, 0, 256, 255, 1, 0, 0, 0, 256, 257, 1, 0, 0, 0, 257, 25, 1, 0, 0, 0,
		258, 259, 5, 51, 0, 0, 259, 260, 5, 39, 0, 0, 260, 265, 3, 24, 12, 0, 261,
		262, 5, 11, 0, 0, 262, 264, 3, 24, 12, 0, 263, 261, 1, 0, 0, 0, 264, 267,
		1, 0, 0, 0, 265, 263, 1, 0, 0, 0, 265, 266, 1, 0, 0, 0, 266, 27, 1, 0,
		0, 0, 267, 265, 1, 0, 0, 0, 268, 270, 3, 36, 18, 0, 269, 268, 1, 0, 0,
		0, 270, 273, 1, 0, 0, 0, 271, 269, 1, 0, 0, 0, 271, 272, 1, 0, 0, 0, 272,
		283, 1, 0, 0, 0, 273, 271, 1, 0, 0, 0, 274, 284, 3, 10, 5, 0, 275, 277,
		3, 38, 19, 0, 276, 275, 1, 0, 0, 0, 277, 278, 1, 0, 0, 0, 278, 276, 1,
		0, 0, 0, 278, 279, 1, 0, 0, 0, 279, 281, 1, 0, 0, 0, 280, 282, 3, 10, 5,
		0, 281, 280, 1, 0, 0, 0, 281, 282, 1, 0, 0, 0, 282, 284, 1, 0, 0, 0, 283,
		274, 1, 0, 0, 0, 283, 276, 1, 0, 0, 0, 284, 29, 1, 0, 0, 0, 285, 287, 3,
		36, 18, 0, 286, 285, 1, 0, 0, 0, 287, 290, 1, 0, 0, 0, 288, 286, 1, 0,
		0, 0, 288, 289, 1, 0, 0, 0, 289, 298, 1, 0, 0, 0, 290, 288, 1, 0, 0, 0,
		291, 293, 3, 38, 19, 0, 292, 291, 1, 0, 0, 0, 293, 296, 1, 0, 0, 0, 294,
		292, 1, 0, 0, 0, 294, 295, 1, 0, 0, 0, 295, 297, 1, 0, 0, 0, 296, 294,
		1, 0, 0, 0, 297, 299, 3, 12, 6, 0, 298, 294, 1, 0, 0, 0, 299, 300, 1, 0,
		0, 0, 300, 298, 1, 0, 0, 0, 300, 301, 1, 0, 0, 0, 301, 302, 1, 0, 0, 0,
		302, 303, 3, 28, 14, 0, 303, 31, 1, 0, 0, 0, 304, 306, 5, 50, 0, 0, 305,
		304, 1, 0, 0, 0, 305, 306, 1, 0, 0, 0, 306, 307, 1, 0, 0, 0, 307, 308,
		5, 47, 0, 0, 308, 309, 3, 66, 33, 0, 309, 33, 1, 0, 0, 0, 310, 311, 5,
		59, 0, 0, 311, 312, 3, 72, 36, 0, 312, 313, 5, 61, 0, 0, 313, 314, 3, 174,
		87, 0, 314, 35, 1, 0, 0, 0, 315, 319, 3, 32, 16, 0, 316, 319, 3, 34, 17,
		0, 317, 319, 3, 46, 23, 0, 318, 315, 1, 0, 0, 0, 318, 316, 1, 0, 0, 0,
		318, 317, 1, 0, 0, 0, 319, 37, 1, 0, 0, 0, 320, 326, 3, 64, 32, 0, 321,
		326, 3, 54, 27, 0, 322, 326, 3, 40, 20, 0, 323, 326, 3, 58, 29, 0, 324,
		326, 3, 42, 21, 0, 325, 320, 1, 0, 0, 0, 325, 321, 1, 0, 0, 0, 325, 322,
		1, 0, 0, 0, 325, 323, 1, 0, 0, 0, 325, 324, 1, 0, 0, 0, 326, 39, 1, 0,
		0, 0, 327, 329, 5, 44, 0, 0, 328, 327, 1, 0, 0, 0, 328, 329, 1, 0, 0, 0,
		329, 330, 1, 0, 0, 0, 330, 331, 5, 41, 0, 0, 331, 332, 3, 148, 74, 0, 332,
		41, 1, 0, 0, 0, 333, 334, 5, 52, 0, 0, 334, 339, 3, 44, 22, 0, 335, 336,
		5, 11, 0, 0, 336, 338, 3, 44, 22, 0, 337, 335, 1, 0, 0, 0, 338, 341, 1,
		0, 0, 0, 339, 337, 1, 0, 0, 0, 339, 340, 1, 0, 0, 0, 340, 43, 1, 0, 0,
		0, 341, 339, 1, 0, 0, 0, 342, 343, 3, 174, 87, 0, 343, 344, 3, 62, 31,
		0, 344, 347, 1, 0, 0, 0, 345, 347, 3, 104, 52, 0, 346, 342, 1, 0, 0, 0,
		346, 345, 1, 0, 0, 0, 347, 45, 1, 0, 0, 0, 348, 349, 5, 28, 0, 0, 349,
		350, 3, 130, 65, 0, 350, 353, 3, 48, 24, 0, 351, 352, 5, 29, 0, 0, 352,
		354, 3, 50, 25, 0, 353, 351, 1, 0, 0, 0, 353, 354, 1, 0, 0, 0, 354, 47,
		1, 0, 0, 0, 355, 357, 5, 12, 0, 0, 356, 358, 3, 148, 74, 0, 357, 356, 1,
		0, 0, 0, 357, 358, 1, 0, 0, 0, 358, 359, 1, 0, 0, 0, 359, 360, 5, 13, 0,
		0, 360, 49, 1, 0, 0, 0, 361, 366, 3, 52, 26, 0, 362, 363, 5, 11, 0, 0,
		363, 365, 3, 52, 26, 0, 364, 362, 1, 0, 0, 0, 365, 368, 1, 0, 0, 0, 366,
		364, 1, 0, 0, 0, 366, 367, 1, 0, 0, 0, 367, 370, 1, 0, 0, 0, 368, 366,
		1, 0, 0, 0, 369, 371, 3, 68, 34, 0, 370, 369, 1, 0, 0, 0, 370, 371, 1,
		0, 0, 0, 371, 51, 1, 0, 0, 0, 372, 373, 3, 174, 87, 0, 373, 374, 5, 61,
		0, 0, 374, 376, 1, 0, 0, 0, 375, 372, 1, 0, 0, 0, 375, 376, 1, 0, 0, 0,
		376, 377, 1, 0, 0, 0, 377, 378, 3, 174, 87, 0, 378, 53, 1, 0, 0, 0, 379,
		380, 5, 48, 0, 0, 380, 384, 3, 106, 53, 0, 381, 383, 3, 56, 28, 0, 382,
		381, 1, 0, 0, 0, 383, 386, 1, 0, 0, 0, 384, 382, 1, 0, 0, 0, 384, 385,
		1, 0, 0, 0, 385, 55, 1, 0, 0, 0, 386, 384, 1, 0, 0, 0, 387, 388, 5, 49,
		0, 0, 388, 389, 7, 1, 0, 0, 389, 390, 3, 58, 29, 0, 390, 57, 1, 0, 0, 0,
		391, 392, 5, 54, 0, 0, 392, 397, 3, 60, 30, 0, 393, 394, 5, 11, 0, 0, 394,
		396, 3, 60, 30, 0, 395, 393, 1, 0, 0, 0, 396, 399, 1, 0, 0, 0, 397, 395,
		1, 0, 0, 0, 397, 398, 1, 0, 0, 0, 398, 59, 1, 0, 0, 0, 399, 397, 1, 0,
		0, 0, 400, 401, 3, 104, 52, 0, 401, 402, 5, 1, 0, 0, 402, 403, 3, 72, 36,
		0, 403, 412, 1, 0, 0, 0, 404, 405, 3, 174, 87, 0, 405, 406, 7, 2, 0, 0,
		406, 407, 3, 72, 36, 0, 407, 412, 1, 0, 0, 0, 408, 409, 3, 174, 87, 0,
		409, 410, 3, 62, 31, 0, 410, 412, 1, 0, 0, 0, 411, 400, 1, 0, 0, 0, 411,
		404, 1, 0, 0, 0, 411, 408, 1, 0, 0, 0, 412, 61, 1, 0, 0, 0, 413, 414, 5,
		25, 0, 0, 414, 416, 3, 172, 86, 0, 415, 413, 1, 0, 0, 0, 416, 417, 1, 0,
		0, 0, 417, 415, 1, 0, 0, 0, 417, 418, 1, 0, 0, 0, 418, 63, 1, 0, 0, 0,
		419, 420, 5, 40, 0, 0, 420, 421, 3, 70, 35, 0, 421, 65, 1, 0, 0, 0, 422,
		424, 3, 70, 35, 0, 423, 425, 3, 68, 34, 0, 424, 423, 1, 0, 0, 0, 424, 425,
		1, 0, 0, 0, 425, 67, 1, 0, 0, 0, 426, 427, 5, 56, 0, 0, 427, 428, 3, 72,
		36, 0, 428, 69, 1, 0, 0, 0, 429, 434, 3, 106, 53, 0, 430, 431, 5, 11, 0,
		0, 431, 433, 3, 106, 53, 0, 432, 430, 1, 0, 0, 0, 433, 436, 1, 0, 0, 0,
		434, 432, 1, 0, 0, 0, 434, 435, 1, 0, 0, 0, 435, 71, 1, 0, 0, 0, 436, 434,
		1, 0, 0, 0, 437, 442, 3, 74, 37, 0, 438, 439, 5, 68, 0, 0, 439, 441, 3,
		74, 37, 0, 440, 438, 1, 0, 0, 0, 441, 444, 1, 0, 0, 0, 442, 440, 1, 0,
		0, 0, 442, 443, 1, 0, 0, 0, 443, 73, 1, 0, 0, 0, 444, 442, 1, 0, 0, 0,
		445, 450, 3, 76, 38, 0, 446, 447, 5, 70, 0, 0, 447, 449, 3, 76, 38, 0,
		448, 446, 1, 0, 0, 0, 449, 452, 1, 0, 0, 0, 450, 448, 1, 0, 0, 0, 450,
		451, 1, 0, 0, 0, 451, 75, 1, 0, 0, 0, 452, 450, 1, 0, 0, 0, 453, 458, 3,
		78, 39, 0, 454, 455, 5, 60, 0, 0, 455, 457, 3, 78, 39, 0, 456, 454, 1,
		0, 0, 0, 457, 460, 1, 0, 0, 0, 458, 456, 1, 0, 0, 0, 458, 459, 1, 0, 0,
		0, 459, 77, 1, 0, 0, 0, 460, 458, 1, 0, 0, 0, 461, 463, 5, 67, 0, 0, 462,
		461, 1, 0, 0, 0, 462, 463, 1, 0, 0, 0, 463, 464, 1, 0, 0, 0, 464, 465,
		3, 80, 40, 0, 465, 79, 1, 0, 0, 0, 466, 472, 3, 84, 42, 0, 467, 468, 3,
		82, 41, 0, 468, 469, 3, 84, 42, 0, 469, 471, 1, 0, 0, 0, 470, 467, 1, 0,
		0, 0, 471, 474, 1, 0, 0, 0, 472, 470, 1, 0, 0, 0, 472, 473, 1, 0, 0, 0,
		473, 81, 1, 0, 0, 0, 474, 472, 1, 0, 0, 0, 475, 476, 7, 3, 0, 0, 476, 83,
		1, 0, 0, 0, 477, 482, 3, 86, 43, 0, 478, 479, 7, 4, 0, 0, 479, 481, 3,
		86, 43, 0, 480, 478, 1, 0, 0, 0, 481, 484, 1, 0, 0, 0, 482, 480, 1, 0,
		0, 0, 482, 483, 1, 0, 0, 0, 483, 85, 1, 0, 0, 0, 484, 482, 1, 0, 0, 0,
		485, 490, 3, 88, 44, 0, 486, 487, 7, 5, 0, 0, 487, 489, 3, 88, 44, 0, 488,
		486, 1, 0, 0, 0, 489, 492, 1, 0, 0, 0, 490, 488, 1, 0, 0, 0, 490, 491,
		1, 0, 0, 0, 491, 87, 1, 0, 0, 0, 492, 490, 1, 0, 0, 0, 493, 498, 3, 90,
		45, 0, 494, 495, 5, 22, 0, 0, 495, 497, 3, 90, 45, 0, 496, 494, 1, 0, 0,
		0, 497, 500, 1, 0, 0, 0, 498, 496, 1, 0, 0, 0, 498, 499, 1, 0, 0, 0, 499,
		89, 1, 0, 0, 0, 500, 498, 1, 0, 0, 0, 501, 503, 7, 4, 0, 0, 502, 501, 1,
		0, 0, 0, 502, 503, 1, 0, 0, 0, 503, 504, 1, 0, 0, 0, 504, 505, 3, 92, 46,
		0, 505, 91, 1, 0, 0, 0, 506, 512, 3, 102, 51, 0, 507, 511, 3, 96, 48, 0,
		508, 511, 3, 94, 47, 0, 509, 511, 3, 100, 50, 0, 510, 507, 1, 0, 0, 0,
		510, 508, 1, 0, 0, 0, 510, 509, 1, 0, 0, 0, 511, 514, 1, 0, 0, 0, 512,
		510, 1, 0, 0, 0, 512, 513, 1, 0, 0, 0, 513, 93, 1, 0, 0, 0, 514, 512, 1,
		0, 0, 0, 515, 516, 5, 65, 0, 0, 516, 530, 3, 102, 51, 0, 517, 526, 5, 16,
		0, 0, 518, 520, 3, 72, 36, 0, 519, 518, 1, 0, 0, 0, 519, 520, 1, 0, 0,
		0, 520, 521, 1, 0, 0, 0, 521, 523, 5, 8, 0, 0, 522, 524, 3, 72, 36, 0,
		523, 522, 1, 0, 0, 0, 523, 524, 1, 0, 0, 0, 524, 527, 1, 0, 0, 0, 525,
		527, 3, 72, 36, 0, 526, 519, 1, 0, 0, 0, 526, 525, 1, 0, 0, 0, 527, 528,
		1, 0, 0, 0, 528, 530, 5, 17, 0, 0, 529, 515, 1, 0, 0, 0, 529, 517, 1, 0,
		0, 0, 530, 95, 1, 0, 0, 0, 531, 532, 3, 98, 49, 0, 532, 533, 3, 102, 51,
		0, 533, 97, 1, 0, 0, 0, 534, 535, 5, 69, 0, 0, 535, 540, 5, 57, 0, 0, 536,
		537, 5, 64, 0, 0, 537, 540, 5, 57, 0, 0, 538, 540, 5, 62, 0, 0, 539, 534,
		1, 0, 0, 0, 539, 536, 1, 0, 0, 0, 539, 538, 1, 0, 0, 0, 540, 99, 1, 0,
		0, 0, 541, 543, 5, 66, 0, 0, 542, 544, 5, 67, 0, 0, 543, 542, 1, 0, 0,
		0, 543, 544, 1, 0, 0, 0, 544, 545, 1, 0, 0, 0, 545, 546, 5, 73, 0, 0, 546,
		101, 1, 0, 0, 0, 547, 549, 3, 104, 52, 0, 548, 550, 3, 62, 31, 0, 549,
		548, 1, 0, 0, 0, 549, 550, 1, 0, 0, 0, 550, 103, 1, 0, 0, 0, 551, 556,
		3, 116, 58, 0, 552, 553, 5, 10, 0, 0, 553, 555, 3, 172, 86, 0, 554, 552,
		1, 0, 0, 0, 555, 558, 1, 0, 0, 0, 556, 554, 1, 0, 0, 0, 556, 557, 1, 0,
		0, 0, 557, 105, 1, 0, 0, 0, 558, 556, 1, 0, 0, 0, 559, 560, 3, 174, 87,
		0, 560, 561, 5, 1, 0, 0, 561, 563, 1, 0, 0, 0, 562, 559, 1, 0, 0, 0, 562,
		563, 1, 0, 0, 0, 563, 564, 1, 0, 0, 0, 564, 565, 3, 108, 54, 0, 565, 107,
		1, 0, 0, 0, 566, 570, 3, 114, 57, 0, 567, 569, 3, 110, 55, 0, 568, 567,
		1, 0, 0, 0, 569, 572, 1, 0, 0, 0, 570, 568, 1, 0, 0, 0, 570, 571, 1, 0,
		0, 0, 571, 578, 1, 0, 0, 0, 572, 570, 1, 0, 0, 0, 573, 574, 5, 12, 0, 0,
		574, 575, 3, 108, 54, 0, 575, 576, 5, 13, 0, 0, 576, 578, 1, 0, 0, 0, 577,
		566, 1, 0, 0, 0, 577, 573, 1, 0, 0, 0, 578, 109, 1, 0, 0, 0, 579, 580,
		3, 120, 60, 0, 580, 581, 3, 114, 57, 0, 581, 111, 1, 0, 0, 0, 582, 585,
		3, 168, 84, 0, 583, 585, 3, 152, 76, 0, 584, 582, 1, 0, 0, 0, 584, 583,
		1, 0, 0, 0, 585, 113, 1, 0, 0, 0, 586, 588, 5, 12, 0, 0, 587, 589, 3, 174,
		87, 0, 588, 587, 1, 0, 0, 0, 588, 589, 1, 0, 0, 0, 589, 591, 1, 0, 0, 0,
		590, 592, 3, 62, 31, 0, 591, 590, 1, 0, 0, 0, 591, 592, 1, 0, 0, 0, 592,
		594, 1, 0, 0, 0, 593, 595, 3, 112, 56, 0, 594, 593, 1, 0, 0, 0, 594, 595,
		1, 0, 0, 0, 595, 596, 1, 0, 0, 0, 596, 597, 5, 13, 0, 0, 597, 115, 1, 0,
		0, 0, 598, 611, 3, 154, 77, 0, 599, 611, 3, 152, 76, 0, 600, 611, 3, 150,
		75, 0, 601, 611, 3, 146, 73, 0, 602, 611, 3, 142, 71, 0, 603, 611, 3, 138,
		69, 0, 604, 611, 3, 136, 68, 0, 605, 611, 3, 140, 70, 0, 606, 611, 3, 134,
		67, 0, 607, 611, 3, 132, 66, 0, 608, 611, 3, 174, 87, 0, 609, 611, 3, 128,
		64, 0, 610, 598, 1, 0, 0, 0, 610, 599, 1, 0, 0, 0, 610, 600, 1, 0, 0, 0,
		610, 601, 1, 0, 0, 0, 610, 602, 1, 0, 0, 0, 610, 603, 1, 0, 0, 0, 610,
		604, 1, 0, 0, 0, 610, 605, 1, 0, 0, 0, 610, 606, 1, 0, 0, 0, 610, 607,
		1, 0, 0, 0, 610, 608, 1, 0, 0, 0, 610, 609, 1, 0, 0, 0, 611, 117, 1, 0,
		0, 0, 612, 613, 3, 174, 87, 0, 613, 614, 5, 1, 0, 0, 614, 119, 1, 0, 0,
		0, 615, 616, 5, 6, 0, 0, 616, 618, 5, 18, 0, 0, 617, 619, 3, 122, 61, 0,
		618, 617, 1, 0, 0, 0, 618, 619, 1, 0, 0, 0, 619, 620, 1, 0, 0, 0, 620,
		622, 5, 18, 0, 0, 621, 623, 5, 5, 0, 0, 622, 621, 1, 0, 0, 0, 622, 623,
		1, 0, 0, 0, 623, 633, 1, 0, 0, 0, 624, 626, 5, 18, 0, 0, 625, 627, 3, 122,
		61, 0, 626, 625, 1, 0, 0, 0, 626, 627, 1, 0, 0, 0, 627, 628, 1, 0, 0, 0,
		628, 630, 5, 18, 0, 0, 629, 631, 5, 5, 0, 0, 630, 629, 1, 0, 0, 0, 630,
		631, 1, 0, 0, 0, 631, 633, 1, 0, 0, 0, 632, 615, 1, 0, 0, 0, 632, 624,
		1, 0, 0, 0, 633, 121, 1, 0, 0, 0, 634, 636, 5, 16, 0, 0, 635, 637, 3, 174,
		87, 0, 636, 635, 1, 0, 0, 0, 636, 637, 1, 0, 0, 0, 637, 639, 1, 0, 0, 0,
		638, 640, 3, 124, 62, 0, 639, 638, 1, 0, 0, 0, 639, 640, 1, 0, 0, 0, 640,
		642, 1, 0, 0, 0, 641, 643, 3, 156, 78, 0, 642, 641, 1, 0, 0, 0, 642, 643,
		1, 0, 0, 0, 643, 645, 1, 0, 0, 0, 644, 646, 3, 112, 56, 0, 645, 644, 1,
		0, 0, 0, 645, 646, 1, 0, 0, 0, 646, 647, 1, 0, 0, 0, 647, 648, 5, 17, 0,
		0, 648, 123, 1, 0, 0, 0, 649, 650, 5, 25, 0, 0, 650, 658, 3, 172, 86, 0,
		651, 653, 5, 26, 0, 0, 652, 654, 5, 25, 0, 0, 653, 652, 1, 0, 0, 0, 653,
		654, 1, 0, 0, 0, 654, 655, 1, 0, 0, 0, 655, 657, 3, 172, 86, 0, 656, 651,
		1, 0, 0, 0, 657, 660, 1, 0, 0, 0, 658, 656, 1, 0, 0, 0, 658, 659, 1, 0,
		0, 0, 659, 125, 1, 0, 0, 0, 660, 658, 1, 0, 0, 0, 661, 663, 5, 58, 0, 0,
		662, 664, 5, 36, 0, 0, 663, 662, 1, 0, 0, 0, 663, 664, 1, 0, 0, 0, 664,
		665, 1, 0, 0, 0, 665, 666, 3, 6, 3, 0, 666, 127, 1, 0, 0, 0, 667, 668,
		5, 45, 0, 0, 668, 671, 5, 14, 0, 0, 669, 672, 3, 4, 2, 0, 670, 672, 3,
		66, 33, 0, 671, 669, 1, 0, 0, 0, 671, 670, 1, 0, 0, 0, 672, 673, 1, 0,
		0, 0, 673, 674, 5, 15, 0, 0, 674, 129, 1, 0, 0, 0, 675, 680, 3, 174, 87,
		0, 676, 677, 5, 10, 0, 0, 677, 679, 3, 174, 87, 0, 678, 676, 1, 0, 0, 0,
		679, 682, 1, 0, 0, 0, 680, 678, 1, 0, 0, 0, 680, 681, 1, 0, 0, 0, 681,
		131, 1, 0, 0, 0, 682, 680, 1, 0, 0, 0, 683, 684, 3, 130, 65, 0, 684, 686,
		5, 12, 0, 0, 685, 687, 5, 63, 0, 0, 686, 685, 1, 0, 0, 0, 686, 687, 1,
		0, 0, 0, 687, 689, 1, 0, 0, 0, 688, 690, 3, 148, 74, 0, 689, 688, 1, 0,
		0, 0, 689, 690, 1, 0, 0, 0, 690, 691, 1, 0, 0, 0, 691, 692, 5, 13, 0, 0,
		692, 133, 1, 0, 0, 0, 693, 694, 5, 12, 0, 0, 694, 695, 3, 72, 36, 0, 695,
		696, 5, 13, 0, 0, 696, 135, 1, 0, 0, 0, 697, 698, 7, 6, 0, 0, 698, 699,
		5, 12, 0, 0, 699, 700, 3, 144, 72, 0, 700, 701, 5, 13, 0, 0, 701, 137,
		1, 0, 0, 0, 702, 704, 5, 16, 0, 0, 703, 705, 3, 118, 59, 0, 704, 703, 1,
		0, 0, 0, 704, 705, 1, 0, 0, 0, 705, 706, 1, 0, 0, 0, 706, 708, 3, 140,
		70, 0, 707, 709, 3, 68, 34, 0, 708, 707, 1, 0, 0, 0, 708, 709, 1, 0, 0,
		0, 709, 710, 1, 0, 0, 0, 710, 711, 5, 26, 0, 0, 711, 712, 3, 72, 36, 0,
		712, 713, 5, 17, 0, 0, 713, 139, 1, 0, 0, 0, 714, 716, 3, 114, 57, 0, 715,
		717, 3, 110, 55, 0, 716, 715, 1, 0, 0, 0, 717, 718, 1, 0, 0, 0, 718, 716,
		1, 0, 0, 0, 718, 719, 1, 0, 0, 0, 719, 141, 1, 0, 0, 0, 720, 721, 5, 16,
		0, 0, 721, 724, 3, 144, 72, 0, 722, 723, 5, 26, 0, 0, 723, 725, 3, 72,
		36, 0, 724, 722, 1, 0, 0, 0, 724, 725, 1, 0, 0, 0, 725, 726, 1, 0, 0, 0,
		726, 727, 5, 17, 0, 0, 727, 143, 1, 0, 0, 0, 728, 729, 3, 174, 87, 0, 729,
		730, 5, 65, 0, 0, 730, 732, 3, 72, 36, 0, 731, 733, 3, 68, 34, 0, 732,
		731, 1, 0, 0, 0, 732, 733, 1, 0, 0, 0, 733, 145, 1, 0, 0, 0, 734, 735,
		5, 32, 0, 0, 735, 736, 5, 12, 0, 0, 736, 737, 5, 23, 0, 0, 737, 738, 5,
		13, 0, 0, 738, 147, 1, 0, 0, 0, 739, 744, 3, 72, 36, 0, 740, 741, 5, 11,
		0, 0, 741, 743, 3, 72, 36, 0, 742, 740, 1, 0, 0, 0, 743, 746, 1, 0, 0,
		0, 744, 742, 1, 0, 0, 0, 744, 745, 1, 0, 0, 0, 745, 149, 1, 0, 0, 0, 746,
		744, 1, 0, 0, 0, 747, 749, 5, 79, 0, 0, 748, 750, 3, 72, 36, 0, 749, 748,
		1, 0, 0, 0, 749, 750, 1, 0, 0, 0, 750, 756, 1, 0, 0, 0, 751, 752, 5, 80,
		0, 0, 752, 753, 3, 72, 36, 0, 753, 754, 5, 81, 0, 0, 754, 755, 3, 72, 36,
		0, 755, 757, 1, 0, 0, 0, 756, 751, 1, 0, 0, 0, 757, 758, 1, 0, 0, 0, 758,
		756, 1, 0, 0, 0, 758, 759, 1, 0, 0, 0, 759, 762, 1, 0, 0, 0, 760, 761,
		5, 82, 0, 0, 761, 763, 3, 72, 36, 0, 762, 760, 1, 0, 0, 0, 762, 763, 1,
		0, 0, 0, 763, 764, 1, 0, 0, 0, 764, 765, 5, 83, 0, 0, 765, 151, 1, 0, 0,
		0, 766, 769, 5, 27, 0, 0, 767, 770, 3, 174, 87, 0, 768, 770, 3, 160, 80,
		0, 769, 767, 1, 0, 0, 0, 769, 768, 1, 0, 0, 0, 770, 153, 1, 0, 0, 0, 771,
		779, 3, 158, 79, 0, 772, 779, 3, 160, 80, 0, 773, 779, 5, 73, 0, 0, 774,
		779, 3, 162, 81, 0, 775, 779, 3, 164, 82, 0, 776, 779, 3, 166, 83, 0, 777,
		779, 3, 168, 84, 0, 778, 771, 1, 0, 0, 0, 778, 772, 1, 0, 0, 0, 778, 773,
		1, 0, 0, 0, 778, 774, 1, 0, 0, 0, 778, 775, 1, 0, 0, 0, 778, 776, 1, 0,
		0, 0, 778, 777, 1, 0, 0, 0, 779, 155, 1, 0, 0, 0, 780, 782, 5, 23, 0, 0,
		781, 783, 3, 160, 80, 0, 782, 781, 1, 0, 0, 0, 782, 783, 1, 0, 0, 0, 783,
		788, 1, 0, 0, 0, 784, 786, 5, 8, 0, 0, 785, 787, 3, 160, 80, 0, 786, 785,
		1, 0, 0, 0, 786, 787, 1, 0, 0, 0, 787, 789, 1, 0, 0, 0, 788, 784, 1, 0,
		0, 0, 788, 789, 1, 0, 0, 0, 789, 157, 1, 0, 0, 0, 790, 791, 7, 7, 0, 0,
		791, 159, 1, 0, 0, 0, 792, 793, 5, 93, 0, 0, 793, 161, 1, 0, 0, 0, 794,
		795, 5, 92, 0, 0, 795, 163, 1, 0, 0, 0, 796, 797, 5, 91, 0, 0, 797, 165,
		1, 0, 0, 0, 798, 800, 5, 16, 0, 0, 799, 801, 3, 148, 74, 0, 800, 799, 1,
		0, 0, 0, 800, 801, 1, 0, 0, 0, 801, 802, 1, 0, 0, 0, 802, 803, 5, 17, 0,
		0, 803, 167, 1, 0, 0, 0, 804, 813, 5, 14, 0, 0, 805, 810, 3, 170, 85, 0,
		806, 807, 5, 11, 0, 0, 807, 809, 3, 170, 85, 0, 808, 806, 1, 0, 0, 0, 809,
		812, 1, 0, 0, 0, 810, 808, 1, 0, 0, 0, 810, 811, 1, 0, 0, 0, 811, 814,
		1, 0, 0, 0, 812, 810, 1, 0, 0, 0, 813, 805, 1, 0, 0, 0, 813, 814, 1, 0,
		0, 0, 814, 815, 1, 0, 0, 0, 815, 816, 5, 15, 0, 0, 816, 169, 1, 0, 0, 0,
		817, 818, 3, 172, 86, 0, 818, 819, 5, 25, 0, 0, 819, 820, 3, 72, 36, 0,
		820, 171, 1, 0, 0, 0, 821, 824, 3, 174, 87, 0, 822, 824, 3, 176, 88, 0,
		823, 821, 1, 0, 0, 0, 823, 822, 1, 0, 0, 0, 824, 173, 1, 0, 0, 0, 825,
		826, 7, 8, 0, 0, 826, 175, 1, 0, 0, 0, 827, 828, 7, 9, 0, 0, 828, 177,
		1, 0, 0, 0, 102, 180, 186, 192, 197, 202, 207, 209, 217, 226, 230, 233,
		236, 240, 246, 252, 256, 265, 271, 278, 281, 283, 288, 294, 300, 305, 318,
		325, 328, 339, 346, 353, 357, 366, 370, 375, 384, 397, 411, 417, 424, 434,
		442, 450, 458, 462, 472, 482, 490, 498, 502, 510, 512, 519, 523, 526, 529,
		539, 543, 549, 556, 562, 570, 577, 584, 588, 591, 594, 610, 618, 622, 626,
		630, 632, 636, 639, 642, 645, 653, 658, 663, 671, 680, 686, 689, 704, 708,
		718, 724, 732, 744, 749, 758, 762, 769, 778, 782, 786, 788, 800, 810, 813,
		823,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// CypherParserInit initializes any static state used to implement CypherParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewCypherParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func CypherParserInit() {
	staticData := &CypherParserParserStaticData
	staticData.once.Do(cypherparserParserInit)
}

// NewCypherParser produces a new parser instance for the optional input antlr.TokenStream.
func NewCypherParser(input antlr.TokenStream) *CypherParser {
	CypherParserInit()
	this := new(CypherParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &CypherParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "CypherParser.g4"

	return this
}

// CypherParser tokens.
const (
	CypherParserEOF            = antlr.TokenEOF
	CypherParserASSIGN         = 1
	CypherParserADD_ASSIGN     = 2
	CypherParserLE             = 3
	CypherParserGE             = 4
	CypherParserGT             = 5
	CypherParserLT             = 6
	CypherParserNOT_EQUAL      = 7
	CypherParserRANGE          = 8
	CypherParserSEMI           = 9
	CypherParserDOT            = 10
	CypherParserCOMMA          = 11
	CypherParserLPAREN         = 12
	CypherParserRPAREN         = 13
	CypherParserLBRACE         = 14
	CypherParserRBRACE         = 15
	CypherParserLBRACK         = 16
	CypherParserRBRACK         = 17
	CypherParserSUB            = 18
	CypherParserPLUS           = 19
	CypherParserDIV            = 20
	CypherParserMOD            = 21
	CypherParserCARET          = 22
	CypherParserMULT           = 23
	CypherParserESC            = 24
	CypherParserCOLON          = 25
	CypherParserSTICK          = 26
	CypherParserDOLLAR         = 27
	CypherParserCALL           = 28
	CypherParserYIELD          = 29
	CypherParserFILTER         = 30
	CypherParserEXTRACT        = 31
	CypherParserCOUNT          = 32
	CypherParserANY            = 33
	CypherParserNONE           = 34
	CypherParserSINGLE         = 35
	CypherParserALL            = 36
	CypherParserASC            = 37
	CypherParserASCENDING      = 38
	CypherParserBY             = 39
	CypherParserCREATE         = 40
	CypherParserDELETE         = 41
	CypherParserDESC           = 42
	CypherParserDESCENDING     = 43
	CypherParserDETACH         = 44
	CypherParserEXISTS         = 45
	CypherParserLIMIT          = 46
	CypherParserMATCH          = 47
	CypherParserMERGE          = 48
	CypherParserON             = 49
	CypherParserOPTIONAL       = 50
	CypherParserORDER          = 51
	CypherParserREMOVE         = 52
	CypherParserRETURN         = 53
	CypherParserSET            = 54
	CypherParserSKIP_W         = 55
	CypherParserWHERE          = 56
	CypherParserWITH           = 57
	CypherParserUNION          = 58
	CypherParserUNWIND         = 59
	CypherParserAND            = 60
	CypherParserAS             = 61
	CypherParserCONTAINS       = 62
	CypherParserDISTINCT       = 63
	CypherParserENDS           = 64
	CypherParserIN             = 65
	CypherParserIS             = 66
	CypherParserNOT            = 67
	CypherParserOR             = 68
	CypherParserSTARTS         = 69
	CypherParserXOR            = 70
	CypherParserFALSE          = 71
	CypherParserTRUE           = 72
	CypherParserNULL_W         = 73
	CypherParserCONSTRAINT     = 74
	CypherParserDO             = 75
	CypherParserFOR            = 76
	CypherParserREQUIRE        = 77
	CypherParserUNIQUE         = 78
	CypherParserCASE           = 79
	CypherParserWHEN           = 80
	CypherParserTHEN           = 81
	CypherParserELSE           = 82
	CypherParserEND            = 83
	CypherParserMANDATORY      = 84
	CypherParserSCALAR         = 85
	CypherParserOF             = 86
	CypherParserADD            = 87
	CypherParserDROP           = 88
	CypherParserID             = 89
	CypherParserESC_LITERAL    = 90
	CypherParserCHAR_LITERAL   = 91
	CypherParserSTRING_LITERAL = 92
	CypherParserDIGIT          = 93
	CypherParserFLOAT          = 94
	CypherParserWS             = 95
	CypherParserCOMMENT        = 96
	CypherParserLINE_COMMENT   = 97
	CypherParserERRCHAR        = 98
	CypherParserLetter         = 99
)

// CypherParser rules.
const (
	CypherParserRULE_script                    = 0
	CypherParserRULE_query                     = 1
	CypherParserRULE_regularQuery              = 2
	CypherParserRULE_singleQuery               = 3
	CypherParserRULE_standaloneCall            = 4
	CypherParserRULE_returnSt                  = 5
	CypherParserRULE_withSt                    = 6
	CypherParserRULE_skipSt                    = 7
	CypherParserRULE_limitSt                   = 8
	CypherParserRULE_projectionBody            = 9
	CypherParserRULE_projectionItems           = 10
	CypherParserRULE_projectionItem            = 11
	CypherParserRULE_orderItem                 = 12
	CypherParserRULE_orderSt                   = 13
	CypherParserRULE_singlePartQ               = 14
	CypherParserRULE_multiPartQ                = 15
	CypherParserRULE_matchSt                   = 16
	CypherParserRULE_unwindSt                  = 17
	CypherParserRULE_readingStatement          = 18
	CypherParserRULE_updatingStatement         = 19
	CypherParserRULE_deleteSt                  = 20
	CypherParserRULE_removeSt                  = 21
	CypherParserRULE_removeItem                = 22
	CypherParserRULE_queryCallSt               = 23
	CypherParserRULE_parenExpressionChain      = 24
	CypherParserRULE_yieldItems                = 25
	CypherParserRULE_yieldItem                 = 26
	CypherParserRULE_mergeSt                   = 27
	CypherParserRULE_mergeAction               = 28
	CypherParserRULE_setSt                     = 29
	CypherParserRULE_setItem                   = 30
	CypherParserRULE_nodeLabels                = 31
	CypherParserRULE_createSt                  = 32
	CypherParserRULE_patternWhere              = 33
	CypherParserRULE_where                     = 34
	CypherParserRULE_pattern                   = 35
	CypherParserRULE_expression                = 36
	CypherParserRULE_xorExpression             = 37
	CypherParserRULE_andExpression             = 38
	CypherParserRULE_notExpression             = 39
	CypherParserRULE_comparisonExpression      = 40
	CypherParserRULE_comparisonSigns           = 41
	CypherParserRULE_addSubExpression          = 42
	CypherParserRULE_multDivExpression         = 43
	CypherParserRULE_powerExpression           = 44
	CypherParserRULE_unaryAddSubExpression     = 45
	CypherParserRULE_atomicExpression          = 46
	CypherParserRULE_listExpression            = 47
	CypherParserRULE_stringExpression          = 48
	CypherParserRULE_stringExpPrefix           = 49
	CypherParserRULE_nullExpression            = 50
	CypherParserRULE_propertyOrLabelExpression = 51
	CypherParserRULE_propertyExpression        = 52
	CypherParserRULE_patternPart               = 53
	CypherParserRULE_patternElem               = 54
	CypherParserRULE_patternElemChain          = 55
	CypherParserRULE_properties                = 56
	CypherParserRULE_nodePattern               = 57
	CypherParserRULE_atom                      = 58
	CypherParserRULE_lhs                       = 59
	CypherParserRULE_relationshipPattern       = 60
	CypherParserRULE_relationDetail            = 61
	CypherParserRULE_relationshipTypes         = 62
	CypherParserRULE_unionSt                   = 63
	CypherParserRULE_subqueryExist             = 64
	CypherParserRULE_invocationName            = 65
	CypherParserRULE_functionInvocation        = 66
	CypherParserRULE_parenthesizedExpression   = 67
	CypherParserRULE_filterWith                = 68
	CypherParserRULE_patternComprehension      = 69
	CypherParserRULE_relationshipsChainPattern = 70
	CypherParserRULE_listComprehension         = 71
	CypherParserRULE_filterExpression          = 72
	CypherParserRULE_countAll                  = 73
	CypherParserRULE_expressionChain           = 74
	CypherParserRULE_caseExpression            = 75
	CypherParserRULE_parameter                 = 76
	CypherParserRULE_literal                   = 77
	CypherParserRULE_rangeLit                  = 78
	CypherParserRULE_boolLit                   = 79
	CypherParserRULE_numLit                    = 80
	CypherParserRULE_stringLit                 = 81
	CypherParserRULE_charLit                   = 82
	CypherParserRULE_listLit                   = 83
	CypherParserRULE_mapLit                    = 84
	CypherParserRULE_mapPair                   = 85
	CypherParserRULE_name                      = 86
	CypherParserRULE_symbol                    = 87
	CypherParserRULE_reservedWord              = 88
)

// IScriptContext is an interface to support dynamic dispatch.
type IScriptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Query() IQueryContext
	EOF() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsScriptContext differentiates from other interfaces.
	IsScriptContext()
}

type ScriptContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScriptContext() *ScriptContext {
	var p = new(ScriptContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_script
	return p
}

func InitEmptyScriptContext(p *ScriptContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_script
}

func (*ScriptContext) IsScriptContext() {}

func NewScriptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScriptContext {
	var p = new(ScriptContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_script

	return p
}

func (s *ScriptContext) GetParser() antlr.Parser { return s.parser }

func (s *ScriptContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *ScriptContext) EOF() antlr.TerminalNode {
	return s.GetToken(CypherParserEOF, 0)
}

func (s *ScriptContext) SEMI() antlr.TerminalNode {
	return s.GetToken(CypherParserSEMI, 0)
}

func (s *ScriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScriptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterScript(s)
	}
}

func (s *ScriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitScript(s)
	}
}

func (s *ScriptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitScript(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Script() (localctx IScriptContext) {
	localctx = NewScriptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, CypherParserRULE_script)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(178)
		p.Query()
	}
	p.SetState(180)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSEMI {
		{
			p.SetState(179)
			p.Match(CypherParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(182)
		p.Match(CypherParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RegularQuery() IRegularQueryContext
	StandaloneCall() IStandaloneCallContext

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_query
	return p
}

func InitEmptyQueryContext(p *QueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_query
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) RegularQuery() IRegularQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRegularQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRegularQueryContext)
}

func (s *QueryContext) StandaloneCall() IStandaloneCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandaloneCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandaloneCallContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (s *QueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, CypherParserRULE_query)
	p.SetState(186)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(184)
			p.RegularQuery()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(185)
			p.StandaloneCall()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRegularQueryContext is an interface to support dynamic dispatch.
type IRegularQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleQuery() ISingleQueryContext
	AllUnionSt() []IUnionStContext
	UnionSt(i int) IUnionStContext

	// IsRegularQueryContext differentiates from other interfaces.
	IsRegularQueryContext()
}

type RegularQueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRegularQueryContext() *RegularQueryContext {
	var p = new(RegularQueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_regularQuery
	return p
}

func InitEmptyRegularQueryContext(p *RegularQueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_regularQuery
}

func (*RegularQueryContext) IsRegularQueryContext() {}

func NewRegularQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RegularQueryContext {
	var p = new(RegularQueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_regularQuery

	return p
}

func (s *RegularQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *RegularQueryContext) SingleQuery() ISingleQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleQueryContext)
}

func (s *RegularQueryContext) AllUnionSt() []IUnionStContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnionStContext); ok {
			len++
		}
	}

	tst := make([]IUnionStContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnionStContext); ok {
			tst[i] = t.(IUnionStContext)
			i++
		}
	}

	return tst
}

func (s *RegularQueryContext) UnionSt(i int) IUnionStContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionStContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionStContext)
}

func (s *RegularQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegularQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RegularQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterRegularQuery(s)
	}
}

func (s *RegularQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitRegularQuery(s)
	}
}

func (s *RegularQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitRegularQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) RegularQuery() (localctx IRegularQueryContext) {
	localctx = NewRegularQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, CypherParserRULE_regularQuery)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(188)
		p.SingleQuery()
	}
	p.SetState(192)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserUNION {
		{
			p.SetState(189)
			p.UnionSt()
		}

		p.SetState(194)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleQueryContext is an interface to support dynamic dispatch.
type ISingleQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SinglePartQ() ISinglePartQContext
	MultiPartQ() IMultiPartQContext

	// IsSingleQueryContext differentiates from other interfaces.
	IsSingleQueryContext()
}

type SingleQueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleQueryContext() *SingleQueryContext {
	var p = new(SingleQueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_singleQuery
	return p
}

func InitEmptySingleQueryContext(p *SingleQueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_singleQuery
}

func (*SingleQueryContext) IsSingleQueryContext() {}

func NewSingleQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleQueryContext {
	var p = new(SingleQueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_singleQuery

	return p
}

func (s *SingleQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleQueryContext) SinglePartQ() ISinglePartQContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISinglePartQContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISinglePartQContext)
}

func (s *SingleQueryContext) MultiPartQ() IMultiPartQContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiPartQContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiPartQContext)
}

func (s *SingleQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterSingleQuery(s)
	}
}

func (s *SingleQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitSingleQuery(s)
	}
}

func (s *SingleQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitSingleQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) SingleQuery() (localctx ISingleQueryContext) {
	localctx = NewSingleQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, CypherParserRULE_singleQuery)
	p.SetState(197)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(195)
			p.SinglePartQ()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(196)
			p.MultiPartQ()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStandaloneCallContext is an interface to support dynamic dispatch.
type IStandaloneCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CALL() antlr.TerminalNode
	InvocationName() IInvocationNameContext
	ParenExpressionChain() IParenExpressionChainContext
	YIELD() antlr.TerminalNode
	MULT() antlr.TerminalNode
	YieldItems() IYieldItemsContext

	// IsStandaloneCallContext differentiates from other interfaces.
	IsStandaloneCallContext()
}

type StandaloneCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandaloneCallContext() *StandaloneCallContext {
	var p = new(StandaloneCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_standaloneCall
	return p
}

func InitEmptyStandaloneCallContext(p *StandaloneCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_standaloneCall
}

func (*StandaloneCallContext) IsStandaloneCallContext() {}

func NewStandaloneCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandaloneCallContext {
	var p = new(StandaloneCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_standaloneCall

	return p
}

func (s *StandaloneCallContext) GetParser() antlr.Parser { return s.parser }

func (s *StandaloneCallContext) CALL() antlr.TerminalNode {
	return s.GetToken(CypherParserCALL, 0)
}

func (s *StandaloneCallContext) InvocationName() IInvocationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInvocationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInvocationNameContext)
}

func (s *StandaloneCallContext) ParenExpressionChain() IParenExpressionChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenExpressionChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenExpressionChainContext)
}

func (s *StandaloneCallContext) YIELD() antlr.TerminalNode {
	return s.GetToken(CypherParserYIELD, 0)
}

func (s *StandaloneCallContext) MULT() antlr.TerminalNode {
	return s.GetToken(CypherParserMULT, 0)
}

func (s *StandaloneCallContext) YieldItems() IYieldItemsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldItemsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldItemsContext)
}

func (s *StandaloneCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandaloneCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandaloneCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterStandaloneCall(s)
	}
}

func (s *StandaloneCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitStandaloneCall(s)
	}
}

func (s *StandaloneCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitStandaloneCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) StandaloneCall() (localctx IStandaloneCallContext) {
	localctx = NewStandaloneCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, CypherParserRULE_standaloneCall)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(199)
		p.Match(CypherParserCALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(200)
		p.InvocationName()
	}
	p.SetState(202)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserLPAREN {
		{
			p.SetState(201)
			p.ParenExpressionChain()
		}

	}
	p.SetState(209)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserYIELD {
		{
			p.SetState(204)
			p.Match(CypherParserYIELD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(207)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case CypherParserMULT:
			{
				p.SetState(205)
				p.Match(CypherParserMULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case CypherParserFILTER, CypherParserEXTRACT, CypherParserCOUNT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserID, CypherParserESC_LITERAL:
			{
				p.SetState(206)
				p.YieldItems()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStContext is an interface to support dynamic dispatch.
type IReturnStContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	ProjectionBody() IProjectionBodyContext

	// IsReturnStContext differentiates from other interfaces.
	IsReturnStContext()
}

type ReturnStContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStContext() *ReturnStContext {
	var p = new(ReturnStContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_returnSt
	return p
}

func InitEmptyReturnStContext(p *ReturnStContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_returnSt
}

func (*ReturnStContext) IsReturnStContext() {}

func NewReturnStContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStContext {
	var p = new(ReturnStContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_returnSt

	return p
}

func (s *ReturnStContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStContext) RETURN() antlr.TerminalNode {
	return s.GetToken(CypherParserRETURN, 0)
}

func (s *ReturnStContext) ProjectionBody() IProjectionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProjectionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProjectionBodyContext)
}

func (s *ReturnStContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterReturnSt(s)
	}
}

func (s *ReturnStContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitReturnSt(s)
	}
}

func (s *ReturnStContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitReturnSt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ReturnSt() (localctx IReturnStContext) {
	localctx = NewReturnStContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, CypherParserRULE_returnSt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(211)
		p.Match(CypherParserRETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(212)
		p.ProjectionBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithStContext is an interface to support dynamic dispatch.
type IWithStContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	ProjectionBody() IProjectionBodyContext
	Where() IWhereContext

	// IsWithStContext differentiates from other interfaces.
	IsWithStContext()
}

type WithStContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithStContext() *WithStContext {
	var p = new(WithStContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_withSt
	return p
}

func InitEmptyWithStContext(p *WithStContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_withSt
}

func (*WithStContext) IsWithStContext() {}

func NewWithStContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithStContext {
	var p = new(WithStContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_withSt

	return p
}

func (s *WithStContext) GetParser() antlr.Parser { return s.parser }

func (s *WithStContext) WITH() antlr.TerminalNode {
	return s.GetToken(CypherParserWITH, 0)
}

func (s *WithStContext) ProjectionBody() IProjectionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProjectionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProjectionBodyContext)
}

func (s *WithStContext) Where() IWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereContext)
}

func (s *WithStContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithStContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithStContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterWithSt(s)
	}
}

func (s *WithStContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitWithSt(s)
	}
}

func (s *WithStContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitWithSt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) WithSt() (localctx IWithStContext) {
	localctx = NewWithStContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, CypherParserRULE_withSt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(214)
		p.Match(CypherParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(215)
		p.ProjectionBody()
	}
	p.SetState(217)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserWHERE {
		{
			p.SetState(216)
			p.Where()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISkipStContext is an interface to support dynamic dispatch.
type ISkipStContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SKIP_W() antlr.TerminalNode
	Expression() IExpressionContext

	// IsSkipStContext differentiates from other interfaces.
	IsSkipStContext()
}

type SkipStContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySkipStContext() *SkipStContext {
	var p = new(SkipStContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_skipSt
	return p
}

func InitEmptySkipStContext(p *SkipStContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_skipSt
}

func (*SkipStContext) IsSkipStContext() {}

func NewSkipStContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkipStContext {
	var p = new(SkipStContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_skipSt

	return p
}

func (s *SkipStContext) GetParser() antlr.Parser { return s.parser }

func (s *SkipStContext) SKIP_W() antlr.TerminalNode {
	return s.GetToken(CypherParserSKIP_W, 0)
}

func (s *SkipStContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SkipStContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkipStContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SkipStContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterSkipSt(s)
	}
}

func (s *SkipStContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitSkipSt(s)
	}
}

func (s *SkipStContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitSkipSt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) SkipSt() (localctx ISkipStContext) {
	localctx = NewSkipStContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, CypherParserRULE_skipSt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(219)
		p.Match(CypherParserSKIP_W)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(220)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitStContext is an interface to support dynamic dispatch.
type ILimitStContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIMIT() antlr.TerminalNode
	Expression() IExpressionContext

	// IsLimitStContext differentiates from other interfaces.
	IsLimitStContext()
}

type LimitStContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitStContext() *LimitStContext {
	var p = new(LimitStContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_limitSt
	return p
}

func InitEmptyLimitStContext(p *LimitStContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_limitSt
}

func (*LimitStContext) IsLimitStContext() {}

func NewLimitStContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitStContext {
	var p = new(LimitStContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_limitSt

	return p
}

func (s *LimitStContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitStContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(CypherParserLIMIT, 0)
}

func (s *LimitStContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LimitStContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitStContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitStContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterLimitSt(s)
	}
}

func (s *LimitStContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitLimitSt(s)
	}
}

func (s *LimitStContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitLimitSt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) LimitSt() (localctx ILimitStContext) {
	localctx = NewLimitStContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, CypherParserRULE_limitSt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(222)
		p.Match(CypherParserLIMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(223)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProjectionBodyContext is an interface to support dynamic dispatch.
type IProjectionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProjectionItems() IProjectionItemsContext
	DISTINCT() antlr.TerminalNode
	OrderSt() IOrderStContext
	SkipSt() ISkipStContext
	LimitSt() ILimitStContext

	// IsProjectionBodyContext differentiates from other interfaces.
	IsProjectionBodyContext()
}

type ProjectionBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProjectionBodyContext() *ProjectionBodyContext {
	var p = new(ProjectionBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_projectionBody
	return p
}

func InitEmptyProjectionBodyContext(p *ProjectionBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_projectionBody
}

func (*ProjectionBodyContext) IsProjectionBodyContext() {}

func NewProjectionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProjectionBodyContext {
	var p = new(ProjectionBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_projectionBody

	return p
}

func (s *ProjectionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ProjectionBodyContext) ProjectionItems() IProjectionItemsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProjectionItemsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProjectionItemsContext)
}

func (s *ProjectionBodyContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(CypherParserDISTINCT, 0)
}

func (s *ProjectionBodyContext) OrderSt() IOrderStContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderStContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderStContext)
}

func (s *ProjectionBodyContext) SkipSt() ISkipStContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkipStContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkipStContext)
}

func (s *ProjectionBodyContext) LimitSt() ILimitStContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitStContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitStContext)
}

func (s *ProjectionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProjectionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProjectionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterProjectionBody(s)
	}
}

func (s *ProjectionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitProjectionBody(s)
	}
}

func (s *ProjectionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitProjectionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ProjectionBody() (localctx IProjectionBodyContext) {
	localctx = NewProjectionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, CypherParserRULE_projectionBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(226)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserDISTINCT {
		{
			p.SetState(225)
			p.Match(CypherParserDISTINCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(228)
		p.ProjectionItems()
	}
	p.SetState(230)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserORDER {
		{
			p.SetState(229)
			p.OrderSt()
		}

	}
	p.SetState(233)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSKIP_W {
		{
			p.SetState(232)
			p.SkipSt()
		}

	}
	p.SetState(236)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserLIMIT {
		{
			p.SetState(235)
			p.LimitSt()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProjectionItemsContext is an interface to support dynamic dispatch.
type IProjectionItemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MULT() antlr.TerminalNode
	AllProjectionItem() []IProjectionItemContext
	ProjectionItem(i int) IProjectionItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsProjectionItemsContext differentiates from other interfaces.
	IsProjectionItemsContext()
}

type ProjectionItemsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProjectionItemsContext() *ProjectionItemsContext {
	var p = new(ProjectionItemsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_projectionItems
	return p
}

func InitEmptyProjectionItemsContext(p *ProjectionItemsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_projectionItems
}

func (*ProjectionItemsContext) IsProjectionItemsContext() {}

func NewProjectionItemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProjectionItemsContext {
	var p = new(ProjectionItemsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_projectionItems

	return p
}

func (s *ProjectionItemsContext) GetParser() antlr.Parser { return s.parser }

func (s *ProjectionItemsContext) MULT() antlr.TerminalNode {
	return s.GetToken(CypherParserMULT, 0)
}

func (s *ProjectionItemsContext) AllProjectionItem() []IProjectionItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProjectionItemContext); ok {
			len++
		}
	}

	tst := make([]IProjectionItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProjectionItemContext); ok {
			tst[i] = t.(IProjectionItemContext)
			i++
		}
	}

	return tst
}

func (s *ProjectionItemsContext) ProjectionItem(i int) IProjectionItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProjectionItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProjectionItemContext)
}

func (s *ProjectionItemsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(CypherParserCOMMA)
}

func (s *ProjectionItemsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserCOMMA, i)
}

func (s *ProjectionItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProjectionItemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProjectionItemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterProjectionItems(s)
	}
}

func (s *ProjectionItemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitProjectionItems(s)
	}
}

func (s *ProjectionItemsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitProjectionItems(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ProjectionItems() (localctx IProjectionItemsContext) {
	localctx = NewProjectionItemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, CypherParserRULE_projectionItems)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(240)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CypherParserMULT:
		{
			p.SetState(238)
			p.Match(CypherParserMULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CypherParserLPAREN, CypherParserLBRACE, CypherParserLBRACK, CypherParserSUB, CypherParserPLUS, CypherParserDOLLAR, CypherParserFILTER, CypherParserEXTRACT, CypherParserCOUNT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserALL, CypherParserEXISTS, CypherParserNOT, CypherParserFALSE, CypherParserTRUE, CypherParserNULL_W, CypherParserCASE, CypherParserID, CypherParserESC_LITERAL, CypherParserCHAR_LITERAL, CypherParserSTRING_LITERAL, CypherParserDIGIT:
		{
			p.SetState(239)
			p.ProjectionItem()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(246)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserCOMMA {
		{
			p.SetState(242)
			p.Match(CypherParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(243)
			p.ProjectionItem()
		}

		p.SetState(248)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProjectionItemContext is an interface to support dynamic dispatch.
type IProjectionItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	AS() antlr.TerminalNode
	Symbol() ISymbolContext

	// IsProjectionItemContext differentiates from other interfaces.
	IsProjectionItemContext()
}

type ProjectionItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProjectionItemContext() *ProjectionItemContext {
	var p = new(ProjectionItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_projectionItem
	return p
}

func InitEmptyProjectionItemContext(p *ProjectionItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_projectionItem
}

func (*ProjectionItemContext) IsProjectionItemContext() {}

func NewProjectionItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProjectionItemContext {
	var p = new(ProjectionItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_projectionItem

	return p
}

func (s *ProjectionItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ProjectionItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ProjectionItemContext) AS() antlr.TerminalNode {
	return s.GetToken(CypherParserAS, 0)
}

func (s *ProjectionItemContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *ProjectionItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProjectionItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProjectionItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterProjectionItem(s)
	}
}

func (s *ProjectionItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitProjectionItem(s)
	}
}

func (s *ProjectionItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitProjectionItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ProjectionItem() (localctx IProjectionItemContext) {
	localctx = NewProjectionItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, CypherParserRULE_projectionItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(249)
		p.Expression()
	}
	p.SetState(252)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserAS {
		{
			p.SetState(250)
			p.Match(CypherParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(251)
			p.Symbol()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderItemContext is an interface to support dynamic dispatch.
type IOrderItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	ASCENDING() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESCENDING() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsOrderItemContext differentiates from other interfaces.
	IsOrderItemContext()
}

type OrderItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderItemContext() *OrderItemContext {
	var p = new(OrderItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_orderItem
	return p
}

func InitEmptyOrderItemContext(p *OrderItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_orderItem
}

func (*OrderItemContext) IsOrderItemContext() {}

func NewOrderItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderItemContext {
	var p = new(OrderItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_orderItem

	return p
}

func (s *OrderItemContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OrderItemContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(CypherParserASCENDING, 0)
}

func (s *OrderItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(CypherParserASC, 0)
}

func (s *OrderItemContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(CypherParserDESCENDING, 0)
}

func (s *OrderItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(CypherParserDESC, 0)
}

func (s *OrderItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterOrderItem(s)
	}
}

func (s *OrderItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitOrderItem(s)
	}
}

func (s *OrderItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitOrderItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) OrderItem() (localctx IOrderItemContext) {
	localctx = NewOrderItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, CypherParserRULE_orderItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(254)
		p.Expression()
	}
	p.SetState(256)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&13606456393728) != 0 {
		{
			p.SetState(255)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&13606456393728) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderStContext is an interface to support dynamic dispatch.
type IOrderStContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllOrderItem() []IOrderItemContext
	OrderItem(i int) IOrderItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsOrderStContext differentiates from other interfaces.
	IsOrderStContext()
}

type OrderStContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderStContext() *OrderStContext {
	var p = new(OrderStContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_orderSt
	return p
}

func InitEmptyOrderStContext(p *OrderStContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_orderSt
}

func (*OrderStContext) IsOrderStContext() {}

func NewOrderStContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderStContext {
	var p = new(OrderStContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_orderSt

	return p
}

func (s *OrderStContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderStContext) ORDER() antlr.TerminalNode {
	return s.GetToken(CypherParserORDER, 0)
}

func (s *OrderStContext) BY() antlr.TerminalNode {
	return s.GetToken(CypherParserBY, 0)
}

func (s *OrderStContext) AllOrderItem() []IOrderItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrderItemContext); ok {
			len++
		}
	}

	tst := make([]IOrderItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrderItemContext); ok {
			tst[i] = t.(IOrderItemContext)
			i++
		}
	}

	return tst
}

func (s *OrderStContext) OrderItem(i int) IOrderItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderItemContext)
}

func (s *OrderStContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(CypherParserCOMMA)
}

func (s *OrderStContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserCOMMA, i)
}

func (s *OrderStContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderStContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderStContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterOrderSt(s)
	}
}

func (s *OrderStContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitOrderSt(s)
	}
}

func (s *OrderStContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitOrderSt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) OrderSt() (localctx IOrderStContext) {
	localctx = NewOrderStContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, CypherParserRULE_orderSt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(258)
		p.Match(CypherParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(259)
		p.Match(CypherParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(260)
		p.OrderItem()
	}
	p.SetState(265)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserCOMMA {
		{
			p.SetState(261)
			p.Match(CypherParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(262)
			p.OrderItem()
		}

		p.SetState(267)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISinglePartQContext is an interface to support dynamic dispatch.
type ISinglePartQContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReturnSt() IReturnStContext
	AllReadingStatement() []IReadingStatementContext
	ReadingStatement(i int) IReadingStatementContext
	AllUpdatingStatement() []IUpdatingStatementContext
	UpdatingStatement(i int) IUpdatingStatementContext

	// IsSinglePartQContext differentiates from other interfaces.
	IsSinglePartQContext()
}

type SinglePartQContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySinglePartQContext() *SinglePartQContext {
	var p = new(SinglePartQContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_singlePartQ
	return p
}

func InitEmptySinglePartQContext(p *SinglePartQContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_singlePartQ
}

func (*SinglePartQContext) IsSinglePartQContext() {}

func NewSinglePartQContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SinglePartQContext {
	var p = new(SinglePartQContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_singlePartQ

	return p
}

func (s *SinglePartQContext) GetParser() antlr.Parser { return s.parser }

func (s *SinglePartQContext) ReturnSt() IReturnStContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStContext)
}

func (s *SinglePartQContext) AllReadingStatement() []IReadingStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReadingStatementContext); ok {
			len++
		}
	}

	tst := make([]IReadingStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReadingStatementContext); ok {
			tst[i] = t.(IReadingStatementContext)
			i++
		}
	}

	return tst
}

func (s *SinglePartQContext) ReadingStatement(i int) IReadingStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReadingStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReadingStatementContext)
}

func (s *SinglePartQContext) AllUpdatingStatement() []IUpdatingStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatingStatementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatingStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatingStatementContext); ok {
			tst[i] = t.(IUpdatingStatementContext)
			i++
		}
	}

	return tst
}

func (s *SinglePartQContext) UpdatingStatement(i int) IUpdatingStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatingStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatingStatementContext)
}

func (s *SinglePartQContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SinglePartQContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SinglePartQContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterSinglePartQ(s)
	}
}

func (s *SinglePartQContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitSinglePartQ(s)
	}
}

func (s *SinglePartQContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitSinglePartQ(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) SinglePartQ() (localctx ISinglePartQContext) {
	localctx = NewSinglePartQContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, CypherParserRULE_singlePartQ)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(271)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&577727389967056896) != 0 {
		{
			p.SetState(268)
			p.ReadingStatement()
		}

		p.SetState(273)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(283)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CypherParserRETURN:
		{
			p.SetState(274)
			p.ReturnSt()
		}

	case CypherParserCREATE, CypherParserDELETE, CypherParserDETACH, CypherParserMERGE, CypherParserREMOVE, CypherParserSET:
		p.SetState(276)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&22820363834490880) != 0) {
			{
				p.SetState(275)
				p.UpdatingStatement()
			}

			p.SetState(278)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(281)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserRETURN {
			{
				p.SetState(280)
				p.ReturnSt()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiPartQContext is an interface to support dynamic dispatch.
type IMultiPartQContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SinglePartQ() ISinglePartQContext
	AllReadingStatement() []IReadingStatementContext
	ReadingStatement(i int) IReadingStatementContext
	AllWithSt() []IWithStContext
	WithSt(i int) IWithStContext
	AllUpdatingStatement() []IUpdatingStatementContext
	UpdatingStatement(i int) IUpdatingStatementContext

	// IsMultiPartQContext differentiates from other interfaces.
	IsMultiPartQContext()
}

type MultiPartQContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiPartQContext() *MultiPartQContext {
	var p = new(MultiPartQContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_multiPartQ
	return p
}

func InitEmptyMultiPartQContext(p *MultiPartQContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_multiPartQ
}

func (*MultiPartQContext) IsMultiPartQContext() {}

func NewMultiPartQContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiPartQContext {
	var p = new(MultiPartQContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_multiPartQ

	return p
}

func (s *MultiPartQContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiPartQContext) SinglePartQ() ISinglePartQContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISinglePartQContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISinglePartQContext)
}

func (s *MultiPartQContext) AllReadingStatement() []IReadingStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReadingStatementContext); ok {
			len++
		}
	}

	tst := make([]IReadingStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReadingStatementContext); ok {
			tst[i] = t.(IReadingStatementContext)
			i++
		}
	}

	return tst
}

func (s *MultiPartQContext) ReadingStatement(i int) IReadingStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReadingStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReadingStatementContext)
}

func (s *MultiPartQContext) AllWithSt() []IWithStContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWithStContext); ok {
			len++
		}
	}

	tst := make([]IWithStContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWithStContext); ok {
			tst[i] = t.(IWithStContext)
			i++
		}
	}

	return tst
}

func (s *MultiPartQContext) WithSt(i int) IWithStContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithStContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithStContext)
}

func (s *MultiPartQContext) AllUpdatingStatement() []IUpdatingStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatingStatementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatingStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatingStatementContext); ok {
			tst[i] = t.(IUpdatingStatementContext)
			i++
		}
	}

	return tst
}

func (s *MultiPartQContext) UpdatingStatement(i int) IUpdatingStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatingStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatingStatementContext)
}

func (s *MultiPartQContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiPartQContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiPartQContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterMultiPartQ(s)
	}
}

func (s *MultiPartQContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitMultiPartQ(s)
	}
}

func (s *MultiPartQContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitMultiPartQ(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) MultiPartQ() (localctx IMultiPartQContext) {
	localctx = NewMultiPartQContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, CypherParserRULE_multiPartQ)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(288)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&577727389967056896) != 0 {
		{
			p.SetState(285)
			p.ReadingStatement()
		}

		p.SetState(290)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(298)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(294)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&22820363834490880) != 0 {
				{
					p.SetState(291)
					p.UpdatingStatement()
				}

				p.SetState(296)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(297)
				p.WithSt()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(300)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(302)
		p.SinglePartQ()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchStContext is an interface to support dynamic dispatch.
type IMatchStContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MATCH() antlr.TerminalNode
	PatternWhere() IPatternWhereContext
	OPTIONAL() antlr.TerminalNode

	// IsMatchStContext differentiates from other interfaces.
	IsMatchStContext()
}

type MatchStContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchStContext() *MatchStContext {
	var p = new(MatchStContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_matchSt
	return p
}

func InitEmptyMatchStContext(p *MatchStContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_matchSt
}

func (*MatchStContext) IsMatchStContext() {}

func NewMatchStContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchStContext {
	var p = new(MatchStContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_matchSt

	return p
}

func (s *MatchStContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchStContext) MATCH() antlr.TerminalNode {
	return s.GetToken(CypherParserMATCH, 0)
}

func (s *MatchStContext) PatternWhere() IPatternWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternWhereContext)
}

func (s *MatchStContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(CypherParserOPTIONAL, 0)
}

func (s *MatchStContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchStContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchStContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterMatchSt(s)
	}
}

func (s *MatchStContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitMatchSt(s)
	}
}

func (s *MatchStContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitMatchSt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) MatchSt() (localctx IMatchStContext) {
	localctx = NewMatchStContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, CypherParserRULE_matchSt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(305)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserOPTIONAL {
		{
			p.SetState(304)
			p.Match(CypherParserOPTIONAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(307)
		p.Match(CypherParserMATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(308)
		p.PatternWhere()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnwindStContext is an interface to support dynamic dispatch.
type IUnwindStContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNWIND() antlr.TerminalNode
	Expression() IExpressionContext
	AS() antlr.TerminalNode
	Symbol() ISymbolContext

	// IsUnwindStContext differentiates from other interfaces.
	IsUnwindStContext()
}

type UnwindStContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnwindStContext() *UnwindStContext {
	var p = new(UnwindStContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_unwindSt
	return p
}

func InitEmptyUnwindStContext(p *UnwindStContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_unwindSt
}

func (*UnwindStContext) IsUnwindStContext() {}

func NewUnwindStContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnwindStContext {
	var p = new(UnwindStContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_unwindSt

	return p
}

func (s *UnwindStContext) GetParser() antlr.Parser { return s.parser }

func (s *UnwindStContext) UNWIND() antlr.TerminalNode {
	return s.GetToken(CypherParserUNWIND, 0)
}

func (s *UnwindStContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnwindStContext) AS() antlr.TerminalNode {
	return s.GetToken(CypherParserAS, 0)
}

func (s *UnwindStContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *UnwindStContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnwindStContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnwindStContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterUnwindSt(s)
	}
}

func (s *UnwindStContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitUnwindSt(s)
	}
}

func (s *UnwindStContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitUnwindSt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) UnwindSt() (localctx IUnwindStContext) {
	localctx = NewUnwindStContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, CypherParserRULE_unwindSt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(310)
		p.Match(CypherParserUNWIND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(311)
		p.Expression()
	}
	{
		p.SetState(312)
		p.Match(CypherParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(313)
		p.Symbol()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReadingStatementContext is an interface to support dynamic dispatch.
type IReadingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MatchSt() IMatchStContext
	UnwindSt() IUnwindStContext
	QueryCallSt() IQueryCallStContext

	// IsReadingStatementContext differentiates from other interfaces.
	IsReadingStatementContext()
}

type ReadingStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadingStatementContext() *ReadingStatementContext {
	var p = new(ReadingStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_readingStatement
	return p
}

func InitEmptyReadingStatementContext(p *ReadingStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_readingStatement
}

func (*ReadingStatementContext) IsReadingStatementContext() {}

func NewReadingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadingStatementContext {
	var p = new(ReadingStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_readingStatement

	return p
}

func (s *ReadingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadingStatementContext) MatchSt() IMatchStContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchStContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchStContext)
}

func (s *ReadingStatementContext) UnwindSt() IUnwindStContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnwindStContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnwindStContext)
}

func (s *ReadingStatementContext) QueryCallSt() IQueryCallStContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryCallStContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryCallStContext)
}

func (s *ReadingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterReadingStatement(s)
	}
}

func (s *ReadingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitReadingStatement(s)
	}
}

func (s *ReadingStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitReadingStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ReadingStatement() (localctx IReadingStatementContext) {
	localctx = NewReadingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, CypherParserRULE_readingStatement)
	p.SetState(318)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CypherParserMATCH, CypherParserOPTIONAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(315)
			p.MatchSt()
		}

	case CypherParserUNWIND:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(316)
			p.UnwindSt()
		}

	case CypherParserCALL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(317)
			p.QueryCallSt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdatingStatementContext is an interface to support dynamic dispatch.
type IUpdatingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CreateSt() ICreateStContext
	MergeSt() IMergeStContext
	DeleteSt() IDeleteStContext
	SetSt() ISetStContext
	RemoveSt() IRemoveStContext

	// IsUpdatingStatementContext differentiates from other interfaces.
	IsUpdatingStatementContext()
}

type UpdatingStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdatingStatementContext() *UpdatingStatementContext {
	var p = new(UpdatingStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_updatingStatement
	return p
}

func InitEmptyUpdatingStatementContext(p *UpdatingStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_updatingStatement
}

func (*UpdatingStatementContext) IsUpdatingStatementContext() {}

func NewUpdatingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdatingStatementContext {
	var p = new(UpdatingStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_updatingStatement

	return p
}

func (s *UpdatingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdatingStatementContext) CreateSt() ICreateStContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateStContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateStContext)
}

func (s *UpdatingStatementContext) MergeSt() IMergeStContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeStContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeStContext)
}

func (s *UpdatingStatementContext) DeleteSt() IDeleteStContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteStContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteStContext)
}

func (s *UpdatingStatementContext) SetSt() ISetStContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetStContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetStContext)
}

func (s *UpdatingStatementContext) RemoveSt() IRemoveStContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRemoveStContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRemoveStContext)
}

func (s *UpdatingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdatingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdatingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterUpdatingStatement(s)
	}
}

func (s *UpdatingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitUpdatingStatement(s)
	}
}

func (s *UpdatingStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitUpdatingStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) UpdatingStatement() (localctx IUpdatingStatementContext) {
	localctx = NewUpdatingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, CypherParserRULE_updatingStatement)
	p.SetState(325)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CypherParserCREATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(320)
			p.CreateSt()
		}

	case CypherParserMERGE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(321)
			p.MergeSt()
		}

	case CypherParserDELETE, CypherParserDETACH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(322)
			p.DeleteSt()
		}

	case CypherParserSET:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(323)
			p.SetSt()
		}

	case CypherParserREMOVE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(324)
			p.RemoveSt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteStContext is an interface to support dynamic dispatch.
type IDeleteStContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	ExpressionChain() IExpressionChainContext
	DETACH() antlr.TerminalNode

	// IsDeleteStContext differentiates from other interfaces.
	IsDeleteStContext()
}

type DeleteStContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteStContext() *DeleteStContext {
	var p = new(DeleteStContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_deleteSt
	return p
}

func InitEmptyDeleteStContext(p *DeleteStContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_deleteSt
}

func (*DeleteStContext) IsDeleteStContext() {}

func NewDeleteStContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteStContext {
	var p = new(DeleteStContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_deleteSt

	return p
}

func (s *DeleteStContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteStContext) DELETE() antlr.TerminalNode {
	return s.GetToken(CypherParserDELETE, 0)
}

func (s *DeleteStContext) ExpressionChain() IExpressionChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionChainContext)
}

func (s *DeleteStContext) DETACH() antlr.TerminalNode {
	return s.GetToken(CypherParserDETACH, 0)
}

func (s *DeleteStContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteStContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteStContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterDeleteSt(s)
	}
}

func (s *DeleteStContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitDeleteSt(s)
	}
}

func (s *DeleteStContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitDeleteSt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) DeleteSt() (localctx IDeleteStContext) {
	localctx = NewDeleteStContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, CypherParserRULE_deleteSt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(328)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserDETACH {
		{
			p.SetState(327)
			p.Match(CypherParserDETACH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(330)
		p.Match(CypherParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(331)
		p.ExpressionChain()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRemoveStContext is an interface to support dynamic dispatch.
type IRemoveStContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REMOVE() antlr.TerminalNode
	AllRemoveItem() []IRemoveItemContext
	RemoveItem(i int) IRemoveItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRemoveStContext differentiates from other interfaces.
	IsRemoveStContext()
}

type RemoveStContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRemoveStContext() *RemoveStContext {
	var p = new(RemoveStContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_removeSt
	return p
}

func InitEmptyRemoveStContext(p *RemoveStContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_removeSt
}

func (*RemoveStContext) IsRemoveStContext() {}

func NewRemoveStContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RemoveStContext {
	var p = new(RemoveStContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_removeSt

	return p
}

func (s *RemoveStContext) GetParser() antlr.Parser { return s.parser }

func (s *RemoveStContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(CypherParserREMOVE, 0)
}

func (s *RemoveStContext) AllRemoveItem() []IRemoveItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRemoveItemContext); ok {
			len++
		}
	}

	tst := make([]IRemoveItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRemoveItemContext); ok {
			tst[i] = t.(IRemoveItemContext)
			i++
		}
	}

	return tst
}

func (s *RemoveStContext) RemoveItem(i int) IRemoveItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRemoveItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRemoveItemContext)
}

func (s *RemoveStContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(CypherParserCOMMA)
}

func (s *RemoveStContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserCOMMA, i)
}

func (s *RemoveStContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RemoveStContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RemoveStContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterRemoveSt(s)
	}
}

func (s *RemoveStContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitRemoveSt(s)
	}
}

func (s *RemoveStContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitRemoveSt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) RemoveSt() (localctx IRemoveStContext) {
	localctx = NewRemoveStContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, CypherParserRULE_removeSt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(333)
		p.Match(CypherParserREMOVE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(334)
		p.RemoveItem()
	}
	p.SetState(339)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserCOMMA {
		{
			p.SetState(335)
			p.Match(CypherParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(336)
			p.RemoveItem()
		}

		p.SetState(341)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRemoveItemContext is an interface to support dynamic dispatch.
type IRemoveItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Symbol() ISymbolContext
	NodeLabels() INodeLabelsContext
	PropertyExpression() IPropertyExpressionContext

	// IsRemoveItemContext differentiates from other interfaces.
	IsRemoveItemContext()
}

type RemoveItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRemoveItemContext() *RemoveItemContext {
	var p = new(RemoveItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_removeItem
	return p
}

func InitEmptyRemoveItemContext(p *RemoveItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_removeItem
}

func (*RemoveItemContext) IsRemoveItemContext() {}

func NewRemoveItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RemoveItemContext {
	var p = new(RemoveItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_removeItem

	return p
}

func (s *RemoveItemContext) GetParser() antlr.Parser { return s.parser }

func (s *RemoveItemContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *RemoveItemContext) NodeLabels() INodeLabelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeLabelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeLabelsContext)
}

func (s *RemoveItemContext) PropertyExpression() IPropertyExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyExpressionContext)
}

func (s *RemoveItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RemoveItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RemoveItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterRemoveItem(s)
	}
}

func (s *RemoveItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitRemoveItem(s)
	}
}

func (s *RemoveItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitRemoveItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) RemoveItem() (localctx IRemoveItemContext) {
	localctx = NewRemoveItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, CypherParserRULE_removeItem)
	p.SetState(346)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(342)
			p.Symbol()
		}
		{
			p.SetState(343)
			p.NodeLabels()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(345)
			p.PropertyExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryCallStContext is an interface to support dynamic dispatch.
type IQueryCallStContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CALL() antlr.TerminalNode
	InvocationName() IInvocationNameContext
	ParenExpressionChain() IParenExpressionChainContext
	YIELD() antlr.TerminalNode
	YieldItems() IYieldItemsContext

	// IsQueryCallStContext differentiates from other interfaces.
	IsQueryCallStContext()
}

type QueryCallStContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryCallStContext() *QueryCallStContext {
	var p = new(QueryCallStContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_queryCallSt
	return p
}

func InitEmptyQueryCallStContext(p *QueryCallStContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_queryCallSt
}

func (*QueryCallStContext) IsQueryCallStContext() {}

func NewQueryCallStContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryCallStContext {
	var p = new(QueryCallStContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_queryCallSt

	return p
}

func (s *QueryCallStContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryCallStContext) CALL() antlr.TerminalNode {
	return s.GetToken(CypherParserCALL, 0)
}

func (s *QueryCallStContext) InvocationName() IInvocationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInvocationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInvocationNameContext)
}

func (s *QueryCallStContext) ParenExpressionChain() IParenExpressionChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenExpressionChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenExpressionChainContext)
}

func (s *QueryCallStContext) YIELD() antlr.TerminalNode {
	return s.GetToken(CypherParserYIELD, 0)
}

func (s *QueryCallStContext) YieldItems() IYieldItemsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldItemsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldItemsContext)
}

func (s *QueryCallStContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryCallStContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryCallStContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterQueryCallSt(s)
	}
}

func (s *QueryCallStContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitQueryCallSt(s)
	}
}

func (s *QueryCallStContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitQueryCallSt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) QueryCallSt() (localctx IQueryCallStContext) {
	localctx = NewQueryCallStContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, CypherParserRULE_queryCallSt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(348)
		p.Match(CypherParserCALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(349)
		p.InvocationName()
	}
	{
		p.SetState(350)
		p.ParenExpressionChain()
	}
	p.SetState(353)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserYIELD {
		{
			p.SetState(351)
			p.Match(CypherParserYIELD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(352)
			p.YieldItems()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParenExpressionChainContext is an interface to support dynamic dispatch.
type IParenExpressionChainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ExpressionChain() IExpressionChainContext

	// IsParenExpressionChainContext differentiates from other interfaces.
	IsParenExpressionChainContext()
}

type ParenExpressionChainContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenExpressionChainContext() *ParenExpressionChainContext {
	var p = new(ParenExpressionChainContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_parenExpressionChain
	return p
}

func InitEmptyParenExpressionChainContext(p *ParenExpressionChainContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_parenExpressionChain
}

func (*ParenExpressionChainContext) IsParenExpressionChainContext() {}

func NewParenExpressionChainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenExpressionChainContext {
	var p = new(ParenExpressionChainContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_parenExpressionChain

	return p
}

func (s *ParenExpressionChainContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenExpressionChainContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(CypherParserLPAREN, 0)
}

func (s *ParenExpressionChainContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(CypherParserRPAREN, 0)
}

func (s *ParenExpressionChainContext) ExpressionChain() IExpressionChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionChainContext)
}

func (s *ParenExpressionChainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenExpressionChainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenExpressionChainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterParenExpressionChain(s)
	}
}

func (s *ParenExpressionChainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitParenExpressionChain(s)
	}
}

func (s *ParenExpressionChainContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitParenExpressionChain(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ParenExpressionChain() (localctx IParenExpressionChainContext) {
	localctx = NewParenExpressionChainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, CypherParserRULE_parenExpressionChain)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(355)
		p.Match(CypherParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(357)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&35320872390656) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&130027633) != 0) {
		{
			p.SetState(356)
			p.ExpressionChain()
		}

	}
	{
		p.SetState(359)
		p.Match(CypherParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYieldItemsContext is an interface to support dynamic dispatch.
type IYieldItemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllYieldItem() []IYieldItemContext
	YieldItem(i int) IYieldItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	Where() IWhereContext

	// IsYieldItemsContext differentiates from other interfaces.
	IsYieldItemsContext()
}

type YieldItemsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldItemsContext() *YieldItemsContext {
	var p = new(YieldItemsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_yieldItems
	return p
}

func InitEmptyYieldItemsContext(p *YieldItemsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_yieldItems
}

func (*YieldItemsContext) IsYieldItemsContext() {}

func NewYieldItemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldItemsContext {
	var p = new(YieldItemsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_yieldItems

	return p
}

func (s *YieldItemsContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldItemsContext) AllYieldItem() []IYieldItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IYieldItemContext); ok {
			len++
		}
	}

	tst := make([]IYieldItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IYieldItemContext); ok {
			tst[i] = t.(IYieldItemContext)
			i++
		}
	}

	return tst
}

func (s *YieldItemsContext) YieldItem(i int) IYieldItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldItemContext)
}

func (s *YieldItemsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(CypherParserCOMMA)
}

func (s *YieldItemsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserCOMMA, i)
}

func (s *YieldItemsContext) Where() IWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereContext)
}

func (s *YieldItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldItemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldItemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterYieldItems(s)
	}
}

func (s *YieldItemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitYieldItems(s)
	}
}

func (s *YieldItemsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitYieldItems(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) YieldItems() (localctx IYieldItemsContext) {
	localctx = NewYieldItemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, CypherParserRULE_yieldItems)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(361)
		p.YieldItem()
	}
	p.SetState(366)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserCOMMA {
		{
			p.SetState(362)
			p.Match(CypherParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(363)
			p.YieldItem()
		}

		p.SetState(368)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(370)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserWHERE {
		{
			p.SetState(369)
			p.Where()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYieldItemContext is an interface to support dynamic dispatch.
type IYieldItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSymbol() []ISymbolContext
	Symbol(i int) ISymbolContext
	AS() antlr.TerminalNode

	// IsYieldItemContext differentiates from other interfaces.
	IsYieldItemContext()
}

type YieldItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldItemContext() *YieldItemContext {
	var p = new(YieldItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_yieldItem
	return p
}

func InitEmptyYieldItemContext(p *YieldItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_yieldItem
}

func (*YieldItemContext) IsYieldItemContext() {}

func NewYieldItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldItemContext {
	var p = new(YieldItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_yieldItem

	return p
}

func (s *YieldItemContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldItemContext) AllSymbol() []ISymbolContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolContext); ok {
			len++
		}
	}

	tst := make([]ISymbolContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolContext); ok {
			tst[i] = t.(ISymbolContext)
			i++
		}
	}

	return tst
}

func (s *YieldItemContext) Symbol(i int) ISymbolContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *YieldItemContext) AS() antlr.TerminalNode {
	return s.GetToken(CypherParserAS, 0)
}

func (s *YieldItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterYieldItem(s)
	}
}

func (s *YieldItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitYieldItem(s)
	}
}

func (s *YieldItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitYieldItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) YieldItem() (localctx IYieldItemContext) {
	localctx = NewYieldItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, CypherParserRULE_yieldItem)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(375)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(372)
			p.Symbol()
		}
		{
			p.SetState(373)
			p.Match(CypherParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(377)
		p.Symbol()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMergeStContext is an interface to support dynamic dispatch.
type IMergeStContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MERGE() antlr.TerminalNode
	PatternPart() IPatternPartContext
	AllMergeAction() []IMergeActionContext
	MergeAction(i int) IMergeActionContext

	// IsMergeStContext differentiates from other interfaces.
	IsMergeStContext()
}

type MergeStContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeStContext() *MergeStContext {
	var p = new(MergeStContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_mergeSt
	return p
}

func InitEmptyMergeStContext(p *MergeStContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_mergeSt
}

func (*MergeStContext) IsMergeStContext() {}

func NewMergeStContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeStContext {
	var p = new(MergeStContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_mergeSt

	return p
}

func (s *MergeStContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeStContext) MERGE() antlr.TerminalNode {
	return s.GetToken(CypherParserMERGE, 0)
}

func (s *MergeStContext) PatternPart() IPatternPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternPartContext)
}

func (s *MergeStContext) AllMergeAction() []IMergeActionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMergeActionContext); ok {
			len++
		}
	}

	tst := make([]IMergeActionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMergeActionContext); ok {
			tst[i] = t.(IMergeActionContext)
			i++
		}
	}

	return tst
}

func (s *MergeStContext) MergeAction(i int) IMergeActionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeActionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeActionContext)
}

func (s *MergeStContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeStContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeStContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterMergeSt(s)
	}
}

func (s *MergeStContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitMergeSt(s)
	}
}

func (s *MergeStContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitMergeSt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) MergeSt() (localctx IMergeStContext) {
	localctx = NewMergeStContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, CypherParserRULE_mergeSt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(379)
		p.Match(CypherParserMERGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(380)
		p.PatternPart()
	}
	p.SetState(384)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserON {
		{
			p.SetState(381)
			p.MergeAction()
		}

		p.SetState(386)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMergeActionContext is an interface to support dynamic dispatch.
type IMergeActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	SetSt() ISetStContext
	MATCH() antlr.TerminalNode
	CREATE() antlr.TerminalNode

	// IsMergeActionContext differentiates from other interfaces.
	IsMergeActionContext()
}

type MergeActionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeActionContext() *MergeActionContext {
	var p = new(MergeActionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_mergeAction
	return p
}

func InitEmptyMergeActionContext(p *MergeActionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_mergeAction
}

func (*MergeActionContext) IsMergeActionContext() {}

func NewMergeActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeActionContext {
	var p = new(MergeActionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_mergeAction

	return p
}

func (s *MergeActionContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeActionContext) ON() antlr.TerminalNode {
	return s.GetToken(CypherParserON, 0)
}

func (s *MergeActionContext) SetSt() ISetStContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetStContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetStContext)
}

func (s *MergeActionContext) MATCH() antlr.TerminalNode {
	return s.GetToken(CypherParserMATCH, 0)
}

func (s *MergeActionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *MergeActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterMergeAction(s)
	}
}

func (s *MergeActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitMergeAction(s)
	}
}

func (s *MergeActionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitMergeAction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) MergeAction() (localctx IMergeActionContext) {
	localctx = NewMergeActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, CypherParserRULE_mergeAction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(387)
		p.Match(CypherParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(388)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CypherParserCREATE || _la == CypherParserMATCH) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(389)
		p.SetSt()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetStContext is an interface to support dynamic dispatch.
type ISetStContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	AllSetItem() []ISetItemContext
	SetItem(i int) ISetItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSetStContext differentiates from other interfaces.
	IsSetStContext()
}

type SetStContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStContext() *SetStContext {
	var p = new(SetStContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_setSt
	return p
}

func InitEmptySetStContext(p *SetStContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_setSt
}

func (*SetStContext) IsSetStContext() {}

func NewSetStContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStContext {
	var p = new(SetStContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_setSt

	return p
}

func (s *SetStContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStContext) SET() antlr.TerminalNode {
	return s.GetToken(CypherParserSET, 0)
}

func (s *SetStContext) AllSetItem() []ISetItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISetItemContext); ok {
			len++
		}
	}

	tst := make([]ISetItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISetItemContext); ok {
			tst[i] = t.(ISetItemContext)
			i++
		}
	}

	return tst
}

func (s *SetStContext) SetItem(i int) ISetItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetItemContext)
}

func (s *SetStContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(CypherParserCOMMA)
}

func (s *SetStContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserCOMMA, i)
}

func (s *SetStContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetStContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterSetSt(s)
	}
}

func (s *SetStContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitSetSt(s)
	}
}

func (s *SetStContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitSetSt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) SetSt() (localctx ISetStContext) {
	localctx = NewSetStContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, CypherParserRULE_setSt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(391)
		p.Match(CypherParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(392)
		p.SetItem()
	}
	p.SetState(397)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserCOMMA {
		{
			p.SetState(393)
			p.Match(CypherParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(394)
			p.SetItem()
		}

		p.SetState(399)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetItemContext is an interface to support dynamic dispatch.
type ISetItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PropertyExpression() IPropertyExpressionContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext
	Symbol() ISymbolContext
	ADD_ASSIGN() antlr.TerminalNode
	NodeLabels() INodeLabelsContext

	// IsSetItemContext differentiates from other interfaces.
	IsSetItemContext()
}

type SetItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetItemContext() *SetItemContext {
	var p = new(SetItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_setItem
	return p
}

func InitEmptySetItemContext(p *SetItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_setItem
}

func (*SetItemContext) IsSetItemContext() {}

func NewSetItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetItemContext {
	var p = new(SetItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_setItem

	return p
}

func (s *SetItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SetItemContext) PropertyExpression() IPropertyExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyExpressionContext)
}

func (s *SetItemContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(CypherParserASSIGN, 0)
}

func (s *SetItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetItemContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *SetItemContext) ADD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CypherParserADD_ASSIGN, 0)
}

func (s *SetItemContext) NodeLabels() INodeLabelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeLabelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeLabelsContext)
}

func (s *SetItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterSetItem(s)
	}
}

func (s *SetItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitSetItem(s)
	}
}

func (s *SetItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitSetItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) SetItem() (localctx ISetItemContext) {
	localctx = NewSetItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, CypherParserRULE_setItem)
	var _la int

	p.SetState(411)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(400)
			p.PropertyExpression()
		}
		{
			p.SetState(401)
			p.Match(CypherParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(402)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(404)
			p.Symbol()
		}
		{
			p.SetState(405)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CypherParserASSIGN || _la == CypherParserADD_ASSIGN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(406)
			p.Expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(408)
			p.Symbol()
		}
		{
			p.SetState(409)
			p.NodeLabels()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodeLabelsContext is an interface to support dynamic dispatch.
type INodeLabelsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllName() []INameContext
	Name(i int) INameContext

	// IsNodeLabelsContext differentiates from other interfaces.
	IsNodeLabelsContext()
}

type NodeLabelsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeLabelsContext() *NodeLabelsContext {
	var p = new(NodeLabelsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_nodeLabels
	return p
}

func InitEmptyNodeLabelsContext(p *NodeLabelsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_nodeLabels
}

func (*NodeLabelsContext) IsNodeLabelsContext() {}

func NewNodeLabelsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeLabelsContext {
	var p = new(NodeLabelsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_nodeLabels

	return p
}

func (s *NodeLabelsContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeLabelsContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(CypherParserCOLON)
}

func (s *NodeLabelsContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserCOLON, i)
}

func (s *NodeLabelsContext) AllName() []INameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INameContext); ok {
			len++
		}
	}

	tst := make([]INameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INameContext); ok {
			tst[i] = t.(INameContext)
			i++
		}
	}

	return tst
}

func (s *NodeLabelsContext) Name(i int) INameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *NodeLabelsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeLabelsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeLabelsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterNodeLabels(s)
	}
}

func (s *NodeLabelsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitNodeLabels(s)
	}
}

func (s *NodeLabelsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitNodeLabels(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) NodeLabels() (localctx INodeLabelsContext) {
	localctx = NewNodeLabelsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, CypherParserRULE_nodeLabels)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(415)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == CypherParserCOLON {
		{
			p.SetState(413)
			p.Match(CypherParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(414)
			p.Name()
		}

		p.SetState(417)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateStContext is an interface to support dynamic dispatch.
type ICreateStContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	Pattern() IPatternContext

	// IsCreateStContext differentiates from other interfaces.
	IsCreateStContext()
}

type CreateStContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateStContext() *CreateStContext {
	var p = new(CreateStContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_createSt
	return p
}

func InitEmptyCreateStContext(p *CreateStContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_createSt
}

func (*CreateStContext) IsCreateStContext() {}

func NewCreateStContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateStContext {
	var p = new(CreateStContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_createSt

	return p
}

func (s *CreateStContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateStContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *CreateStContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *CreateStContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateStContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterCreateSt(s)
	}
}

func (s *CreateStContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitCreateSt(s)
	}
}

func (s *CreateStContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitCreateSt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) CreateSt() (localctx ICreateStContext) {
	localctx = NewCreateStContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, CypherParserRULE_createSt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(419)
		p.Match(CypherParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(420)
		p.Pattern()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternWhereContext is an interface to support dynamic dispatch.
type IPatternWhereContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Pattern() IPatternContext
	Where() IWhereContext

	// IsPatternWhereContext differentiates from other interfaces.
	IsPatternWhereContext()
}

type PatternWhereContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternWhereContext() *PatternWhereContext {
	var p = new(PatternWhereContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_patternWhere
	return p
}

func InitEmptyPatternWhereContext(p *PatternWhereContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_patternWhere
}

func (*PatternWhereContext) IsPatternWhereContext() {}

func NewPatternWhereContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternWhereContext {
	var p = new(PatternWhereContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_patternWhere

	return p
}

func (s *PatternWhereContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternWhereContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *PatternWhereContext) Where() IWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereContext)
}

func (s *PatternWhereContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternWhereContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternWhereContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterPatternWhere(s)
	}
}

func (s *PatternWhereContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitPatternWhere(s)
	}
}

func (s *PatternWhereContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitPatternWhere(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) PatternWhere() (localctx IPatternWhereContext) {
	localctx = NewPatternWhereContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, CypherParserRULE_patternWhere)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(422)
		p.Pattern()
	}
	p.SetState(424)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserWHERE {
		{
			p.SetState(423)
			p.Where()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhereContext is an interface to support dynamic dispatch.
type IWhereContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsWhereContext differentiates from other interfaces.
	IsWhereContext()
}

type WhereContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereContext() *WhereContext {
	var p = new(WhereContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_where
	return p
}

func InitEmptyWhereContext(p *WhereContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_where
}

func (*WhereContext) IsWhereContext() {}

func NewWhereContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereContext {
	var p = new(WhereContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_where

	return p
}

func (s *WhereContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereContext) WHERE() antlr.TerminalNode {
	return s.GetToken(CypherParserWHERE, 0)
}

func (s *WhereContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhereContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterWhere(s)
	}
}

func (s *WhereContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitWhere(s)
	}
}

func (s *WhereContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitWhere(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Where() (localctx IWhereContext) {
	localctx = NewWhereContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, CypherParserRULE_where)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(426)
		p.Match(CypherParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(427)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternContext is an interface to support dynamic dispatch.
type IPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPatternPart() []IPatternPartContext
	PatternPart(i int) IPatternPartContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPatternContext differentiates from other interfaces.
	IsPatternContext()
}

type PatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternContext() *PatternContext {
	var p = new(PatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_pattern
	return p
}

func InitEmptyPatternContext(p *PatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_pattern
}

func (*PatternContext) IsPatternContext() {}

func NewPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternContext {
	var p = new(PatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_pattern

	return p
}

func (s *PatternContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternContext) AllPatternPart() []IPatternPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPatternPartContext); ok {
			len++
		}
	}

	tst := make([]IPatternPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPatternPartContext); ok {
			tst[i] = t.(IPatternPartContext)
			i++
		}
	}

	return tst
}

func (s *PatternContext) PatternPart(i int) IPatternPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternPartContext)
}

func (s *PatternContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(CypherParserCOMMA)
}

func (s *PatternContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserCOMMA, i)
}

func (s *PatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterPattern(s)
	}
}

func (s *PatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitPattern(s)
	}
}

func (s *PatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Pattern() (localctx IPatternContext) {
	localctx = NewPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, CypherParserRULE_pattern)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(429)
		p.PatternPart()
	}
	p.SetState(434)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserCOMMA {
		{
			p.SetState(430)
			p.Match(CypherParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(431)
			p.PatternPart()
		}

		p.SetState(436)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllXorExpression() []IXorExpressionContext
	XorExpression(i int) IXorExpressionContext
	AllOR() []antlr.TerminalNode
	OR(i int) antlr.TerminalNode

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) AllXorExpression() []IXorExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IXorExpressionContext); ok {
			len++
		}
	}

	tst := make([]IXorExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IXorExpressionContext); ok {
			tst[i] = t.(IXorExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) XorExpression(i int) IXorExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXorExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXorExpressionContext)
}

func (s *ExpressionContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(CypherParserOR)
}

func (s *ExpressionContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserOR, i)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, CypherParserRULE_expression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(437)
		p.XorExpression()
	}
	p.SetState(442)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserOR {
		{
			p.SetState(438)
			p.Match(CypherParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(439)
			p.XorExpression()
		}

		p.SetState(444)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXorExpressionContext is an interface to support dynamic dispatch.
type IXorExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAndExpression() []IAndExpressionContext
	AndExpression(i int) IAndExpressionContext
	AllXOR() []antlr.TerminalNode
	XOR(i int) antlr.TerminalNode

	// IsXorExpressionContext differentiates from other interfaces.
	IsXorExpressionContext()
}

type XorExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXorExpressionContext() *XorExpressionContext {
	var p = new(XorExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_xorExpression
	return p
}

func InitEmptyXorExpressionContext(p *XorExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_xorExpression
}

func (*XorExpressionContext) IsXorExpressionContext() {}

func NewXorExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XorExpressionContext {
	var p = new(XorExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_xorExpression

	return p
}

func (s *XorExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *XorExpressionContext) AllAndExpression() []IAndExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAndExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAndExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAndExpressionContext); ok {
			tst[i] = t.(IAndExpressionContext)
			i++
		}
	}

	return tst
}

func (s *XorExpressionContext) AndExpression(i int) IAndExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAndExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAndExpressionContext)
}

func (s *XorExpressionContext) AllXOR() []antlr.TerminalNode {
	return s.GetTokens(CypherParserXOR)
}

func (s *XorExpressionContext) XOR(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserXOR, i)
}

func (s *XorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XorExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterXorExpression(s)
	}
}

func (s *XorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitXorExpression(s)
	}
}

func (s *XorExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitXorExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) XorExpression() (localctx IXorExpressionContext) {
	localctx = NewXorExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, CypherParserRULE_xorExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(445)
		p.AndExpression()
	}
	p.SetState(450)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserXOR {
		{
			p.SetState(446)
			p.Match(CypherParserXOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(447)
			p.AndExpression()
		}

		p.SetState(452)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAndExpressionContext is an interface to support dynamic dispatch.
type IAndExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNotExpression() []INotExpressionContext
	NotExpression(i int) INotExpressionContext
	AllAND() []antlr.TerminalNode
	AND(i int) antlr.TerminalNode

	// IsAndExpressionContext differentiates from other interfaces.
	IsAndExpressionContext()
}

type AndExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAndExpressionContext() *AndExpressionContext {
	var p = new(AndExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_andExpression
	return p
}

func InitEmptyAndExpressionContext(p *AndExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_andExpression
}

func (*AndExpressionContext) IsAndExpressionContext() {}

func NewAndExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AndExpressionContext {
	var p = new(AndExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_andExpression

	return p
}

func (s *AndExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AndExpressionContext) AllNotExpression() []INotExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INotExpressionContext); ok {
			len++
		}
	}

	tst := make([]INotExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INotExpressionContext); ok {
			tst[i] = t.(INotExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AndExpressionContext) NotExpression(i int) INotExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotExpressionContext)
}

func (s *AndExpressionContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(CypherParserAND)
}

func (s *AndExpressionContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserAND, i)
}

func (s *AndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterAndExpression(s)
	}
}

func (s *AndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitAndExpression(s)
	}
}

func (s *AndExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitAndExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) AndExpression() (localctx IAndExpressionContext) {
	localctx = NewAndExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, CypherParserRULE_andExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(453)
		p.NotExpression()
	}
	p.SetState(458)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserAND {
		{
			p.SetState(454)
			p.Match(CypherParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(455)
			p.NotExpression()
		}

		p.SetState(460)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INotExpressionContext is an interface to support dynamic dispatch.
type INotExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ComparisonExpression() IComparisonExpressionContext
	NOT() antlr.TerminalNode

	// IsNotExpressionContext differentiates from other interfaces.
	IsNotExpressionContext()
}

type NotExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotExpressionContext() *NotExpressionContext {
	var p = new(NotExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_notExpression
	return p
}

func InitEmptyNotExpressionContext(p *NotExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_notExpression
}

func (*NotExpressionContext) IsNotExpressionContext() {}

func NewNotExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotExpressionContext {
	var p = new(NotExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_notExpression

	return p
}

func (s *NotExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *NotExpressionContext) ComparisonExpression() IComparisonExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonExpressionContext)
}

func (s *NotExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(CypherParserNOT, 0)
}

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterNotExpression(s)
	}
}

func (s *NotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitNotExpression(s)
	}
}

func (s *NotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitNotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) NotExpression() (localctx INotExpressionContext) {
	localctx = NewNotExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, CypherParserRULE_notExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(462)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserNOT {
		{
			p.SetState(461)
			p.Match(CypherParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(464)
		p.ComparisonExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonExpressionContext is an interface to support dynamic dispatch.
type IComparisonExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAddSubExpression() []IAddSubExpressionContext
	AddSubExpression(i int) IAddSubExpressionContext
	AllComparisonSigns() []IComparisonSignsContext
	ComparisonSigns(i int) IComparisonSignsContext

	// IsComparisonExpressionContext differentiates from other interfaces.
	IsComparisonExpressionContext()
}

type ComparisonExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonExpressionContext() *ComparisonExpressionContext {
	var p = new(ComparisonExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_comparisonExpression
	return p
}

func InitEmptyComparisonExpressionContext(p *ComparisonExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_comparisonExpression
}

func (*ComparisonExpressionContext) IsComparisonExpressionContext() {}

func NewComparisonExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonExpressionContext {
	var p = new(ComparisonExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_comparisonExpression

	return p
}

func (s *ComparisonExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonExpressionContext) AllAddSubExpression() []IAddSubExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAddSubExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAddSubExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAddSubExpressionContext); ok {
			tst[i] = t.(IAddSubExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonExpressionContext) AddSubExpression(i int) IAddSubExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddSubExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddSubExpressionContext)
}

func (s *ComparisonExpressionContext) AllComparisonSigns() []IComparisonSignsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComparisonSignsContext); ok {
			len++
		}
	}

	tst := make([]IComparisonSignsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComparisonSignsContext); ok {
			tst[i] = t.(IComparisonSignsContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonExpressionContext) ComparisonSigns(i int) IComparisonSignsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonSignsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonSignsContext)
}

func (s *ComparisonExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterComparisonExpression(s)
	}
}

func (s *ComparisonExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitComparisonExpression(s)
	}
}

func (s *ComparisonExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitComparisonExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ComparisonExpression() (localctx IComparisonExpressionContext) {
	localctx = NewComparisonExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, CypherParserRULE_comparisonExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(466)
		p.AddSubExpression()
	}
	p.SetState(472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&250) != 0 {
		{
			p.SetState(467)
			p.ComparisonSigns()
		}
		{
			p.SetState(468)
			p.AddSubExpression()
		}

		p.SetState(474)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonSignsContext is an interface to support dynamic dispatch.
type IComparisonSignsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASSIGN() antlr.TerminalNode
	LE() antlr.TerminalNode
	GE() antlr.TerminalNode
	GT() antlr.TerminalNode
	LT() antlr.TerminalNode
	NOT_EQUAL() antlr.TerminalNode

	// IsComparisonSignsContext differentiates from other interfaces.
	IsComparisonSignsContext()
}

type ComparisonSignsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonSignsContext() *ComparisonSignsContext {
	var p = new(ComparisonSignsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_comparisonSigns
	return p
}

func InitEmptyComparisonSignsContext(p *ComparisonSignsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_comparisonSigns
}

func (*ComparisonSignsContext) IsComparisonSignsContext() {}

func NewComparisonSignsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonSignsContext {
	var p = new(ComparisonSignsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_comparisonSigns

	return p
}

func (s *ComparisonSignsContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonSignsContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(CypherParserASSIGN, 0)
}

func (s *ComparisonSignsContext) LE() antlr.TerminalNode {
	return s.GetToken(CypherParserLE, 0)
}

func (s *ComparisonSignsContext) GE() antlr.TerminalNode {
	return s.GetToken(CypherParserGE, 0)
}

func (s *ComparisonSignsContext) GT() antlr.TerminalNode {
	return s.GetToken(CypherParserGT, 0)
}

func (s *ComparisonSignsContext) LT() antlr.TerminalNode {
	return s.GetToken(CypherParserLT, 0)
}

func (s *ComparisonSignsContext) NOT_EQUAL() antlr.TerminalNode {
	return s.GetToken(CypherParserNOT_EQUAL, 0)
}

func (s *ComparisonSignsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonSignsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonSignsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterComparisonSigns(s)
	}
}

func (s *ComparisonSignsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitComparisonSigns(s)
	}
}

func (s *ComparisonSignsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitComparisonSigns(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ComparisonSigns() (localctx IComparisonSignsContext) {
	localctx = NewComparisonSignsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, CypherParserRULE_comparisonSigns)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(475)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&250) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddSubExpressionContext is an interface to support dynamic dispatch.
type IAddSubExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMultDivExpression() []IMultDivExpressionContext
	MultDivExpression(i int) IMultDivExpressionContext
	AllPLUS() []antlr.TerminalNode
	PLUS(i int) antlr.TerminalNode
	AllSUB() []antlr.TerminalNode
	SUB(i int) antlr.TerminalNode

	// IsAddSubExpressionContext differentiates from other interfaces.
	IsAddSubExpressionContext()
}

type AddSubExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddSubExpressionContext() *AddSubExpressionContext {
	var p = new(AddSubExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_addSubExpression
	return p
}

func InitEmptyAddSubExpressionContext(p *AddSubExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_addSubExpression
}

func (*AddSubExpressionContext) IsAddSubExpressionContext() {}

func NewAddSubExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddSubExpressionContext {
	var p = new(AddSubExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_addSubExpression

	return p
}

func (s *AddSubExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AddSubExpressionContext) AllMultDivExpression() []IMultDivExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultDivExpressionContext); ok {
			len++
		}
	}

	tst := make([]IMultDivExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultDivExpressionContext); ok {
			tst[i] = t.(IMultDivExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AddSubExpressionContext) MultDivExpression(i int) IMultDivExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultDivExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultDivExpressionContext)
}

func (s *AddSubExpressionContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(CypherParserPLUS)
}

func (s *AddSubExpressionContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserPLUS, i)
}

func (s *AddSubExpressionContext) AllSUB() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSUB)
}

func (s *AddSubExpressionContext) SUB(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSUB, i)
}

func (s *AddSubExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddSubExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddSubExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterAddSubExpression(s)
	}
}

func (s *AddSubExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitAddSubExpression(s)
	}
}

func (s *AddSubExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitAddSubExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) AddSubExpression() (localctx IAddSubExpressionContext) {
	localctx = NewAddSubExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, CypherParserRULE_addSubExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(477)
		p.MultDivExpression()
	}
	p.SetState(482)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserSUB || _la == CypherParserPLUS {
		{
			p.SetState(478)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CypherParserSUB || _la == CypherParserPLUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(479)
			p.MultDivExpression()
		}

		p.SetState(484)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultDivExpressionContext is an interface to support dynamic dispatch.
type IMultDivExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPowerExpression() []IPowerExpressionContext
	PowerExpression(i int) IPowerExpressionContext
	AllMULT() []antlr.TerminalNode
	MULT(i int) antlr.TerminalNode
	AllDIV() []antlr.TerminalNode
	DIV(i int) antlr.TerminalNode
	AllMOD() []antlr.TerminalNode
	MOD(i int) antlr.TerminalNode

	// IsMultDivExpressionContext differentiates from other interfaces.
	IsMultDivExpressionContext()
}

type MultDivExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultDivExpressionContext() *MultDivExpressionContext {
	var p = new(MultDivExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_multDivExpression
	return p
}

func InitEmptyMultDivExpressionContext(p *MultDivExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_multDivExpression
}

func (*MultDivExpressionContext) IsMultDivExpressionContext() {}

func NewMultDivExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultDivExpressionContext {
	var p = new(MultDivExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_multDivExpression

	return p
}

func (s *MultDivExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultDivExpressionContext) AllPowerExpression() []IPowerExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPowerExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPowerExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPowerExpressionContext); ok {
			tst[i] = t.(IPowerExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultDivExpressionContext) PowerExpression(i int) IPowerExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPowerExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPowerExpressionContext)
}

func (s *MultDivExpressionContext) AllMULT() []antlr.TerminalNode {
	return s.GetTokens(CypherParserMULT)
}

func (s *MultDivExpressionContext) MULT(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserMULT, i)
}

func (s *MultDivExpressionContext) AllDIV() []antlr.TerminalNode {
	return s.GetTokens(CypherParserDIV)
}

func (s *MultDivExpressionContext) DIV(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserDIV, i)
}

func (s *MultDivExpressionContext) AllMOD() []antlr.TerminalNode {
	return s.GetTokens(CypherParserMOD)
}

func (s *MultDivExpressionContext) MOD(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserMOD, i)
}

func (s *MultDivExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultDivExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultDivExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterMultDivExpression(s)
	}
}

func (s *MultDivExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitMultDivExpression(s)
	}
}

func (s *MultDivExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitMultDivExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) MultDivExpression() (localctx IMultDivExpressionContext) {
	localctx = NewMultDivExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, CypherParserRULE_multDivExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(485)
		p.PowerExpression()
	}
	p.SetState(490)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&11534336) != 0 {
		{
			p.SetState(486)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&11534336) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(487)
			p.PowerExpression()
		}

		p.SetState(492)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPowerExpressionContext is an interface to support dynamic dispatch.
type IPowerExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUnaryAddSubExpression() []IUnaryAddSubExpressionContext
	UnaryAddSubExpression(i int) IUnaryAddSubExpressionContext
	AllCARET() []antlr.TerminalNode
	CARET(i int) antlr.TerminalNode

	// IsPowerExpressionContext differentiates from other interfaces.
	IsPowerExpressionContext()
}

type PowerExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerExpressionContext() *PowerExpressionContext {
	var p = new(PowerExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_powerExpression
	return p
}

func InitEmptyPowerExpressionContext(p *PowerExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_powerExpression
}

func (*PowerExpressionContext) IsPowerExpressionContext() {}

func NewPowerExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerExpressionContext {
	var p = new(PowerExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_powerExpression

	return p
}

func (s *PowerExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerExpressionContext) AllUnaryAddSubExpression() []IUnaryAddSubExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnaryAddSubExpressionContext); ok {
			len++
		}
	}

	tst := make([]IUnaryAddSubExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnaryAddSubExpressionContext); ok {
			tst[i] = t.(IUnaryAddSubExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PowerExpressionContext) UnaryAddSubExpression(i int) IUnaryAddSubExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryAddSubExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryAddSubExpressionContext)
}

func (s *PowerExpressionContext) AllCARET() []antlr.TerminalNode {
	return s.GetTokens(CypherParserCARET)
}

func (s *PowerExpressionContext) CARET(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserCARET, i)
}

func (s *PowerExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowerExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterPowerExpression(s)
	}
}

func (s *PowerExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitPowerExpression(s)
	}
}

func (s *PowerExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitPowerExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) PowerExpression() (localctx IPowerExpressionContext) {
	localctx = NewPowerExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, CypherParserRULE_powerExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(493)
		p.UnaryAddSubExpression()
	}
	p.SetState(498)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserCARET {
		{
			p.SetState(494)
			p.Match(CypherParserCARET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(495)
			p.UnaryAddSubExpression()
		}

		p.SetState(500)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaryAddSubExpressionContext is an interface to support dynamic dispatch.
type IUnaryAddSubExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AtomicExpression() IAtomicExpressionContext
	PLUS() antlr.TerminalNode
	SUB() antlr.TerminalNode

	// IsUnaryAddSubExpressionContext differentiates from other interfaces.
	IsUnaryAddSubExpressionContext()
}

type UnaryAddSubExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryAddSubExpressionContext() *UnaryAddSubExpressionContext {
	var p = new(UnaryAddSubExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_unaryAddSubExpression
	return p
}

func InitEmptyUnaryAddSubExpressionContext(p *UnaryAddSubExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_unaryAddSubExpression
}

func (*UnaryAddSubExpressionContext) IsUnaryAddSubExpressionContext() {}

func NewUnaryAddSubExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryAddSubExpressionContext {
	var p = new(UnaryAddSubExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_unaryAddSubExpression

	return p
}

func (s *UnaryAddSubExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryAddSubExpressionContext) AtomicExpression() IAtomicExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomicExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomicExpressionContext)
}

func (s *UnaryAddSubExpressionContext) PLUS() antlr.TerminalNode {
	return s.GetToken(CypherParserPLUS, 0)
}

func (s *UnaryAddSubExpressionContext) SUB() antlr.TerminalNode {
	return s.GetToken(CypherParserSUB, 0)
}

func (s *UnaryAddSubExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryAddSubExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryAddSubExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterUnaryAddSubExpression(s)
	}
}

func (s *UnaryAddSubExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitUnaryAddSubExpression(s)
	}
}

func (s *UnaryAddSubExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitUnaryAddSubExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) UnaryAddSubExpression() (localctx IUnaryAddSubExpressionContext) {
	localctx = NewUnaryAddSubExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, CypherParserRULE_unaryAddSubExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(502)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSUB || _la == CypherParserPLUS {
		{
			p.SetState(501)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CypherParserSUB || _la == CypherParserPLUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(504)
		p.AtomicExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAtomicExpressionContext is an interface to support dynamic dispatch.
type IAtomicExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PropertyOrLabelExpression() IPropertyOrLabelExpressionContext
	AllStringExpression() []IStringExpressionContext
	StringExpression(i int) IStringExpressionContext
	AllListExpression() []IListExpressionContext
	ListExpression(i int) IListExpressionContext
	AllNullExpression() []INullExpressionContext
	NullExpression(i int) INullExpressionContext

	// IsAtomicExpressionContext differentiates from other interfaces.
	IsAtomicExpressionContext()
}

type AtomicExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomicExpressionContext() *AtomicExpressionContext {
	var p = new(AtomicExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_atomicExpression
	return p
}

func InitEmptyAtomicExpressionContext(p *AtomicExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_atomicExpression
}

func (*AtomicExpressionContext) IsAtomicExpressionContext() {}

func NewAtomicExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomicExpressionContext {
	var p = new(AtomicExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_atomicExpression

	return p
}

func (s *AtomicExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomicExpressionContext) PropertyOrLabelExpression() IPropertyOrLabelExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyOrLabelExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyOrLabelExpressionContext)
}

func (s *AtomicExpressionContext) AllStringExpression() []IStringExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringExpressionContext); ok {
			len++
		}
	}

	tst := make([]IStringExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringExpressionContext); ok {
			tst[i] = t.(IStringExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AtomicExpressionContext) StringExpression(i int) IStringExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringExpressionContext)
}

func (s *AtomicExpressionContext) AllListExpression() []IListExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IListExpressionContext); ok {
			len++
		}
	}

	tst := make([]IListExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IListExpressionContext); ok {
			tst[i] = t.(IListExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AtomicExpressionContext) ListExpression(i int) IListExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListExpressionContext)
}

func (s *AtomicExpressionContext) AllNullExpression() []INullExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INullExpressionContext); ok {
			len++
		}
	}

	tst := make([]INullExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INullExpressionContext); ok {
			tst[i] = t.(INullExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AtomicExpressionContext) NullExpression(i int) INullExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullExpressionContext)
}

func (s *AtomicExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomicExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomicExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterAtomicExpression(s)
	}
}

func (s *AtomicExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitAtomicExpression(s)
	}
}

func (s *AtomicExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitAtomicExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) AtomicExpression() (localctx IAtomicExpressionContext) {
	localctx = NewAtomicExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, CypherParserRULE_atomicExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(506)
		p.PropertyOrLabelExpression()
	}
	p.SetState(512)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-16)) & ^0x3f) == 0 && ((int64(1)<<(_la-16))&11047892835893249) != 0 {
		p.SetState(510)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case CypherParserCONTAINS, CypherParserENDS, CypherParserSTARTS:
			{
				p.SetState(507)
				p.StringExpression()
			}

		case CypherParserLBRACK, CypherParserIN:
			{
				p.SetState(508)
				p.ListExpression()
			}

		case CypherParserIS:
			{
				p.SetState(509)
				p.NullExpression()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(514)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListExpressionContext is an interface to support dynamic dispatch.
type IListExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IN() antlr.TerminalNode
	PropertyOrLabelExpression() IPropertyOrLabelExpressionContext
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsListExpressionContext differentiates from other interfaces.
	IsListExpressionContext()
}

type ListExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListExpressionContext() *ListExpressionContext {
	var p = new(ListExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_listExpression
	return p
}

func InitEmptyListExpressionContext(p *ListExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_listExpression
}

func (*ListExpressionContext) IsListExpressionContext() {}

func NewListExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListExpressionContext {
	var p = new(ListExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_listExpression

	return p
}

func (s *ListExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ListExpressionContext) IN() antlr.TerminalNode {
	return s.GetToken(CypherParserIN, 0)
}

func (s *ListExpressionContext) PropertyOrLabelExpression() IPropertyOrLabelExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyOrLabelExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyOrLabelExpressionContext)
}

func (s *ListExpressionContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(CypherParserLBRACK, 0)
}

func (s *ListExpressionContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(CypherParserRBRACK, 0)
}

func (s *ListExpressionContext) RANGE() antlr.TerminalNode {
	return s.GetToken(CypherParserRANGE, 0)
}

func (s *ListExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ListExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ListExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterListExpression(s)
	}
}

func (s *ListExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitListExpression(s)
	}
}

func (s *ListExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitListExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ListExpression() (localctx IListExpressionContext) {
	localctx = NewListExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, CypherParserRULE_listExpression)
	var _la int

	p.SetState(529)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CypherParserIN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(515)
			p.Match(CypherParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(516)
			p.PropertyOrLabelExpression()
		}

	case CypherParserLBRACK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(517)
			p.Match(CypherParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(526)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext()) {
		case 1:
			p.SetState(519)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&35320872390656) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&130027633) != 0) {
				{
					p.SetState(518)
					p.Expression()
				}

			}
			{
				p.SetState(521)
				p.Match(CypherParserRANGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(523)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&35320872390656) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&130027633) != 0) {
				{
					p.SetState(522)
					p.Expression()
				}

			}

		case 2:
			{
				p.SetState(525)
				p.Expression()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(528)
			p.Match(CypherParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringExpressionContext is an interface to support dynamic dispatch.
type IStringExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringExpPrefix() IStringExpPrefixContext
	PropertyOrLabelExpression() IPropertyOrLabelExpressionContext

	// IsStringExpressionContext differentiates from other interfaces.
	IsStringExpressionContext()
}

type StringExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringExpressionContext() *StringExpressionContext {
	var p = new(StringExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_stringExpression
	return p
}

func InitEmptyStringExpressionContext(p *StringExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_stringExpression
}

func (*StringExpressionContext) IsStringExpressionContext() {}

func NewStringExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringExpressionContext {
	var p = new(StringExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_stringExpression

	return p
}

func (s *StringExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StringExpressionContext) StringExpPrefix() IStringExpPrefixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringExpPrefixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringExpPrefixContext)
}

func (s *StringExpressionContext) PropertyOrLabelExpression() IPropertyOrLabelExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyOrLabelExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyOrLabelExpressionContext)
}

func (s *StringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterStringExpression(s)
	}
}

func (s *StringExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitStringExpression(s)
	}
}

func (s *StringExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitStringExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) StringExpression() (localctx IStringExpressionContext) {
	localctx = NewStringExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, CypherParserRULE_stringExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(531)
		p.StringExpPrefix()
	}
	{
		p.SetState(532)
		p.PropertyOrLabelExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringExpPrefixContext is an interface to support dynamic dispatch.
type IStringExpPrefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STARTS() antlr.TerminalNode
	WITH() antlr.TerminalNode
	ENDS() antlr.TerminalNode
	CONTAINS() antlr.TerminalNode

	// IsStringExpPrefixContext differentiates from other interfaces.
	IsStringExpPrefixContext()
}

type StringExpPrefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringExpPrefixContext() *StringExpPrefixContext {
	var p = new(StringExpPrefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_stringExpPrefix
	return p
}

func InitEmptyStringExpPrefixContext(p *StringExpPrefixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_stringExpPrefix
}

func (*StringExpPrefixContext) IsStringExpPrefixContext() {}

func NewStringExpPrefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringExpPrefixContext {
	var p = new(StringExpPrefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_stringExpPrefix

	return p
}

func (s *StringExpPrefixContext) GetParser() antlr.Parser { return s.parser }

func (s *StringExpPrefixContext) STARTS() antlr.TerminalNode {
	return s.GetToken(CypherParserSTARTS, 0)
}

func (s *StringExpPrefixContext) WITH() antlr.TerminalNode {
	return s.GetToken(CypherParserWITH, 0)
}

func (s *StringExpPrefixContext) ENDS() antlr.TerminalNode {
	return s.GetToken(CypherParserENDS, 0)
}

func (s *StringExpPrefixContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(CypherParserCONTAINS, 0)
}

func (s *StringExpPrefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringExpPrefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringExpPrefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterStringExpPrefix(s)
	}
}

func (s *StringExpPrefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitStringExpPrefix(s)
	}
}

func (s *StringExpPrefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitStringExpPrefix(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) StringExpPrefix() (localctx IStringExpPrefixContext) {
	localctx = NewStringExpPrefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, CypherParserRULE_stringExpPrefix)
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CypherParserSTARTS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(534)
			p.Match(CypherParserSTARTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(535)
			p.Match(CypherParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CypherParserENDS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(536)
			p.Match(CypherParserENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(537)
			p.Match(CypherParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CypherParserCONTAINS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(538)
			p.Match(CypherParserCONTAINS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INullExpressionContext is an interface to support dynamic dispatch.
type INullExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IS() antlr.TerminalNode
	NULL_W() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsNullExpressionContext differentiates from other interfaces.
	IsNullExpressionContext()
}

type NullExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullExpressionContext() *NullExpressionContext {
	var p = new(NullExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_nullExpression
	return p
}

func InitEmptyNullExpressionContext(p *NullExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_nullExpression
}

func (*NullExpressionContext) IsNullExpressionContext() {}

func NewNullExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullExpressionContext {
	var p = new(NullExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_nullExpression

	return p
}

func (s *NullExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *NullExpressionContext) IS() antlr.TerminalNode {
	return s.GetToken(CypherParserIS, 0)
}

func (s *NullExpressionContext) NULL_W() antlr.TerminalNode {
	return s.GetToken(CypherParserNULL_W, 0)
}

func (s *NullExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(CypherParserNOT, 0)
}

func (s *NullExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterNullExpression(s)
	}
}

func (s *NullExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitNullExpression(s)
	}
}

func (s *NullExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitNullExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) NullExpression() (localctx INullExpressionContext) {
	localctx = NewNullExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, CypherParserRULE_nullExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(541)
		p.Match(CypherParserIS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(543)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserNOT {
		{
			p.SetState(542)
			p.Match(CypherParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(545)
		p.Match(CypherParserNULL_W)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyOrLabelExpressionContext is an interface to support dynamic dispatch.
type IPropertyOrLabelExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PropertyExpression() IPropertyExpressionContext
	NodeLabels() INodeLabelsContext

	// IsPropertyOrLabelExpressionContext differentiates from other interfaces.
	IsPropertyOrLabelExpressionContext()
}

type PropertyOrLabelExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyOrLabelExpressionContext() *PropertyOrLabelExpressionContext {
	var p = new(PropertyOrLabelExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_propertyOrLabelExpression
	return p
}

func InitEmptyPropertyOrLabelExpressionContext(p *PropertyOrLabelExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_propertyOrLabelExpression
}

func (*PropertyOrLabelExpressionContext) IsPropertyOrLabelExpressionContext() {}

func NewPropertyOrLabelExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyOrLabelExpressionContext {
	var p = new(PropertyOrLabelExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_propertyOrLabelExpression

	return p
}

func (s *PropertyOrLabelExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyOrLabelExpressionContext) PropertyExpression() IPropertyExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyExpressionContext)
}

func (s *PropertyOrLabelExpressionContext) NodeLabels() INodeLabelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeLabelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeLabelsContext)
}

func (s *PropertyOrLabelExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyOrLabelExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyOrLabelExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterPropertyOrLabelExpression(s)
	}
}

func (s *PropertyOrLabelExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitPropertyOrLabelExpression(s)
	}
}

func (s *PropertyOrLabelExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitPropertyOrLabelExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) PropertyOrLabelExpression() (localctx IPropertyOrLabelExpressionContext) {
	localctx = NewPropertyOrLabelExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, CypherParserRULE_propertyOrLabelExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(547)
		p.PropertyExpression()
	}
	p.SetState(549)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserCOLON {
		{
			p.SetState(548)
			p.NodeLabels()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyExpressionContext is an interface to support dynamic dispatch.
type IPropertyExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Atom() IAtomContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllName() []INameContext
	Name(i int) INameContext

	// IsPropertyExpressionContext differentiates from other interfaces.
	IsPropertyExpressionContext()
}

type PropertyExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyExpressionContext() *PropertyExpressionContext {
	var p = new(PropertyExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_propertyExpression
	return p
}

func InitEmptyPropertyExpressionContext(p *PropertyExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_propertyExpression
}

func (*PropertyExpressionContext) IsPropertyExpressionContext() {}

func NewPropertyExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyExpressionContext {
	var p = new(PropertyExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_propertyExpression

	return p
}

func (s *PropertyExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyExpressionContext) Atom() IAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *PropertyExpressionContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(CypherParserDOT)
}

func (s *PropertyExpressionContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserDOT, i)
}

func (s *PropertyExpressionContext) AllName() []INameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INameContext); ok {
			len++
		}
	}

	tst := make([]INameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INameContext); ok {
			tst[i] = t.(INameContext)
			i++
		}
	}

	return tst
}

func (s *PropertyExpressionContext) Name(i int) INameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *PropertyExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterPropertyExpression(s)
	}
}

func (s *PropertyExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitPropertyExpression(s)
	}
}

func (s *PropertyExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitPropertyExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) PropertyExpression() (localctx IPropertyExpressionContext) {
	localctx = NewPropertyExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, CypherParserRULE_propertyExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(551)
		p.Atom()
	}
	p.SetState(556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserDOT {
		{
			p.SetState(552)
			p.Match(CypherParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(553)
			p.Name()
		}

		p.SetState(558)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternPartContext is an interface to support dynamic dispatch.
type IPatternPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PatternElem() IPatternElemContext
	Symbol() ISymbolContext
	ASSIGN() antlr.TerminalNode

	// IsPatternPartContext differentiates from other interfaces.
	IsPatternPartContext()
}

type PatternPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternPartContext() *PatternPartContext {
	var p = new(PatternPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_patternPart
	return p
}

func InitEmptyPatternPartContext(p *PatternPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_patternPart
}

func (*PatternPartContext) IsPatternPartContext() {}

func NewPatternPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternPartContext {
	var p = new(PatternPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_patternPart

	return p
}

func (s *PatternPartContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternPartContext) PatternElem() IPatternElemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternElemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternElemContext)
}

func (s *PatternPartContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *PatternPartContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(CypherParserASSIGN, 0)
}

func (s *PatternPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterPatternPart(s)
	}
}

func (s *PatternPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitPatternPart(s)
	}
}

func (s *PatternPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitPatternPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) PatternPart() (localctx IPatternPartContext) {
	localctx = NewPatternPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, CypherParserRULE_patternPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(562)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-30)) & ^0x3f) == 0 && ((int64(1)<<(_la-30))&1729382256910270527) != 0 {
		{
			p.SetState(559)
			p.Symbol()
		}
		{
			p.SetState(560)
			p.Match(CypherParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(564)
		p.PatternElem()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternElemContext is an interface to support dynamic dispatch.
type IPatternElemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NodePattern() INodePatternContext
	AllPatternElemChain() []IPatternElemChainContext
	PatternElemChain(i int) IPatternElemChainContext
	LPAREN() antlr.TerminalNode
	PatternElem() IPatternElemContext
	RPAREN() antlr.TerminalNode

	// IsPatternElemContext differentiates from other interfaces.
	IsPatternElemContext()
}

type PatternElemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternElemContext() *PatternElemContext {
	var p = new(PatternElemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_patternElem
	return p
}

func InitEmptyPatternElemContext(p *PatternElemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_patternElem
}

func (*PatternElemContext) IsPatternElemContext() {}

func NewPatternElemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternElemContext {
	var p = new(PatternElemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_patternElem

	return p
}

func (s *PatternElemContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternElemContext) NodePattern() INodePatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodePatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodePatternContext)
}

func (s *PatternElemContext) AllPatternElemChain() []IPatternElemChainContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPatternElemChainContext); ok {
			len++
		}
	}

	tst := make([]IPatternElemChainContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPatternElemChainContext); ok {
			tst[i] = t.(IPatternElemChainContext)
			i++
		}
	}

	return tst
}

func (s *PatternElemContext) PatternElemChain(i int) IPatternElemChainContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternElemChainContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternElemChainContext)
}

func (s *PatternElemContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(CypherParserLPAREN, 0)
}

func (s *PatternElemContext) PatternElem() IPatternElemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternElemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternElemContext)
}

func (s *PatternElemContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(CypherParserRPAREN, 0)
}

func (s *PatternElemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternElemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternElemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterPatternElem(s)
	}
}

func (s *PatternElemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitPatternElem(s)
	}
}

func (s *PatternElemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitPatternElem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) PatternElem() (localctx IPatternElemContext) {
	localctx = NewPatternElemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, CypherParserRULE_patternElem)
	var _la int

	p.SetState(577)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(566)
			p.NodePattern()
		}
		p.SetState(570)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == CypherParserLT || _la == CypherParserSUB {
			{
				p.SetState(567)
				p.PatternElemChain()
			}

			p.SetState(572)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(573)
			p.Match(CypherParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(574)
			p.PatternElem()
		}
		{
			p.SetState(575)
			p.Match(CypherParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternElemChainContext is an interface to support dynamic dispatch.
type IPatternElemChainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RelationshipPattern() IRelationshipPatternContext
	NodePattern() INodePatternContext

	// IsPatternElemChainContext differentiates from other interfaces.
	IsPatternElemChainContext()
}

type PatternElemChainContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternElemChainContext() *PatternElemChainContext {
	var p = new(PatternElemChainContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_patternElemChain
	return p
}

func InitEmptyPatternElemChainContext(p *PatternElemChainContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_patternElemChain
}

func (*PatternElemChainContext) IsPatternElemChainContext() {}

func NewPatternElemChainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternElemChainContext {
	var p = new(PatternElemChainContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_patternElemChain

	return p
}

func (s *PatternElemChainContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternElemChainContext) RelationshipPattern() IRelationshipPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationshipPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationshipPatternContext)
}

func (s *PatternElemChainContext) NodePattern() INodePatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodePatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodePatternContext)
}

func (s *PatternElemChainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternElemChainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternElemChainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterPatternElemChain(s)
	}
}

func (s *PatternElemChainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitPatternElemChain(s)
	}
}

func (s *PatternElemChainContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitPatternElemChain(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) PatternElemChain() (localctx IPatternElemChainContext) {
	localctx = NewPatternElemChainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, CypherParserRULE_patternElemChain)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(579)
		p.RelationshipPattern()
	}
	{
		p.SetState(580)
		p.NodePattern()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertiesContext is an interface to support dynamic dispatch.
type IPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MapLit() IMapLitContext
	Parameter() IParameterContext

	// IsPropertiesContext differentiates from other interfaces.
	IsPropertiesContext()
}

type PropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertiesContext() *PropertiesContext {
	var p = new(PropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_properties
	return p
}

func InitEmptyPropertiesContext(p *PropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_properties
}

func (*PropertiesContext) IsPropertiesContext() {}

func NewPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertiesContext {
	var p = new(PropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_properties

	return p
}

func (s *PropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertiesContext) MapLit() IMapLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapLitContext)
}

func (s *PropertiesContext) Parameter() IParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *PropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterProperties(s)
	}
}

func (s *PropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitProperties(s)
	}
}

func (s *PropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Properties() (localctx IPropertiesContext) {
	localctx = NewPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, CypherParserRULE_properties)
	p.SetState(584)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CypherParserLBRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(582)
			p.MapLit()
		}

	case CypherParserDOLLAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(583)
			p.Parameter()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodePatternContext is an interface to support dynamic dispatch.
type INodePatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Symbol() ISymbolContext
	NodeLabels() INodeLabelsContext
	Properties() IPropertiesContext

	// IsNodePatternContext differentiates from other interfaces.
	IsNodePatternContext()
}

type NodePatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodePatternContext() *NodePatternContext {
	var p = new(NodePatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_nodePattern
	return p
}

func InitEmptyNodePatternContext(p *NodePatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_nodePattern
}

func (*NodePatternContext) IsNodePatternContext() {}

func NewNodePatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodePatternContext {
	var p = new(NodePatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_nodePattern

	return p
}

func (s *NodePatternContext) GetParser() antlr.Parser { return s.parser }

func (s *NodePatternContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(CypherParserLPAREN, 0)
}

func (s *NodePatternContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(CypherParserRPAREN, 0)
}

func (s *NodePatternContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *NodePatternContext) NodeLabels() INodeLabelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeLabelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeLabelsContext)
}

func (s *NodePatternContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *NodePatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodePatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodePatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterNodePattern(s)
	}
}

func (s *NodePatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitNodePattern(s)
	}
}

func (s *NodePatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitNodePattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) NodePattern() (localctx INodePatternContext) {
	localctx = NewNodePatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, CypherParserRULE_nodePattern)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(586)
		p.Match(CypherParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(588)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-30)) & ^0x3f) == 0 && ((int64(1)<<(_la-30))&1729382256910270527) != 0 {
		{
			p.SetState(587)
			p.Symbol()
		}

	}
	p.SetState(591)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserCOLON {
		{
			p.SetState(590)
			p.NodeLabels()
		}

	}
	p.SetState(594)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserLBRACE || _la == CypherParserDOLLAR {
		{
			p.SetState(593)
			p.Properties()
		}

	}
	{
		p.SetState(596)
		p.Match(CypherParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal() ILiteralContext
	Parameter() IParameterContext
	CaseExpression() ICaseExpressionContext
	CountAll() ICountAllContext
	ListComprehension() IListComprehensionContext
	PatternComprehension() IPatternComprehensionContext
	FilterWith() IFilterWithContext
	RelationshipsChainPattern() IRelationshipsChainPatternContext
	ParenthesizedExpression() IParenthesizedExpressionContext
	FunctionInvocation() IFunctionInvocationContext
	Symbol() ISymbolContext
	SubqueryExist() ISubqueryExistContext

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_atom
	return p
}

func InitEmptyAtomContext(p *AtomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_atom
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AtomContext) Parameter() IParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *AtomContext) CaseExpression() ICaseExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseExpressionContext)
}

func (s *AtomContext) CountAll() ICountAllContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICountAllContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICountAllContext)
}

func (s *AtomContext) ListComprehension() IListComprehensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListComprehensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListComprehensionContext)
}

func (s *AtomContext) PatternComprehension() IPatternComprehensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternComprehensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternComprehensionContext)
}

func (s *AtomContext) FilterWith() IFilterWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterWithContext)
}

func (s *AtomContext) RelationshipsChainPattern() IRelationshipsChainPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationshipsChainPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationshipsChainPatternContext)
}

func (s *AtomContext) ParenthesizedExpression() IParenthesizedExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedExpressionContext)
}

func (s *AtomContext) FunctionInvocation() IFunctionInvocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionInvocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionInvocationContext)
}

func (s *AtomContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *AtomContext) SubqueryExist() ISubqueryExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryExistContext)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitAtom(s)
	}
}

func (s *AtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, CypherParserRULE_atom)
	p.SetState(610)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(598)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(599)
			p.Parameter()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(600)
			p.CaseExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(601)
			p.CountAll()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(602)
			p.ListComprehension()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(603)
			p.PatternComprehension()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(604)
			p.FilterWith()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(605)
			p.RelationshipsChainPattern()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(606)
			p.ParenthesizedExpression()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(607)
			p.FunctionInvocation()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(608)
			p.Symbol()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(609)
			p.SubqueryExist()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILhsContext is an interface to support dynamic dispatch.
type ILhsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Symbol() ISymbolContext
	ASSIGN() antlr.TerminalNode

	// IsLhsContext differentiates from other interfaces.
	IsLhsContext()
}

type LhsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLhsContext() *LhsContext {
	var p = new(LhsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_lhs
	return p
}

func InitEmptyLhsContext(p *LhsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_lhs
}

func (*LhsContext) IsLhsContext() {}

func NewLhsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LhsContext {
	var p = new(LhsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_lhs

	return p
}

func (s *LhsContext) GetParser() antlr.Parser { return s.parser }

func (s *LhsContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *LhsContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(CypherParserASSIGN, 0)
}

func (s *LhsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LhsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LhsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterLhs(s)
	}
}

func (s *LhsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitLhs(s)
	}
}

func (s *LhsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitLhs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Lhs() (localctx ILhsContext) {
	localctx = NewLhsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, CypherParserRULE_lhs)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(612)
		p.Symbol()
	}
	{
		p.SetState(613)
		p.Match(CypherParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationshipPatternContext is an interface to support dynamic dispatch.
type IRelationshipPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	AllSUB() []antlr.TerminalNode
	SUB(i int) antlr.TerminalNode
	RelationDetail() IRelationDetailContext
	GT() antlr.TerminalNode

	// IsRelationshipPatternContext differentiates from other interfaces.
	IsRelationshipPatternContext()
}

type RelationshipPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationshipPatternContext() *RelationshipPatternContext {
	var p = new(RelationshipPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipPattern
	return p
}

func InitEmptyRelationshipPatternContext(p *RelationshipPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipPattern
}

func (*RelationshipPatternContext) IsRelationshipPatternContext() {}

func NewRelationshipPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationshipPatternContext {
	var p = new(RelationshipPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relationshipPattern

	return p
}

func (s *RelationshipPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationshipPatternContext) LT() antlr.TerminalNode {
	return s.GetToken(CypherParserLT, 0)
}

func (s *RelationshipPatternContext) AllSUB() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSUB)
}

func (s *RelationshipPatternContext) SUB(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSUB, i)
}

func (s *RelationshipPatternContext) RelationDetail() IRelationDetailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationDetailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationDetailContext)
}

func (s *RelationshipPatternContext) GT() antlr.TerminalNode {
	return s.GetToken(CypherParserGT, 0)
}

func (s *RelationshipPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationshipPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationshipPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterRelationshipPattern(s)
	}
}

func (s *RelationshipPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitRelationshipPattern(s)
	}
}

func (s *RelationshipPatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitRelationshipPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) RelationshipPattern() (localctx IRelationshipPatternContext) {
	localctx = NewRelationshipPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, CypherParserRULE_relationshipPattern)
	var _la int

	p.SetState(632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CypherParserLT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(615)
			p.Match(CypherParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(616)
			p.Match(CypherParserSUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(618)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserLBRACK {
			{
				p.SetState(617)
				p.RelationDetail()
			}

		}
		{
			p.SetState(620)
			p.Match(CypherParserSUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(622)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserGT {
			{
				p.SetState(621)
				p.Match(CypherParserGT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case CypherParserSUB:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(624)
			p.Match(CypherParserSUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(626)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserLBRACK {
			{
				p.SetState(625)
				p.RelationDetail()
			}

		}
		{
			p.SetState(628)
			p.Match(CypherParserSUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(630)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserGT {
			{
				p.SetState(629)
				p.Match(CypherParserGT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationDetailContext is an interface to support dynamic dispatch.
type IRelationDetailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	Symbol() ISymbolContext
	RelationshipTypes() IRelationshipTypesContext
	RangeLit() IRangeLitContext
	Properties() IPropertiesContext

	// IsRelationDetailContext differentiates from other interfaces.
	IsRelationDetailContext()
}

type RelationDetailContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationDetailContext() *RelationDetailContext {
	var p = new(RelationDetailContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_relationDetail
	return p
}

func InitEmptyRelationDetailContext(p *RelationDetailContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_relationDetail
}

func (*RelationDetailContext) IsRelationDetailContext() {}

func NewRelationDetailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationDetailContext {
	var p = new(RelationDetailContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relationDetail

	return p
}

func (s *RelationDetailContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationDetailContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(CypherParserLBRACK, 0)
}

func (s *RelationDetailContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(CypherParserRBRACK, 0)
}

func (s *RelationDetailContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *RelationDetailContext) RelationshipTypes() IRelationshipTypesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationshipTypesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationshipTypesContext)
}

func (s *RelationDetailContext) RangeLit() IRangeLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeLitContext)
}

func (s *RelationDetailContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *RelationDetailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationDetailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationDetailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterRelationDetail(s)
	}
}

func (s *RelationDetailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitRelationDetail(s)
	}
}

func (s *RelationDetailContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitRelationDetail(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) RelationDetail() (localctx IRelationDetailContext) {
	localctx = NewRelationDetailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, CypherParserRULE_relationDetail)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(634)
		p.Match(CypherParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(636)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-30)) & ^0x3f) == 0 && ((int64(1)<<(_la-30))&1729382256910270527) != 0 {
		{
			p.SetState(635)
			p.Symbol()
		}

	}
	p.SetState(639)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserCOLON {
		{
			p.SetState(638)
			p.RelationshipTypes()
		}

	}
	p.SetState(642)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserMULT {
		{
			p.SetState(641)
			p.RangeLit()
		}

	}
	p.SetState(645)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserLBRACE || _la == CypherParserDOLLAR {
		{
			p.SetState(644)
			p.Properties()
		}

	}
	{
		p.SetState(647)
		p.Match(CypherParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationshipTypesContext is an interface to support dynamic dispatch.
type IRelationshipTypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllName() []INameContext
	Name(i int) INameContext
	AllSTICK() []antlr.TerminalNode
	STICK(i int) antlr.TerminalNode

	// IsRelationshipTypesContext differentiates from other interfaces.
	IsRelationshipTypesContext()
}

type RelationshipTypesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationshipTypesContext() *RelationshipTypesContext {
	var p = new(RelationshipTypesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipTypes
	return p
}

func InitEmptyRelationshipTypesContext(p *RelationshipTypesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipTypes
}

func (*RelationshipTypesContext) IsRelationshipTypesContext() {}

func NewRelationshipTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationshipTypesContext {
	var p = new(RelationshipTypesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relationshipTypes

	return p
}

func (s *RelationshipTypesContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationshipTypesContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(CypherParserCOLON)
}

func (s *RelationshipTypesContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserCOLON, i)
}

func (s *RelationshipTypesContext) AllName() []INameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INameContext); ok {
			len++
		}
	}

	tst := make([]INameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INameContext); ok {
			tst[i] = t.(INameContext)
			i++
		}
	}

	return tst
}

func (s *RelationshipTypesContext) Name(i int) INameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *RelationshipTypesContext) AllSTICK() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSTICK)
}

func (s *RelationshipTypesContext) STICK(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSTICK, i)
}

func (s *RelationshipTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationshipTypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationshipTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterRelationshipTypes(s)
	}
}

func (s *RelationshipTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitRelationshipTypes(s)
	}
}

func (s *RelationshipTypesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitRelationshipTypes(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) RelationshipTypes() (localctx IRelationshipTypesContext) {
	localctx = NewRelationshipTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, CypherParserRULE_relationshipTypes)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(649)
		p.Match(CypherParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(650)
		p.Name()
	}
	p.SetState(658)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserSTICK {
		{
			p.SetState(651)
			p.Match(CypherParserSTICK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(653)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserCOLON {
			{
				p.SetState(652)
				p.Match(CypherParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(655)
			p.Name()
		}

		p.SetState(660)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnionStContext is an interface to support dynamic dispatch.
type IUnionStContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNION() antlr.TerminalNode
	SingleQuery() ISingleQueryContext
	ALL() antlr.TerminalNode

	// IsUnionStContext differentiates from other interfaces.
	IsUnionStContext()
}

type UnionStContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionStContext() *UnionStContext {
	var p = new(UnionStContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_unionSt
	return p
}

func InitEmptyUnionStContext(p *UnionStContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_unionSt
}

func (*UnionStContext) IsUnionStContext() {}

func NewUnionStContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionStContext {
	var p = new(UnionStContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_unionSt

	return p
}

func (s *UnionStContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionStContext) UNION() antlr.TerminalNode {
	return s.GetToken(CypherParserUNION, 0)
}

func (s *UnionStContext) SingleQuery() ISingleQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleQueryContext)
}

func (s *UnionStContext) ALL() antlr.TerminalNode {
	return s.GetToken(CypherParserALL, 0)
}

func (s *UnionStContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionStContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionStContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterUnionSt(s)
	}
}

func (s *UnionStContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitUnionSt(s)
	}
}

func (s *UnionStContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitUnionSt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) UnionSt() (localctx IUnionStContext) {
	localctx = NewUnionStContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, CypherParserRULE_unionSt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(661)
		p.Match(CypherParserUNION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(663)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserALL {
		{
			p.SetState(662)
			p.Match(CypherParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(665)
		p.SingleQuery()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubqueryExistContext is an interface to support dynamic dispatch.
type ISubqueryExistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXISTS() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	RegularQuery() IRegularQueryContext
	PatternWhere() IPatternWhereContext

	// IsSubqueryExistContext differentiates from other interfaces.
	IsSubqueryExistContext()
}

type SubqueryExistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubqueryExistContext() *SubqueryExistContext {
	var p = new(SubqueryExistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_subqueryExist
	return p
}

func InitEmptySubqueryExistContext(p *SubqueryExistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_subqueryExist
}

func (*SubqueryExistContext) IsSubqueryExistContext() {}

func NewSubqueryExistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubqueryExistContext {
	var p = new(SubqueryExistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_subqueryExist

	return p
}

func (s *SubqueryExistContext) GetParser() antlr.Parser { return s.parser }

func (s *SubqueryExistContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(CypherParserEXISTS, 0)
}

func (s *SubqueryExistContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(CypherParserLBRACE, 0)
}

func (s *SubqueryExistContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(CypherParserRBRACE, 0)
}

func (s *SubqueryExistContext) RegularQuery() IRegularQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRegularQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRegularQueryContext)
}

func (s *SubqueryExistContext) PatternWhere() IPatternWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternWhereContext)
}

func (s *SubqueryExistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryExistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubqueryExistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterSubqueryExist(s)
	}
}

func (s *SubqueryExistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitSubqueryExist(s)
	}
}

func (s *SubqueryExistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitSubqueryExist(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) SubqueryExist() (localctx ISubqueryExistContext) {
	localctx = NewSubqueryExistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, CypherParserRULE_subqueryExist)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(667)
		p.Match(CypherParserEXISTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(668)
		p.Match(CypherParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(671)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CypherParserCALL, CypherParserCREATE, CypherParserDELETE, CypherParserDETACH, CypherParserMATCH, CypherParserMERGE, CypherParserOPTIONAL, CypherParserREMOVE, CypherParserRETURN, CypherParserSET, CypherParserWITH, CypherParserUNWIND:
		{
			p.SetState(669)
			p.RegularQuery()
		}

	case CypherParserLPAREN, CypherParserFILTER, CypherParserEXTRACT, CypherParserCOUNT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserID, CypherParserESC_LITERAL:
		{
			p.SetState(670)
			p.PatternWhere()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(673)
		p.Match(CypherParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInvocationNameContext is an interface to support dynamic dispatch.
type IInvocationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSymbol() []ISymbolContext
	Symbol(i int) ISymbolContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsInvocationNameContext differentiates from other interfaces.
	IsInvocationNameContext()
}

type InvocationNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInvocationNameContext() *InvocationNameContext {
	var p = new(InvocationNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_invocationName
	return p
}

func InitEmptyInvocationNameContext(p *InvocationNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_invocationName
}

func (*InvocationNameContext) IsInvocationNameContext() {}

func NewInvocationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InvocationNameContext {
	var p = new(InvocationNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_invocationName

	return p
}

func (s *InvocationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *InvocationNameContext) AllSymbol() []ISymbolContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolContext); ok {
			len++
		}
	}

	tst := make([]ISymbolContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolContext); ok {
			tst[i] = t.(ISymbolContext)
			i++
		}
	}

	return tst
}

func (s *InvocationNameContext) Symbol(i int) ISymbolContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *InvocationNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(CypherParserDOT)
}

func (s *InvocationNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserDOT, i)
}

func (s *InvocationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InvocationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InvocationNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterInvocationName(s)
	}
}

func (s *InvocationNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitInvocationName(s)
	}
}

func (s *InvocationNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitInvocationName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) InvocationName() (localctx IInvocationNameContext) {
	localctx = NewInvocationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, CypherParserRULE_invocationName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(675)
		p.Symbol()
	}
	p.SetState(680)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserDOT {
		{
			p.SetState(676)
			p.Match(CypherParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(677)
			p.Symbol()
		}

		p.SetState(682)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionInvocationContext is an interface to support dynamic dispatch.
type IFunctionInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InvocationName() IInvocationNameContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	ExpressionChain() IExpressionChainContext

	// IsFunctionInvocationContext differentiates from other interfaces.
	IsFunctionInvocationContext()
}

type FunctionInvocationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionInvocationContext() *FunctionInvocationContext {
	var p = new(FunctionInvocationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_functionInvocation
	return p
}

func InitEmptyFunctionInvocationContext(p *FunctionInvocationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_functionInvocation
}

func (*FunctionInvocationContext) IsFunctionInvocationContext() {}

func NewFunctionInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionInvocationContext {
	var p = new(FunctionInvocationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_functionInvocation

	return p
}

func (s *FunctionInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionInvocationContext) InvocationName() IInvocationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInvocationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInvocationNameContext)
}

func (s *FunctionInvocationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(CypherParserLPAREN, 0)
}

func (s *FunctionInvocationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(CypherParserRPAREN, 0)
}

func (s *FunctionInvocationContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(CypherParserDISTINCT, 0)
}

func (s *FunctionInvocationContext) ExpressionChain() IExpressionChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionChainContext)
}

func (s *FunctionInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterFunctionInvocation(s)
	}
}

func (s *FunctionInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitFunctionInvocation(s)
	}
}

func (s *FunctionInvocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitFunctionInvocation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) FunctionInvocation() (localctx IFunctionInvocationContext) {
	localctx = NewFunctionInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, CypherParserRULE_functionInvocation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(683)
		p.InvocationName()
	}
	{
		p.SetState(684)
		p.Match(CypherParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserDISTINCT {
		{
			p.SetState(685)
			p.Match(CypherParserDISTINCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(689)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&35320872390656) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&130027633) != 0) {
		{
			p.SetState(688)
			p.ExpressionChain()
		}

	}
	{
		p.SetState(691)
		p.Match(CypherParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParenthesizedExpressionContext is an interface to support dynamic dispatch.
type IParenthesizedExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsParenthesizedExpressionContext differentiates from other interfaces.
	IsParenthesizedExpressionContext()
}

type ParenthesizedExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedExpressionContext() *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_parenthesizedExpression
	return p
}

func InitEmptyParenthesizedExpressionContext(p *ParenthesizedExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_parenthesizedExpression
}

func (*ParenthesizedExpressionContext) IsParenthesizedExpressionContext() {}

func NewParenthesizedExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_parenthesizedExpression

	return p
}

func (s *ParenthesizedExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(CypherParserLPAREN, 0)
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(CypherParserRPAREN, 0)
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitParenthesizedExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ParenthesizedExpression() (localctx IParenthesizedExpressionContext) {
	localctx = NewParenthesizedExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, CypherParserRULE_parenthesizedExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(693)
		p.Match(CypherParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(694)
		p.Expression()
	}
	{
		p.SetState(695)
		p.Match(CypherParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilterWithContext is an interface to support dynamic dispatch.
type IFilterWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	FilterExpression() IFilterExpressionContext
	RPAREN() antlr.TerminalNode
	ALL() antlr.TerminalNode
	ANY() antlr.TerminalNode
	NONE() antlr.TerminalNode
	SINGLE() antlr.TerminalNode

	// IsFilterWithContext differentiates from other interfaces.
	IsFilterWithContext()
}

type FilterWithContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterWithContext() *FilterWithContext {
	var p = new(FilterWithContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_filterWith
	return p
}

func InitEmptyFilterWithContext(p *FilterWithContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_filterWith
}

func (*FilterWithContext) IsFilterWithContext() {}

func NewFilterWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterWithContext {
	var p = new(FilterWithContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_filterWith

	return p
}

func (s *FilterWithContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterWithContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(CypherParserLPAREN, 0)
}

func (s *FilterWithContext) FilterExpression() IFilterExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterExpressionContext)
}

func (s *FilterWithContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(CypherParserRPAREN, 0)
}

func (s *FilterWithContext) ALL() antlr.TerminalNode {
	return s.GetToken(CypherParserALL, 0)
}

func (s *FilterWithContext) ANY() antlr.TerminalNode {
	return s.GetToken(CypherParserANY, 0)
}

func (s *FilterWithContext) NONE() antlr.TerminalNode {
	return s.GetToken(CypherParserNONE, 0)
}

func (s *FilterWithContext) SINGLE() antlr.TerminalNode {
	return s.GetToken(CypherParserSINGLE, 0)
}

func (s *FilterWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterFilterWith(s)
	}
}

func (s *FilterWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitFilterWith(s)
	}
}

func (s *FilterWithContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitFilterWith(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) FilterWith() (localctx IFilterWithContext) {
	localctx = NewFilterWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, CypherParserRULE_filterWith)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(697)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&128849018880) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(698)
		p.Match(CypherParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(699)
		p.FilterExpression()
	}
	{
		p.SetState(700)
		p.Match(CypherParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternComprehensionContext is an interface to support dynamic dispatch.
type IPatternComprehensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	RelationshipsChainPattern() IRelationshipsChainPatternContext
	STICK() antlr.TerminalNode
	Expression() IExpressionContext
	RBRACK() antlr.TerminalNode
	Lhs() ILhsContext
	Where() IWhereContext

	// IsPatternComprehensionContext differentiates from other interfaces.
	IsPatternComprehensionContext()
}

type PatternComprehensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternComprehensionContext() *PatternComprehensionContext {
	var p = new(PatternComprehensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_patternComprehension
	return p
}

func InitEmptyPatternComprehensionContext(p *PatternComprehensionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_patternComprehension
}

func (*PatternComprehensionContext) IsPatternComprehensionContext() {}

func NewPatternComprehensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternComprehensionContext {
	var p = new(PatternComprehensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_patternComprehension

	return p
}

func (s *PatternComprehensionContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternComprehensionContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(CypherParserLBRACK, 0)
}

func (s *PatternComprehensionContext) RelationshipsChainPattern() IRelationshipsChainPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationshipsChainPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationshipsChainPatternContext)
}

func (s *PatternComprehensionContext) STICK() antlr.TerminalNode {
	return s.GetToken(CypherParserSTICK, 0)
}

func (s *PatternComprehensionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PatternComprehensionContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(CypherParserRBRACK, 0)
}

func (s *PatternComprehensionContext) Lhs() ILhsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILhsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILhsContext)
}

func (s *PatternComprehensionContext) Where() IWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereContext)
}

func (s *PatternComprehensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternComprehensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternComprehensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterPatternComprehension(s)
	}
}

func (s *PatternComprehensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitPatternComprehension(s)
	}
}

func (s *PatternComprehensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitPatternComprehension(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) PatternComprehension() (localctx IPatternComprehensionContext) {
	localctx = NewPatternComprehensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, CypherParserRULE_patternComprehension)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.Match(CypherParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(704)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-30)) & ^0x3f) == 0 && ((int64(1)<<(_la-30))&1729382256910270527) != 0 {
		{
			p.SetState(703)
			p.Lhs()
		}

	}
	{
		p.SetState(706)
		p.RelationshipsChainPattern()
	}
	p.SetState(708)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserWHERE {
		{
			p.SetState(707)
			p.Where()
		}

	}
	{
		p.SetState(710)
		p.Match(CypherParserSTICK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(711)
		p.Expression()
	}
	{
		p.SetState(712)
		p.Match(CypherParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationshipsChainPatternContext is an interface to support dynamic dispatch.
type IRelationshipsChainPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NodePattern() INodePatternContext
	AllPatternElemChain() []IPatternElemChainContext
	PatternElemChain(i int) IPatternElemChainContext

	// IsRelationshipsChainPatternContext differentiates from other interfaces.
	IsRelationshipsChainPatternContext()
}

type RelationshipsChainPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationshipsChainPatternContext() *RelationshipsChainPatternContext {
	var p = new(RelationshipsChainPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipsChainPattern
	return p
}

func InitEmptyRelationshipsChainPatternContext(p *RelationshipsChainPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipsChainPattern
}

func (*RelationshipsChainPatternContext) IsRelationshipsChainPatternContext() {}

func NewRelationshipsChainPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationshipsChainPatternContext {
	var p = new(RelationshipsChainPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relationshipsChainPattern

	return p
}

func (s *RelationshipsChainPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationshipsChainPatternContext) NodePattern() INodePatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodePatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodePatternContext)
}

func (s *RelationshipsChainPatternContext) AllPatternElemChain() []IPatternElemChainContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPatternElemChainContext); ok {
			len++
		}
	}

	tst := make([]IPatternElemChainContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPatternElemChainContext); ok {
			tst[i] = t.(IPatternElemChainContext)
			i++
		}
	}

	return tst
}

func (s *RelationshipsChainPatternContext) PatternElemChain(i int) IPatternElemChainContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternElemChainContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternElemChainContext)
}

func (s *RelationshipsChainPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationshipsChainPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationshipsChainPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterRelationshipsChainPattern(s)
	}
}

func (s *RelationshipsChainPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitRelationshipsChainPattern(s)
	}
}

func (s *RelationshipsChainPatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitRelationshipsChainPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) RelationshipsChainPattern() (localctx IRelationshipsChainPatternContext) {
	localctx = NewRelationshipsChainPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, CypherParserRULE_relationshipsChainPattern)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(714)
		p.NodePattern()
	}
	p.SetState(716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(715)
				p.PatternElemChain()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(718)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListComprehensionContext is an interface to support dynamic dispatch.
type IListComprehensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	FilterExpression() IFilterExpressionContext
	RBRACK() antlr.TerminalNode
	STICK() antlr.TerminalNode
	Expression() IExpressionContext

	// IsListComprehensionContext differentiates from other interfaces.
	IsListComprehensionContext()
}

type ListComprehensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListComprehensionContext() *ListComprehensionContext {
	var p = new(ListComprehensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_listComprehension
	return p
}

func InitEmptyListComprehensionContext(p *ListComprehensionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_listComprehension
}

func (*ListComprehensionContext) IsListComprehensionContext() {}

func NewListComprehensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListComprehensionContext {
	var p = new(ListComprehensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_listComprehension

	return p
}

func (s *ListComprehensionContext) GetParser() antlr.Parser { return s.parser }

func (s *ListComprehensionContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(CypherParserLBRACK, 0)
}

func (s *ListComprehensionContext) FilterExpression() IFilterExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterExpressionContext)
}

func (s *ListComprehensionContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(CypherParserRBRACK, 0)
}

func (s *ListComprehensionContext) STICK() antlr.TerminalNode {
	return s.GetToken(CypherParserSTICK, 0)
}

func (s *ListComprehensionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ListComprehensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListComprehensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListComprehensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterListComprehension(s)
	}
}

func (s *ListComprehensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitListComprehension(s)
	}
}

func (s *ListComprehensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitListComprehension(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ListComprehension() (localctx IListComprehensionContext) {
	localctx = NewListComprehensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, CypherParserRULE_listComprehension)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(720)
		p.Match(CypherParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(721)
		p.FilterExpression()
	}
	p.SetState(724)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSTICK {
		{
			p.SetState(722)
			p.Match(CypherParserSTICK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(723)
			p.Expression()
		}

	}
	{
		p.SetState(726)
		p.Match(CypherParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilterExpressionContext is an interface to support dynamic dispatch.
type IFilterExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Symbol() ISymbolContext
	IN() antlr.TerminalNode
	Expression() IExpressionContext
	Where() IWhereContext

	// IsFilterExpressionContext differentiates from other interfaces.
	IsFilterExpressionContext()
}

type FilterExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterExpressionContext() *FilterExpressionContext {
	var p = new(FilterExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_filterExpression
	return p
}

func InitEmptyFilterExpressionContext(p *FilterExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_filterExpression
}

func (*FilterExpressionContext) IsFilterExpressionContext() {}

func NewFilterExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterExpressionContext {
	var p = new(FilterExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_filterExpression

	return p
}

func (s *FilterExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterExpressionContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *FilterExpressionContext) IN() antlr.TerminalNode {
	return s.GetToken(CypherParserIN, 0)
}

func (s *FilterExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FilterExpressionContext) Where() IWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereContext)
}

func (s *FilterExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterFilterExpression(s)
	}
}

func (s *FilterExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitFilterExpression(s)
	}
}

func (s *FilterExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitFilterExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) FilterExpression() (localctx IFilterExpressionContext) {
	localctx = NewFilterExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, CypherParserRULE_filterExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(728)
		p.Symbol()
	}
	{
		p.SetState(729)
		p.Match(CypherParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(730)
		p.Expression()
	}
	p.SetState(732)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserWHERE {
		{
			p.SetState(731)
			p.Where()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICountAllContext is an interface to support dynamic dispatch.
type ICountAllContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COUNT() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	MULT() antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsCountAllContext differentiates from other interfaces.
	IsCountAllContext()
}

type CountAllContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCountAllContext() *CountAllContext {
	var p = new(CountAllContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_countAll
	return p
}

func InitEmptyCountAllContext(p *CountAllContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_countAll
}

func (*CountAllContext) IsCountAllContext() {}

func NewCountAllContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CountAllContext {
	var p = new(CountAllContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_countAll

	return p
}

func (s *CountAllContext) GetParser() antlr.Parser { return s.parser }

func (s *CountAllContext) COUNT() antlr.TerminalNode {
	return s.GetToken(CypherParserCOUNT, 0)
}

func (s *CountAllContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(CypherParserLPAREN, 0)
}

func (s *CountAllContext) MULT() antlr.TerminalNode {
	return s.GetToken(CypherParserMULT, 0)
}

func (s *CountAllContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(CypherParserRPAREN, 0)
}

func (s *CountAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CountAllContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CountAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterCountAll(s)
	}
}

func (s *CountAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitCountAll(s)
	}
}

func (s *CountAllContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitCountAll(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) CountAll() (localctx ICountAllContext) {
	localctx = NewCountAllContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, CypherParserRULE_countAll)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(734)
		p.Match(CypherParserCOUNT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(735)
		p.Match(CypherParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(736)
		p.Match(CypherParserMULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(737)
		p.Match(CypherParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionChainContext is an interface to support dynamic dispatch.
type IExpressionChainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpressionChainContext differentiates from other interfaces.
	IsExpressionChainContext()
}

type ExpressionChainContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionChainContext() *ExpressionChainContext {
	var p = new(ExpressionChainContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_expressionChain
	return p
}

func InitEmptyExpressionChainContext(p *ExpressionChainContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_expressionChain
}

func (*ExpressionChainContext) IsExpressionChainContext() {}

func NewExpressionChainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionChainContext {
	var p = new(ExpressionChainContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_expressionChain

	return p
}

func (s *ExpressionChainContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionChainContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionChainContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionChainContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(CypherParserCOMMA)
}

func (s *ExpressionChainContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserCOMMA, i)
}

func (s *ExpressionChainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionChainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionChainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterExpressionChain(s)
	}
}

func (s *ExpressionChainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitExpressionChain(s)
	}
}

func (s *ExpressionChainContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitExpressionChain(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ExpressionChain() (localctx IExpressionChainContext) {
	localctx = NewExpressionChainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, CypherParserRULE_expressionChain)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(739)
		p.Expression()
	}
	p.SetState(744)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserCOMMA {
		{
			p.SetState(740)
			p.Match(CypherParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(741)
			p.Expression()
		}

		p.SetState(746)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseExpressionContext is an interface to support dynamic dispatch.
type ICaseExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	END() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllWHEN() []antlr.TerminalNode
	WHEN(i int) antlr.TerminalNode
	AllTHEN() []antlr.TerminalNode
	THEN(i int) antlr.TerminalNode
	ELSE() antlr.TerminalNode

	// IsCaseExpressionContext differentiates from other interfaces.
	IsCaseExpressionContext()
}

type CaseExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseExpressionContext() *CaseExpressionContext {
	var p = new(CaseExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_caseExpression
	return p
}

func InitEmptyCaseExpressionContext(p *CaseExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_caseExpression
}

func (*CaseExpressionContext) IsCaseExpressionContext() {}

func NewCaseExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseExpressionContext {
	var p = new(CaseExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_caseExpression

	return p
}

func (s *CaseExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseExpressionContext) CASE() antlr.TerminalNode {
	return s.GetToken(CypherParserCASE, 0)
}

func (s *CaseExpressionContext) END() antlr.TerminalNode {
	return s.GetToken(CypherParserEND, 0)
}

func (s *CaseExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CaseExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseExpressionContext) AllWHEN() []antlr.TerminalNode {
	return s.GetTokens(CypherParserWHEN)
}

func (s *CaseExpressionContext) WHEN(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserWHEN, i)
}

func (s *CaseExpressionContext) AllTHEN() []antlr.TerminalNode {
	return s.GetTokens(CypherParserTHEN)
}

func (s *CaseExpressionContext) THEN(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserTHEN, i)
}

func (s *CaseExpressionContext) ELSE() antlr.TerminalNode {
	return s.GetToken(CypherParserELSE, 0)
}

func (s *CaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterCaseExpression(s)
	}
}

func (s *CaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitCaseExpression(s)
	}
}

func (s *CaseExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitCaseExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) CaseExpression() (localctx ICaseExpressionContext) {
	localctx = NewCaseExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, CypherParserRULE_caseExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(747)
		p.Match(CypherParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(749)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&35320872390656) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&130027633) != 0) {
		{
			p.SetState(748)
			p.Expression()
		}

	}
	p.SetState(756)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == CypherParserWHEN {
		{
			p.SetState(751)
			p.Match(CypherParserWHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(752)
			p.Expression()
		}
		{
			p.SetState(753)
			p.Match(CypherParserTHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(754)
			p.Expression()
		}

		p.SetState(758)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserELSE {
		{
			p.SetState(760)
			p.Match(CypherParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(761)
			p.Expression()
		}

	}
	{
		p.SetState(764)
		p.Match(CypherParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterContext is an interface to support dynamic dispatch.
type IParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOLLAR() antlr.TerminalNode
	Symbol() ISymbolContext
	NumLit() INumLitContext

	// IsParameterContext differentiates from other interfaces.
	IsParameterContext()
}

type ParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterContext() *ParameterContext {
	var p = new(ParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_parameter
	return p
}

func InitEmptyParameterContext(p *ParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_parameter
}

func (*ParameterContext) IsParameterContext() {}

func NewParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterContext {
	var p = new(ParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_parameter

	return p
}

func (s *ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(CypherParserDOLLAR, 0)
}

func (s *ParameterContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *ParameterContext) NumLit() INumLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumLitContext)
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (s *ParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Parameter() (localctx IParameterContext) {
	localctx = NewParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, CypherParserRULE_parameter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(766)
		p.Match(CypherParserDOLLAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(769)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CypherParserFILTER, CypherParserEXTRACT, CypherParserCOUNT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserID, CypherParserESC_LITERAL:
		{
			p.SetState(767)
			p.Symbol()
		}

	case CypherParserDIGIT:
		{
			p.SetState(768)
			p.NumLit()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BoolLit() IBoolLitContext
	NumLit() INumLitContext
	NULL_W() antlr.TerminalNode
	StringLit() IStringLitContext
	CharLit() ICharLitContext
	ListLit() IListLitContext
	MapLit() IMapLitContext

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) BoolLit() IBoolLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoolLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoolLitContext)
}

func (s *LiteralContext) NumLit() INumLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumLitContext)
}

func (s *LiteralContext) NULL_W() antlr.TerminalNode {
	return s.GetToken(CypherParserNULL_W, 0)
}

func (s *LiteralContext) StringLit() IStringLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLitContext)
}

func (s *LiteralContext) CharLit() ICharLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharLitContext)
}

func (s *LiteralContext) ListLit() IListLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListLitContext)
}

func (s *LiteralContext) MapLit() IMapLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapLitContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, CypherParserRULE_literal)
	p.SetState(778)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CypherParserFALSE, CypherParserTRUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(771)
			p.BoolLit()
		}

	case CypherParserDIGIT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(772)
			p.NumLit()
		}

	case CypherParserNULL_W:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(773)
			p.Match(CypherParserNULL_W)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CypherParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(774)
			p.StringLit()
		}

	case CypherParserCHAR_LITERAL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(775)
			p.CharLit()
		}

	case CypherParserLBRACK:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(776)
			p.ListLit()
		}

	case CypherParserLBRACE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(777)
			p.MapLit()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangeLitContext is an interface to support dynamic dispatch.
type IRangeLitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MULT() antlr.TerminalNode
	AllNumLit() []INumLitContext
	NumLit(i int) INumLitContext
	RANGE() antlr.TerminalNode

	// IsRangeLitContext differentiates from other interfaces.
	IsRangeLitContext()
}

type RangeLitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeLitContext() *RangeLitContext {
	var p = new(RangeLitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_rangeLit
	return p
}

func InitEmptyRangeLitContext(p *RangeLitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_rangeLit
}

func (*RangeLitContext) IsRangeLitContext() {}

func NewRangeLitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeLitContext {
	var p = new(RangeLitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_rangeLit

	return p
}

func (s *RangeLitContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeLitContext) MULT() antlr.TerminalNode {
	return s.GetToken(CypherParserMULT, 0)
}

func (s *RangeLitContext) AllNumLit() []INumLitContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INumLitContext); ok {
			len++
		}
	}

	tst := make([]INumLitContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INumLitContext); ok {
			tst[i] = t.(INumLitContext)
			i++
		}
	}

	return tst
}

func (s *RangeLitContext) NumLit(i int) INumLitContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumLitContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumLitContext)
}

func (s *RangeLitContext) RANGE() antlr.TerminalNode {
	return s.GetToken(CypherParserRANGE, 0)
}

func (s *RangeLitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeLitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeLitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterRangeLit(s)
	}
}

func (s *RangeLitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitRangeLit(s)
	}
}

func (s *RangeLitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitRangeLit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) RangeLit() (localctx IRangeLitContext) {
	localctx = NewRangeLitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, CypherParserRULE_rangeLit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(780)
		p.Match(CypherParserMULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(782)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserDIGIT {
		{
			p.SetState(781)
			p.NumLit()
		}

	}
	p.SetState(788)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserRANGE {
		{
			p.SetState(784)
			p.Match(CypherParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(786)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserDIGIT {
			{
				p.SetState(785)
				p.NumLit()
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBoolLitContext is an interface to support dynamic dispatch.
type IBoolLitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBoolLitContext differentiates from other interfaces.
	IsBoolLitContext()
}

type BoolLitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoolLitContext() *BoolLitContext {
	var p = new(BoolLitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_boolLit
	return p
}

func InitEmptyBoolLitContext(p *BoolLitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_boolLit
}

func (*BoolLitContext) IsBoolLitContext() {}

func NewBoolLitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BoolLitContext {
	var p = new(BoolLitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_boolLit

	return p
}

func (s *BoolLitContext) GetParser() antlr.Parser { return s.parser }

func (s *BoolLitContext) TRUE() antlr.TerminalNode {
	return s.GetToken(CypherParserTRUE, 0)
}

func (s *BoolLitContext) FALSE() antlr.TerminalNode {
	return s.GetToken(CypherParserFALSE, 0)
}

func (s *BoolLitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoolLitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BoolLitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterBoolLit(s)
	}
}

func (s *BoolLitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitBoolLit(s)
	}
}

func (s *BoolLitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitBoolLit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) BoolLit() (localctx IBoolLitContext) {
	localctx = NewBoolLitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, CypherParserRULE_boolLit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(790)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CypherParserFALSE || _la == CypherParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumLitContext is an interface to support dynamic dispatch.
type INumLitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DIGIT() antlr.TerminalNode

	// IsNumLitContext differentiates from other interfaces.
	IsNumLitContext()
}

type NumLitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumLitContext() *NumLitContext {
	var p = new(NumLitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_numLit
	return p
}

func InitEmptyNumLitContext(p *NumLitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_numLit
}

func (*NumLitContext) IsNumLitContext() {}

func NewNumLitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumLitContext {
	var p = new(NumLitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_numLit

	return p
}

func (s *NumLitContext) GetParser() antlr.Parser { return s.parser }

func (s *NumLitContext) DIGIT() antlr.TerminalNode {
	return s.GetToken(CypherParserDIGIT, 0)
}

func (s *NumLitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumLitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumLitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterNumLit(s)
	}
}

func (s *NumLitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitNumLit(s)
	}
}

func (s *NumLitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitNumLit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) NumLit() (localctx INumLitContext) {
	localctx = NewNumLitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, CypherParserRULE_numLit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(792)
		p.Match(CypherParserDIGIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLitContext is an interface to support dynamic dispatch.
type IStringLitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_LITERAL() antlr.TerminalNode

	// IsStringLitContext differentiates from other interfaces.
	IsStringLitContext()
}

type StringLitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLitContext() *StringLitContext {
	var p = new(StringLitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_stringLit
	return p
}

func InitEmptyStringLitContext(p *StringLitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_stringLit
}

func (*StringLitContext) IsStringLitContext() {}

func NewStringLitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLitContext {
	var p = new(StringLitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_stringLit

	return p
}

func (s *StringLitContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLitContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(CypherParserSTRING_LITERAL, 0)
}

func (s *StringLitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterStringLit(s)
	}
}

func (s *StringLitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitStringLit(s)
	}
}

func (s *StringLitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitStringLit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) StringLit() (localctx IStringLitContext) {
	localctx = NewStringLitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, CypherParserRULE_stringLit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(794)
		p.Match(CypherParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharLitContext is an interface to support dynamic dispatch.
type ICharLitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHAR_LITERAL() antlr.TerminalNode

	// IsCharLitContext differentiates from other interfaces.
	IsCharLitContext()
}

type CharLitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharLitContext() *CharLitContext {
	var p = new(CharLitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_charLit
	return p
}

func InitEmptyCharLitContext(p *CharLitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_charLit
}

func (*CharLitContext) IsCharLitContext() {}

func NewCharLitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharLitContext {
	var p = new(CharLitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_charLit

	return p
}

func (s *CharLitContext) GetParser() antlr.Parser { return s.parser }

func (s *CharLitContext) CHAR_LITERAL() antlr.TerminalNode {
	return s.GetToken(CypherParserCHAR_LITERAL, 0)
}

func (s *CharLitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharLitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharLitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterCharLit(s)
	}
}

func (s *CharLitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitCharLit(s)
	}
}

func (s *CharLitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitCharLit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) CharLit() (localctx ICharLitContext) {
	localctx = NewCharLitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, CypherParserRULE_charLit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(796)
		p.Match(CypherParserCHAR_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListLitContext is an interface to support dynamic dispatch.
type IListLitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	ExpressionChain() IExpressionChainContext

	// IsListLitContext differentiates from other interfaces.
	IsListLitContext()
}

type ListLitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListLitContext() *ListLitContext {
	var p = new(ListLitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_listLit
	return p
}

func InitEmptyListLitContext(p *ListLitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_listLit
}

func (*ListLitContext) IsListLitContext() {}

func NewListLitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListLitContext {
	var p = new(ListLitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_listLit

	return p
}

func (s *ListLitContext) GetParser() antlr.Parser { return s.parser }

func (s *ListLitContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(CypherParserLBRACK, 0)
}

func (s *ListLitContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(CypherParserRBRACK, 0)
}

func (s *ListLitContext) ExpressionChain() IExpressionChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionChainContext)
}

func (s *ListLitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListLitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListLitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterListLit(s)
	}
}

func (s *ListLitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitListLit(s)
	}
}

func (s *ListLitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitListLit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ListLit() (localctx IListLitContext) {
	localctx = NewListLitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, CypherParserRULE_listLit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(798)
		p.Match(CypherParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(800)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&35320872390656) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&130027633) != 0) {
		{
			p.SetState(799)
			p.ExpressionChain()
		}

	}
	{
		p.SetState(802)
		p.Match(CypherParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapLitContext is an interface to support dynamic dispatch.
type IMapLitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllMapPair() []IMapPairContext
	MapPair(i int) IMapPairContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMapLitContext differentiates from other interfaces.
	IsMapLitContext()
}

type MapLitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapLitContext() *MapLitContext {
	var p = new(MapLitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_mapLit
	return p
}

func InitEmptyMapLitContext(p *MapLitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_mapLit
}

func (*MapLitContext) IsMapLitContext() {}

func NewMapLitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapLitContext {
	var p = new(MapLitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_mapLit

	return p
}

func (s *MapLitContext) GetParser() antlr.Parser { return s.parser }

func (s *MapLitContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(CypherParserLBRACE, 0)
}

func (s *MapLitContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(CypherParserRBRACE, 0)
}

func (s *MapLitContext) AllMapPair() []IMapPairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMapPairContext); ok {
			len++
		}
	}

	tst := make([]IMapPairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMapPairContext); ok {
			tst[i] = t.(IMapPairContext)
			i++
		}
	}

	return tst
}

func (s *MapLitContext) MapPair(i int) IMapPairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapPairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapPairContext)
}

func (s *MapLitContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(CypherParserCOMMA)
}

func (s *MapLitContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserCOMMA, i)
}

func (s *MapLitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapLitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapLitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterMapLit(s)
	}
}

func (s *MapLitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitMapLit(s)
	}
}

func (s *MapLitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitMapLit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) MapLit() (localctx IMapLitContext) {
	localctx = NewMapLitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, CypherParserRULE_mapLit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(804)
		p.Match(CypherParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(813)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-30)) & ^0x3f) == 0 && ((int64(1)<<(_la-30))&2305843009213693951) != 0 {
		{
			p.SetState(805)
			p.MapPair()
		}
		p.SetState(810)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == CypherParserCOMMA {
			{
				p.SetState(806)
				p.Match(CypherParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(807)
				p.MapPair()
			}

			p.SetState(812)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(815)
		p.Match(CypherParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapPairContext is an interface to support dynamic dispatch.
type IMapPairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext
	COLON() antlr.TerminalNode
	Expression() IExpressionContext

	// IsMapPairContext differentiates from other interfaces.
	IsMapPairContext()
}

type MapPairContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapPairContext() *MapPairContext {
	var p = new(MapPairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_mapPair
	return p
}

func InitEmptyMapPairContext(p *MapPairContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_mapPair
}

func (*MapPairContext) IsMapPairContext() {}

func NewMapPairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapPairContext {
	var p = new(MapPairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_mapPair

	return p
}

func (s *MapPairContext) GetParser() antlr.Parser { return s.parser }

func (s *MapPairContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *MapPairContext) COLON() antlr.TerminalNode {
	return s.GetToken(CypherParserCOLON, 0)
}

func (s *MapPairContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MapPairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapPairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapPairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterMapPair(s)
	}
}

func (s *MapPairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitMapPair(s)
	}
}

func (s *MapPairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitMapPair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) MapPair() (localctx IMapPairContext) {
	localctx = NewMapPairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, CypherParserRULE_mapPair)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(817)
		p.Name()
	}
	{
		p.SetState(818)
		p.Match(CypherParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(819)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INameContext is an interface to support dynamic dispatch.
type INameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Symbol() ISymbolContext
	ReservedWord() IReservedWordContext

	// IsNameContext differentiates from other interfaces.
	IsNameContext()
}

type NameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameContext() *NameContext {
	var p = new(NameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_name
	return p
}

func InitEmptyNameContext(p *NameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_name
}

func (*NameContext) IsNameContext() {}

func NewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameContext {
	var p = new(NameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_name

	return p
}

func (s *NameContext) GetParser() antlr.Parser { return s.parser }

func (s *NameContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *NameContext) ReservedWord() IReservedWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReservedWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReservedWordContext)
}

func (s *NameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterName(s)
	}
}

func (s *NameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitName(s)
	}
}

func (s *NameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Name() (localctx INameContext) {
	localctx = NewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, CypherParserRULE_name)
	p.SetState(823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CypherParserFILTER, CypherParserEXTRACT, CypherParserCOUNT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserID, CypherParserESC_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(821)
			p.Symbol()
		}

	case CypherParserALL, CypherParserASC, CypherParserASCENDING, CypherParserBY, CypherParserCREATE, CypherParserDELETE, CypherParserDESC, CypherParserDESCENDING, CypherParserDETACH, CypherParserEXISTS, CypherParserLIMIT, CypherParserMATCH, CypherParserMERGE, CypherParserON, CypherParserOPTIONAL, CypherParserORDER, CypherParserREMOVE, CypherParserRETURN, CypherParserSET, CypherParserSKIP_W, CypherParserWHERE, CypherParserWITH, CypherParserUNION, CypherParserUNWIND, CypherParserAND, CypherParserAS, CypherParserCONTAINS, CypherParserDISTINCT, CypherParserENDS, CypherParserIN, CypherParserIS, CypherParserNOT, CypherParserOR, CypherParserSTARTS, CypherParserXOR, CypherParserFALSE, CypherParserTRUE, CypherParserNULL_W, CypherParserCONSTRAINT, CypherParserDO, CypherParserFOR, CypherParserREQUIRE, CypherParserUNIQUE, CypherParserCASE, CypherParserWHEN, CypherParserTHEN, CypherParserELSE, CypherParserEND, CypherParserMANDATORY, CypherParserSCALAR, CypherParserOF, CypherParserADD, CypherParserDROP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(822)
			p.ReservedWord()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISymbolContext is an interface to support dynamic dispatch.
type ISymbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ESC_LITERAL() antlr.TerminalNode
	ID() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	EXTRACT() antlr.TerminalNode
	ANY() antlr.TerminalNode
	NONE() antlr.TerminalNode
	SINGLE() antlr.TerminalNode

	// IsSymbolContext differentiates from other interfaces.
	IsSymbolContext()
}

type SymbolContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolContext() *SymbolContext {
	var p = new(SymbolContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_symbol
	return p
}

func InitEmptySymbolContext(p *SymbolContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_symbol
}

func (*SymbolContext) IsSymbolContext() {}

func NewSymbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolContext {
	var p = new(SymbolContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_symbol

	return p
}

func (s *SymbolContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolContext) ESC_LITERAL() antlr.TerminalNode {
	return s.GetToken(CypherParserESC_LITERAL, 0)
}

func (s *SymbolContext) ID() antlr.TerminalNode {
	return s.GetToken(CypherParserID, 0)
}

func (s *SymbolContext) COUNT() antlr.TerminalNode {
	return s.GetToken(CypherParserCOUNT, 0)
}

func (s *SymbolContext) FILTER() antlr.TerminalNode {
	return s.GetToken(CypherParserFILTER, 0)
}

func (s *SymbolContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(CypherParserEXTRACT, 0)
}

func (s *SymbolContext) ANY() antlr.TerminalNode {
	return s.GetToken(CypherParserANY, 0)
}

func (s *SymbolContext) NONE() antlr.TerminalNode {
	return s.GetToken(CypherParserNONE, 0)
}

func (s *SymbolContext) SINGLE() antlr.TerminalNode {
	return s.GetToken(CypherParserSINGLE, 0)
}

func (s *SymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterSymbol(s)
	}
}

func (s *SymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitSymbol(s)
	}
}

func (s *SymbolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitSymbol(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Symbol() (localctx ISymbolContext) {
	localctx = NewSymbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, CypherParserRULE_symbol)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(825)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-30)) & ^0x3f) == 0 && ((int64(1)<<(_la-30))&1729382256910270527) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReservedWordContext is an interface to support dynamic dispatch.
type IReservedWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	ASC() antlr.TerminalNode
	ASCENDING() antlr.TerminalNode
	BY() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	DESC() antlr.TerminalNode
	DESCENDING() antlr.TerminalNode
	DETACH() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	MATCH() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	ON() antlr.TerminalNode
	OPTIONAL() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	RETURN() antlr.TerminalNode
	SET() antlr.TerminalNode
	SKIP_W() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	WITH() antlr.TerminalNode
	UNION() antlr.TerminalNode
	UNWIND() antlr.TerminalNode
	AND() antlr.TerminalNode
	AS() antlr.TerminalNode
	CONTAINS() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	ENDS() antlr.TerminalNode
	IN() antlr.TerminalNode
	IS() antlr.TerminalNode
	NOT() antlr.TerminalNode
	OR() antlr.TerminalNode
	STARTS() antlr.TerminalNode
	XOR() antlr.TerminalNode
	FALSE() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	NULL_W() antlr.TerminalNode
	CONSTRAINT() antlr.TerminalNode
	DO() antlr.TerminalNode
	FOR() antlr.TerminalNode
	REQUIRE() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	CASE() antlr.TerminalNode
	WHEN() antlr.TerminalNode
	THEN() antlr.TerminalNode
	ELSE() antlr.TerminalNode
	END() antlr.TerminalNode
	MANDATORY() antlr.TerminalNode
	SCALAR() antlr.TerminalNode
	OF() antlr.TerminalNode
	ADD() antlr.TerminalNode
	DROP() antlr.TerminalNode

	// IsReservedWordContext differentiates from other interfaces.
	IsReservedWordContext()
}

type ReservedWordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReservedWordContext() *ReservedWordContext {
	var p = new(ReservedWordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_reservedWord
	return p
}

func InitEmptyReservedWordContext(p *ReservedWordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CypherParserRULE_reservedWord
}

func (*ReservedWordContext) IsReservedWordContext() {}

func NewReservedWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReservedWordContext {
	var p = new(ReservedWordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_reservedWord

	return p
}

func (s *ReservedWordContext) GetParser() antlr.Parser { return s.parser }

func (s *ReservedWordContext) ALL() antlr.TerminalNode {
	return s.GetToken(CypherParserALL, 0)
}

func (s *ReservedWordContext) ASC() antlr.TerminalNode {
	return s.GetToken(CypherParserASC, 0)
}

func (s *ReservedWordContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(CypherParserASCENDING, 0)
}

func (s *ReservedWordContext) BY() antlr.TerminalNode {
	return s.GetToken(CypherParserBY, 0)
}

func (s *ReservedWordContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *ReservedWordContext) DELETE() antlr.TerminalNode {
	return s.GetToken(CypherParserDELETE, 0)
}

func (s *ReservedWordContext) DESC() antlr.TerminalNode {
	return s.GetToken(CypherParserDESC, 0)
}

func (s *ReservedWordContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(CypherParserDESCENDING, 0)
}

func (s *ReservedWordContext) DETACH() antlr.TerminalNode {
	return s.GetToken(CypherParserDETACH, 0)
}

func (s *ReservedWordContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(CypherParserEXISTS, 0)
}

func (s *ReservedWordContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(CypherParserLIMIT, 0)
}

func (s *ReservedWordContext) MATCH() antlr.TerminalNode {
	return s.GetToken(CypherParserMATCH, 0)
}

func (s *ReservedWordContext) MERGE() antlr.TerminalNode {
	return s.GetToken(CypherParserMERGE, 0)
}

func (s *ReservedWordContext) ON() antlr.TerminalNode {
	return s.GetToken(CypherParserON, 0)
}

func (s *ReservedWordContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(CypherParserOPTIONAL, 0)
}

func (s *ReservedWordContext) ORDER() antlr.TerminalNode {
	return s.GetToken(CypherParserORDER, 0)
}

func (s *ReservedWordContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(CypherParserREMOVE, 0)
}

func (s *ReservedWordContext) RETURN() antlr.TerminalNode {
	return s.GetToken(CypherParserRETURN, 0)
}

func (s *ReservedWordContext) SET() antlr.TerminalNode {
	return s.GetToken(CypherParserSET, 0)
}

func (s *ReservedWordContext) SKIP_W() antlr.TerminalNode {
	return s.GetToken(CypherParserSKIP_W, 0)
}

func (s *ReservedWordContext) WHERE() antlr.TerminalNode {
	return s.GetToken(CypherParserWHERE, 0)
}

func (s *ReservedWordContext) WITH() antlr.TerminalNode {
	return s.GetToken(CypherParserWITH, 0)
}

func (s *ReservedWordContext) UNION() antlr.TerminalNode {
	return s.GetToken(CypherParserUNION, 0)
}

func (s *ReservedWordContext) UNWIND() antlr.TerminalNode {
	return s.GetToken(CypherParserUNWIND, 0)
}

func (s *ReservedWordContext) AND() antlr.TerminalNode {
	return s.GetToken(CypherParserAND, 0)
}

func (s *ReservedWordContext) AS() antlr.TerminalNode {
	return s.GetToken(CypherParserAS, 0)
}

func (s *ReservedWordContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(CypherParserCONTAINS, 0)
}

func (s *ReservedWordContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(CypherParserDISTINCT, 0)
}

func (s *ReservedWordContext) ENDS() antlr.TerminalNode {
	return s.GetToken(CypherParserENDS, 0)
}

func (s *ReservedWordContext) IN() antlr.TerminalNode {
	return s.GetToken(CypherParserIN, 0)
}

func (s *ReservedWordContext) IS() antlr.TerminalNode {
	return s.GetToken(CypherParserIS, 0)
}

func (s *ReservedWordContext) NOT() antlr.TerminalNode {
	return s.GetToken(CypherParserNOT, 0)
}

func (s *ReservedWordContext) OR() antlr.TerminalNode {
	return s.GetToken(CypherParserOR, 0)
}

func (s *ReservedWordContext) STARTS() antlr.TerminalNode {
	return s.GetToken(CypherParserSTARTS, 0)
}

func (s *ReservedWordContext) XOR() antlr.TerminalNode {
	return s.GetToken(CypherParserXOR, 0)
}

func (s *ReservedWordContext) FALSE() antlr.TerminalNode {
	return s.GetToken(CypherParserFALSE, 0)
}

func (s *ReservedWordContext) TRUE() antlr.TerminalNode {
	return s.GetToken(CypherParserTRUE, 0)
}

func (s *ReservedWordContext) NULL_W() antlr.TerminalNode {
	return s.GetToken(CypherParserNULL_W, 0)
}

func (s *ReservedWordContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(CypherParserCONSTRAINT, 0)
}

func (s *ReservedWordContext) DO() antlr.TerminalNode {
	return s.GetToken(CypherParserDO, 0)
}

func (s *ReservedWordContext) FOR() antlr.TerminalNode {
	return s.GetToken(CypherParserFOR, 0)
}

func (s *ReservedWordContext) REQUIRE() antlr.TerminalNode {
	return s.GetToken(CypherParserREQUIRE, 0)
}

func (s *ReservedWordContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(CypherParserUNIQUE, 0)
}

func (s *ReservedWordContext) CASE() antlr.TerminalNode {
	return s.GetToken(CypherParserCASE, 0)
}

func (s *ReservedWordContext) WHEN() antlr.TerminalNode {
	return s.GetToken(CypherParserWHEN, 0)
}

func (s *ReservedWordContext) THEN() antlr.TerminalNode {
	return s.GetToken(CypherParserTHEN, 0)
}

func (s *ReservedWordContext) ELSE() antlr.TerminalNode {
	return s.GetToken(CypherParserELSE, 0)
}

func (s *ReservedWordContext) END() antlr.TerminalNode {
	return s.GetToken(CypherParserEND, 0)
}

func (s *ReservedWordContext) MANDATORY() antlr.TerminalNode {
	return s.GetToken(CypherParserMANDATORY, 0)
}

func (s *ReservedWordContext) SCALAR() antlr.TerminalNode {
	return s.GetToken(CypherParserSCALAR, 0)
}

func (s *ReservedWordContext) OF() antlr.TerminalNode {
	return s.GetToken(CypherParserOF, 0)
}

func (s *ReservedWordContext) ADD() antlr.TerminalNode {
	return s.GetToken(CypherParserADD, 0)
}

func (s *ReservedWordContext) DROP() antlr.TerminalNode {
	return s.GetToken(CypherParserDROP, 0)
}

func (s *ReservedWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReservedWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReservedWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.EnterReservedWord(s)
	}
}

func (s *ReservedWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherParserListener); ok {
		listenerT.ExitReservedWord(s)
	}
}

func (s *ReservedWordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherParserVisitor:
		return t.VisitReservedWord(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ReservedWord() (localctx IReservedWordContext) {
	localctx = NewReservedWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, CypherParserRULE_reservedWord)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(827)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-36)) & ^0x3f) == 0 && ((int64(1)<<(_la-36))&9007199254740991) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
