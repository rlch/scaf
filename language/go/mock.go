package golang

import (
	"bytes"
	"fmt"
	"strings"

	"github.com/rlch/scaf"
)

// TestCase represents a single test case extracted from the scaf AST.
// It contains the inputs (parameters) and expected outputs for matching.
type TestCase struct {
	// Name is the test name from the scaf file.
	Name string

	// Inputs maps parameter name (with $ prefix) to its value.
	Inputs map[string]any

	// Outputs maps field name (e.g., "u.name") to expected value.
	Outputs map[string]any
}

// MockFunc represents a mock function for a query.
type MockFunc struct {
	// Signature is the function signature from the query.
	Signature *FuncSignature

	// TestCases are the test cases for this function.
	TestCases []*TestCase
}

// ExtractTestCases extracts test cases from a QueryScope.
// It walks through all tests (including nested groups) and extracts input/output pairs.
func ExtractTestCases(scope *scaf.QueryScope) []*TestCase {
	var cases []*TestCase

	for _, item := range scope.Items {
		cases = append(cases, extractFromTestOrGroup(item)...)
	}

	return cases
}

// extractFromTestOrGroup recursively extracts test cases from a TestOrGroup.
func extractFromTestOrGroup(item *scaf.TestOrGroup) []*TestCase {
	if item.Test != nil {
		return []*TestCase{extractFromTest(item.Test)}
	}

	if item.Group != nil {
		var cases []*TestCase
		for _, child := range item.Group.Items {
			cases = append(cases, extractFromTestOrGroup(child)...)
		}

		return cases
	}

	return nil
}

// extractFromTest extracts a single TestCase from a Test.
func extractFromTest(test *scaf.Test) *TestCase {
	tc := &TestCase{
		Name:    test.Name,
		Inputs:  make(map[string]any),
		Outputs: make(map[string]any),
	}

	for _, stmt := range test.Statements {
		key := stmt.Key()
		value := stmt.Value.ToGo()

		if strings.HasPrefix(key, "$") {
			// Input parameter - store with $ prefix
			tc.Inputs[key] = value
		} else {
			// Output expectation
			tc.Outputs[key] = value
		}
	}

	return tc
}

// BuildMockFuncs builds MockFunc for each query that has test scopes.
func BuildMockFuncs(suite *scaf.Suite, signatures []*FuncSignature) []*MockFunc {
	// Build a map from query name to signature
	sigMap := make(map[string]*FuncSignature)
	for _, sig := range signatures {
		sigMap[sig.QueryName] = sig
	}

	// Build mock functions from query scopes
	var mocks []*MockFunc

	for _, scope := range suite.Scopes {
		sig, ok := sigMap[scope.QueryName]
		if !ok {
			// No matching query - skip
			continue
		}

		mock := &MockFunc{
			Signature: sig,
			TestCases: ExtractTestCases(scope),
		}

		if len(mock.TestCases) > 0 {
			mocks = append(mocks, mock)
		}
	}

	return mocks
}

// mockGenerator generates the scaf_test.go file content.
type mockGenerator struct {
	ctx          *Context
	buf          *bytes.Buffer
	packageName  string
	needsReflect bool
}

// generateMockFile generates the complete scaf_test.go content.
func (g *generator) generateMockFile(signatures []*FuncSignature) ([]byte, error) {
	if g.ctx.Suite == nil {
		return nil, nil
	}

	mocks := BuildMockFuncs(g.ctx.Suite, signatures)
	if len(mocks) == 0 {
		return nil, nil
	}

	mg := &mockGenerator{
		ctx:         g.ctx,
		buf:         &bytes.Buffer{},
		packageName: g.ctx.PackageName,
	}

	return mg.generate(mocks)
}

func (m *mockGenerator) generate(mocks []*MockFunc) ([]byte, error) {
	// First pass: determine if we need reflect for any complex comparisons
	m.needsReflect = m.needsReflectImport(mocks)

	// Write header
	m.writeHeader()

	// Write init function to swap implementations
	m.writeInit(mocks)

	// Write each mock function
	for i, mock := range mocks {
		isLast := i == len(mocks)-1
		m.writeMockFunc(mock, isLast)
	}

	return m.buf.Bytes(), nil
}

func (m *mockGenerator) needsReflectImport(mocks []*MockFunc) bool {
	for _, mock := range mocks {
		for _, tc := range mock.TestCases {
			for _, v := range tc.Inputs {
				if isComplexType(v) {
					return true
				}
			}
		}
	}

	return false
}

func (m *mockGenerator) writeHeader() {
	m.buf.WriteString("// Code generated by scaf. DO NOT EDIT.\n")
	m.buf.WriteString("//go:build !scaf_prod\n\n")
	fmt.Fprintf(m.buf, "package %s\n\n", m.packageName)

	// Build imports
	var imports []string

	if m.needsReflect {
		imports = append(imports, `"reflect"`)
	}

	if len(imports) > 0 {
		m.buf.WriteString("import (\n")
		for _, imp := range imports {
			fmt.Fprintf(m.buf, "\t%s\n", imp)
		}
		m.buf.WriteString(")\n\n")
	}
}

func (m *mockGenerator) writeInit(mocks []*MockFunc) {
	m.buf.WriteString("func init() {\n")
	for _, mock := range mocks {
		// Convert function name to unexported impl variable name
		implVar := toImplVarName(mock.Signature.Name)
		mockFn := toMockFuncName(mock.Signature.Name)
		fmt.Fprintf(m.buf, "\t%s = %s\n", implVar, mockFn)
	}
	m.buf.WriteString("}\n\n")
}

func (m *mockGenerator) writeMockFunc(mock *MockFunc, isLastFunc bool) {
	sig := mock.Signature

	// Write the mock function
	mockFn := toMockFuncName(sig.Name)
	fmt.Fprintf(m.buf, "func %s(", mockFn)

	// Write parameters
	params := make([]string, len(sig.Params))
	for i, p := range sig.Params {
		params[i] = fmt.Sprintf("%s %s", p.Name, p.Type)
	}
	m.buf.WriteString(strings.Join(params, ", "))
	m.buf.WriteString(")")

	// Write return types
	if len(sig.Returns) > 0 {
		m.buf.WriteString(" ")
		if len(sig.Returns) == 1 {
			m.buf.WriteString(sig.Returns[0].Type)
		} else {
			returns := make([]string, len(sig.Returns))
			for i, r := range sig.Returns {
				returns[i] = r.Type
			}
			fmt.Fprintf(m.buf, "(%s)", strings.Join(returns, ", "))
		}
	}

	m.buf.WriteString(" {\n")

	// Write if-chain for test cases
	for i, tc := range mock.TestCases {
		isFirst := i == 0
		isLast := i == len(mock.TestCases)-1
		m.writeTestCaseMatch(tc, sig, isFirst, isLast)
	}

	// Write default panic for unmatched inputs
	m.buf.WriteString("\tpanic(\"no matching test case\")\n")
	if isLastFunc {
		m.buf.WriteString("}\n")
	} else {
		m.buf.WriteString("}\n\n")
	}
}

func (m *mockGenerator) writeTestCaseMatch(tc *TestCase, sig *FuncSignature, isFirst bool, isLast bool) {
	// Build condition for input matching
	conditions := make([]string, 0, len(tc.Inputs))

	for _, param := range sig.Params {
		inputKey := "$" + param.Name
		inputVal, ok := tc.Inputs[inputKey]

		if !ok {
			continue
		}

		cond := m.buildComparison(param.Name, param.Type, inputVal)
		conditions = append(conditions, cond)
	}

	// Write the if/else if statement
	keyword := "if"
	if !isFirst {
		keyword = "} else if"
	}

	if len(conditions) > 0 {
		fmt.Fprintf(m.buf, "\t%s %s {\n", keyword, strings.Join(conditions, " && "))
	} else {
		// No conditions - always matches (shouldn't happen in practice)
		fmt.Fprintf(m.buf, "\t%s true {\n", keyword)
	}

	// Write return statement
	m.writeReturn(tc, sig)

	// Close the block if this is the last test case
	if isLast {
		m.buf.WriteString("\t}\n")
	}
}

func (m *mockGenerator) buildComparison(paramName, paramType string, value any) string {
	if isComplexType(value) {
		// Use reflect.DeepEqual for complex types
		return fmt.Sprintf("reflect.DeepEqual(%s, %s)", paramName, goLiteral(value))
	}

	// Simple comparison
	return fmt.Sprintf("%s == %s", paramName, goLiteral(value))
}

func (m *mockGenerator) writeReturn(tc *TestCase, sig *FuncSignature) {
	if len(sig.Returns) == 0 {
		m.buf.WriteString("\t\treturn\n")
		return
	}

	// Build return values from outputs
	returnVals := make([]string, len(sig.Returns))

	for i, ret := range sig.Returns {
		// Try to find the output value
		// First try exact match, then try field name only
		if val, ok := tc.Outputs[ret.Name]; ok {
			returnVals[i] = goLiteral(val)
		} else {
			// Try to find by field name with any prefix (e.g., "u.name" -> "name")
			found := false
			for key, val := range tc.Outputs {
				parts := strings.Split(key, ".")
				fieldName := parts[len(parts)-1]

				if fieldName == ret.Name {
					returnVals[i] = goLiteral(val)
					found = true

					break
				}
			}

			if !found {
				// Return zero value
				returnVals[i] = zeroValue(ret.Type)
			}
		}
	}

	fmt.Fprintf(m.buf, "\t\treturn %s\n", strings.Join(returnVals, ", "))
}

// toImplVarName converts a function name to its implementation variable name.
// GetUser -> getUserImpl
func toImplVarName(name string) string {
	if name == "" {
		return ""
	}
	// Lowercase first letter and add Impl suffix
	runes := []rune(name)
	runes[0] = toLower(runes[0])
	return string(runes) + "Impl"
}

// toMockFuncName converts a function name to its mock function name.
// GetUser -> getUserMock
func toMockFuncName(name string) string {
	if name == "" {
		return ""
	}
	// Lowercase first letter and add Mock suffix
	runes := []rune(name)
	runes[0] = toLower(runes[0])
	return string(runes) + "Mock"
}

// toProdFuncName converts a function name to its production function name.
// GetUser -> getUserProd
func toProdFuncName(name string) string {
	if name == "" {
		return ""
	}
	// Lowercase first letter and add Prod suffix
	runes := []rune(name)
	runes[0] = toLower(runes[0])
	return string(runes) + "Prod"
}

func toLower(r rune) rune {
	if r >= 'A' && r <= 'Z' {
		return r + 32
	}
	return r
}

// isComplexType returns true if the value requires reflect.DeepEqual for comparison.
func isComplexType(v any) bool {
	switch v.(type) {
	case map[string]any, []any:
		return true
	default:
		return false
	}
}

// goLiteral converts a Go value to its source code representation.
func goLiteral(v any) string {
	switch val := v.(type) {
	case nil:
		return "nil"
	case string:
		return fmt.Sprintf("%q", val)
	case float64:
		// Check if it's an integer
		if val == float64(int64(val)) {
			return fmt.Sprintf("%d", int64(val))
		}

		return fmt.Sprintf("%v", val)
	case bool:
		return fmt.Sprintf("%t", val)
	case map[string]any:
		return mapLiteral(val)
	case []any:
		return sliceLiteral(val)
	default:
		return fmt.Sprintf("%v", v)
	}
}

func mapLiteral(m map[string]any) string {
	if len(m) == 0 {
		return "map[string]any{}"
	}

	pairs := make([]string, 0, len(m))
	for k, v := range m {
		pairs = append(pairs, fmt.Sprintf("%q: %s", k, goLiteral(v)))
	}

	return fmt.Sprintf("map[string]any{%s}", strings.Join(pairs, ", "))
}

func sliceLiteral(s []any) string {
	if len(s) == 0 {
		return "[]any{}"
	}

	elems := make([]string, len(s))
	for i, v := range s {
		elems[i] = goLiteral(v)
	}

	return fmt.Sprintf("[]any{%s}", strings.Join(elems, ", "))
}

// zeroValue returns the zero value literal for a Go type.
func zeroValue(typ string) string {
	switch typ {
	case "string":
		return `""`
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64":
		return "0"
	case "bool":
		return "false"
	case "any":
		return "nil"
	default:
		// Pointer, slice, map, interface types
		if strings.HasPrefix(typ, "*") ||
			strings.HasPrefix(typ, "[]") ||
			strings.HasPrefix(typ, "map[") {
			return "nil"
		}
		// Struct types - use empty literal
		return typ + "{}"
	}
}
