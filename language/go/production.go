package golang

import (
	"bytes"
	"fmt"
	"strings"
)

// productionGenerator generates the scaf.go file content.
type productionGenerator struct {
	ctx         *Context
	buf         *bytes.Buffer
	packageName string
	signatures  []*FuncSignature
}

// generateProductionFile generates the complete scaf.go content.
func (g *generator) generateProductionFile(signatures []*FuncSignature) ([]byte, error) {
	if g.ctx.Suite == nil || len(signatures) == 0 {
		return nil, nil
	}

	pg := &productionGenerator{
		ctx:         g.ctx,
		buf:         &bytes.Buffer{},
		packageName: g.ctx.PackageName,
		signatures:  signatures,
	}

	return pg.generate()
}

func (p *productionGenerator) generate() ([]byte, error) {
	// Write header
	p.writeHeader()

	// Write each function: public func -> impl var -> prod impl
	for i, sig := range p.signatures {
		isLast := i == len(p.signatures)-1
		if err := p.writeFunction(sig, isLast); err != nil {
			return nil, err
		}
	}

	return p.buf.Bytes(), nil
}

func (p *productionGenerator) writeHeader() {
	p.buf.WriteString("// Code generated by scaf. DO NOT EDIT.\n\n")
	fmt.Fprintf(p.buf, "package %s\n\n", p.packageName)

	// Collect imports from binding
	var imports []string
	if p.ctx.Binding != nil {
		imports = append(imports, p.ctx.Binding.Imports()...)
	}

	if len(imports) > 0 {
		p.buf.WriteString("import (\n")
		for _, imp := range imports {
			fmt.Fprintf(p.buf, "\t%q\n", imp)
		}
		p.buf.WriteString(")\n\n")
	}
}

func (p *productionGenerator) writeFunction(sig *FuncSignature, isLast bool) error {
	// Assemble full signature from:
	// - Binding's prepend params (e.g., ctx context.Context)
	// - Query params (e.g., userId string)
	// - Query returns (e.g., name string)
	// - Binding's error return
	fullSig := p.assembleSignature(sig)

	implVar := toImplVarName(sig.Name)
	prodFn := toProdFuncName(sig.Name)

	// Build function type string for the impl variable
	funcType := p.buildFuncType(fullSig)

	// 1. Write the public function that delegates to impl var
	p.writePublicFunc(fullSig, implVar)

	// 2. Write the impl variable initialized to prod function
	fmt.Fprintf(p.buf, "var %s %s = %s\n\n", implVar, funcType, prodFn)

	// 3. Write the prod function with actual implementation
	if err := p.writeProdFunc(sig, fullSig, prodFn, isLast); err != nil {
		return err
	}

	return nil
}

// assembleSignature builds the full function signature from binding config and query analysis.
func (p *productionGenerator) assembleSignature(sig *FuncSignature) *BindingSignature {
	fullSig := &BindingSignature{
		Name:         sig.Name,
		ReturnsSlice: false,
		ReturnsError: false,
	}

	// 1. Start with binding's prepend params (e.g., ctx context.Context)
	if p.ctx.Binding != nil {
		fullSig.Params = append(fullSig.Params, p.ctx.Binding.PrependParams()...)
	}

	// 2. Add query params (e.g., userId string)
	for _, param := range sig.Params {
		fullSig.Params = append(fullSig.Params, BindingParam{
			Name: param.Name,
			Type: param.Type,
		})
	}

	// 3. Add query returns (e.g., name string)
	for _, r := range sig.Returns {
		fullSig.Returns = append(fullSig.Returns, BindingReturn{
			Name:       r.Name,
			ColumnName: r.ColumnName,
			Type:       r.Type,
		})
	}

	// 4. Set error return from binding
	if p.ctx.Binding != nil {
		fullSig.ReturnsError = p.ctx.Binding.ReturnsError()
	}

	return fullSig
}

func (p *productionGenerator) buildFuncType(sig *BindingSignature) string {
	var sb strings.Builder
	sb.WriteString("func(")

	// Parameters
	params := make([]string, len(sig.Params))
	for i, param := range sig.Params {
		params[i] = param.Type
	}
	sb.WriteString(strings.Join(params, ", "))
	sb.WriteString(")")

	// Returns (including error if ReturnsError)
	returns := p.buildReturnTypes(sig)
	if len(returns) > 0 {
		sb.WriteString(" ")
		if len(returns) == 1 {
			sb.WriteString(returns[0])
		} else {
			sb.WriteString("(")
			sb.WriteString(strings.Join(returns, ", "))
			sb.WriteString(")")
		}
	}

	return sb.String()
}

func (p *productionGenerator) buildReturnTypes(sig *BindingSignature) []string {
	returns := make([]string, 0, len(sig.Returns)+1)
	for _, r := range sig.Returns {
		returns = append(returns, r.Type)
	}
	if sig.ReturnsError {
		returns = append(returns, "error")
	}
	return returns
}

func (p *productionGenerator) writePublicFunc(sig *BindingSignature, implVar string) {
	// func (q *Queries) GetUser(ctx context.Context, userId int) (string, error) {
	//     return getUserImpl(ctx, userId)
	// }

	// Receiver if binding specifies one
	if p.ctx.Binding != nil {
		if recvType := p.ctx.Binding.ReceiverType(); recvType != "" {
			recvName := strings.ToLower(string(strings.TrimPrefix(recvType, "*")[0]))
			fmt.Fprintf(p.buf, "func (%s %s) %s(", recvName, recvType, sig.Name)
		} else {
			fmt.Fprintf(p.buf, "func %s(", sig.Name)
		}
	} else {
		fmt.Fprintf(p.buf, "func %s(", sig.Name)
	}

	// Parameters with names
	params := make([]string, len(sig.Params))
	for i, param := range sig.Params {
		params[i] = fmt.Sprintf("%s %s", param.Name, param.Type)
	}
	p.buf.WriteString(strings.Join(params, ", "))
	p.buf.WriteString(")")

	// Returns
	returns := p.buildReturnTypes(sig)
	if len(returns) > 0 {
		p.buf.WriteString(" ")
		if len(returns) == 1 {
			p.buf.WriteString(returns[0])
		} else {
			fmt.Fprintf(p.buf, "(%s)", strings.Join(returns, ", "))
		}
	}

	p.buf.WriteString(" {\n")

	// Delegate to impl var
	if len(returns) > 0 {
		p.buf.WriteString("\treturn ")
	} else {
		p.buf.WriteString("\t")
	}
	fmt.Fprintf(p.buf, "%s(", implVar)

	// Pass parameters
	paramNames := make([]string, len(sig.Params))
	for i, param := range sig.Params {
		paramNames[i] = param.Name
	}
	p.buf.WriteString(strings.Join(paramNames, ", "))
	p.buf.WriteString(")\n}\n\n")
}

func (p *productionGenerator) writeProdFunc(baseSig *FuncSignature, fullSig *BindingSignature, prodFn string, isLast bool) error {
	// func getUserProd(ctx context.Context, userId int) (string, error) {
	//     <binding-generated body>
	// }
	fmt.Fprintf(p.buf, "func %s(", prodFn)

	// Parameters with names
	params := make([]string, len(fullSig.Params))
	for i, param := range fullSig.Params {
		params[i] = fmt.Sprintf("%s %s", param.Name, param.Type)
	}
	p.buf.WriteString(strings.Join(params, ", "))
	p.buf.WriteString(")")

	// Returns
	returns := p.buildReturnTypes(fullSig)
	if len(returns) > 0 {
		p.buf.WriteString(" ")
		if len(returns) == 1 {
			p.buf.WriteString(returns[0])
		} else {
			fmt.Fprintf(p.buf, "(%s)", strings.Join(returns, ", "))
		}
	}

	p.buf.WriteString(" {\n")

	// Generate body using binding or placeholder
	if p.ctx.Binding != nil {
		// Get receiver name for the body context
		var recvName string
		if recvType := p.ctx.Binding.ReceiverType(); recvType != "" {
			recvName = strings.ToLower(string(strings.TrimPrefix(recvType, "*")[0]))
		}

		// Build query params (from query analysis, not binding-added params)
		queryParams := make([]BindingParam, len(baseSig.Params))
		for i, p := range baseSig.Params {
			queryParams[i] = BindingParam{Name: p.Name, Type: p.Type}
		}

		bodyCtx := &BodyContext{
			Query:        baseSig.Query,
			Signature:    fullSig,
			QueryParams:  queryParams,
			Schema:       p.ctx.Schema,
			ReceiverName: recvName,
			ReceiverType: p.ctx.Binding.ReceiverType(),
		}

		body, err := p.ctx.Binding.GenerateBody(bodyCtx)
		if err != nil {
			return fmt.Errorf("binding failed to generate body for %s: %w", baseSig.Name, err)
		}

		// Indent the body
		for _, line := range strings.Split(body, "\n") {
			if line != "" {
				fmt.Fprintf(p.buf, "\t%s\n", line)
			}
		}
	} else {
		// No binding - generate panic placeholder
		p.buf.WriteString("\tpanic(\"no binding configured\")\n")
	}

	if isLast {
		p.buf.WriteString("}\n")
	} else {
		p.buf.WriteString("}\n\n")
	}

	return nil
}


