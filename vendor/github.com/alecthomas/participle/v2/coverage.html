
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>railroad: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/alecthomas/participle/v2/cmd/railroad/main.go (0.0%)</option>
				
				<option value="file1">github.com/alecthomas/participle/v2/context.go (96.7%)</option>
				
				<option value="file2">github.com/alecthomas/participle/v2/ebnf.go (96.1%)</option>
				
				<option value="file3">github.com/alecthomas/participle/v2/ebnf/ebnf.go (75.8%)</option>
				
				<option value="file4">github.com/alecthomas/participle/v2/error.go (89.7%)</option>
				
				<option value="file5">github.com/alecthomas/participle/v2/grammar.go (84.5%)</option>
				
				<option value="file6">github.com/alecthomas/participle/v2/lexer/api.go (51.9%)</option>
				
				<option value="file7">github.com/alecthomas/participle/v2/lexer/errors.go (69.2%)</option>
				
				<option value="file8">github.com/alecthomas/participle/v2/lexer/internal/basiclexer.go (0.0%)</option>
				
				<option value="file9">github.com/alecthomas/participle/v2/lexer/peek.go (88.4%)</option>
				
				<option value="file10">github.com/alecthomas/participle/v2/lexer/simple.go (87.5%)</option>
				
				<option value="file11">github.com/alecthomas/participle/v2/lexer/stateful.go (82.7%)</option>
				
				<option value="file12">github.com/alecthomas/participle/v2/lexer/text_scanner.go (84.0%)</option>
				
				<option value="file13">github.com/alecthomas/participle/v2/map.go (88.9%)</option>
				
				<option value="file14">github.com/alecthomas/participle/v2/nodes.go (86.9%)</option>
				
				<option value="file15">github.com/alecthomas/participle/v2/options.go (92.5%)</option>
				
				<option value="file16">github.com/alecthomas/participle/v2/parser.go (78.1%)</option>
				
				<option value="file17">github.com/alecthomas/participle/v2/recovery.go (82.5%)</option>
				
				<option value="file18">github.com/alecthomas/participle/v2/struct.go (87.6%)</option>
				
				<option value="file19">github.com/alecthomas/participle/v2/validate.go (96.4%)</option>
				
				<option value="file20">github.com/alecthomas/participle/v2/visit.go (84.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package main generates Railroad Diagrams from Participle grammar EBNF.
package main

import (
        "embed"
        "flag"
        "fmt"
        "os"

        "github.com/alecthomas/repr"

        "github.com/alecthomas/participle/v2/ebnf"
)

const (
        mergeRefThreshold  = -1
        mergeSizeThreshold = 0
)

type production struct {
        *ebnf.Production
        refs int
        size int
}

// Embed the railroad-diagrams css and js files for later output.
// From here: https://github.com/tabatkins/railroad-diagrams
//
//go:embed assets/*
var assets embed.FS

func generate(productions map[string]*production, n ebnf.Node) (s string) <span class="cov0" title="0">{
        switch n := n.(type) </span>{
        case *ebnf.EBNF:<span class="cov0" title="0">
                s += `&lt;!DOCTYPE html&gt;
&lt;style&gt;
body {
        background-color: hsl(30,20%, 95%);
}
h1 {
        font-family: sans-serif;
        font-size: 1em;
}
&lt;/style&gt;
&lt;!-- From https://github.com/tabatkins/railroad-diagrams --&gt;
&lt;link rel='stylesheet' href='railroad-diagrams.css'&gt;
&lt;script src='railroad-diagrams.js'&gt;&lt;/script&gt;
&lt;body&gt;
`
                for _, p := range n.Productions </span><span class="cov0" title="0">{
                        s += generate(productions, p) + "\n"
                }</span>
                <span class="cov0" title="0">s += "&lt;/body&gt;\n"</span>

        case *ebnf.Production:<span class="cov0" title="0">
                if productions[n.Production].refs &lt;= mergeRefThreshold </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">s += `&lt;h1 id="` + n.Production + `"&gt;` + n.Production + "&lt;/h1&gt;\n"
                s += "&lt;script&gt;\n"
                s += "Diagram("
                s += generate(productions, n.Expression)
                s += ").addTo();\n"
                s += "&lt;/script&gt;\n"</span>

        case *ebnf.Expression:<span class="cov0" title="0">
                s += "Choice(0, "
                for i, a := range n.Alternatives </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                s += ", "
                        }</span>
                        <span class="cov0" title="0">s += generate(productions, a)</span>
                }
                <span class="cov0" title="0">s += ")"</span>

        case *ebnf.SubExpression:<span class="cov0" title="0">
                s += generate(productions, n.Expr)
                if n.Lookahead != ebnf.LookaheadAssertionNone </span><span class="cov0" title="0">{
                        s = fmt.Sprintf(`Group(%s, "?%c")`, s, n.Lookahead)
                }</span>

        case *ebnf.Sequence:<span class="cov0" title="0">
                s += "Sequence("
                for i, t := range n.Terms </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                s += ", "
                        }</span>
                        <span class="cov0" title="0">s += generate(productions, t)</span>
                }
                <span class="cov0" title="0">s += ")"</span>

        case *ebnf.Term:<span class="cov0" title="0">
                switch n.Repetition </span>{
                case "*":<span class="cov0" title="0">
                        s += "ZeroOrMore("</span>
                case "+":<span class="cov0" title="0">
                        s += "OneOrMore("</span>
                case "?":<span class="cov0" title="0">
                        s += "Optional("</span>
                }
                <span class="cov0" title="0">switch </span>{
                case n.Name != "":<span class="cov0" title="0">
                        p := productions[n.Name]
                        if p.refs &gt; mergeRefThreshold </span><span class="cov0" title="0">{
                                s += fmt.Sprintf("NonTerminal(%q, {href:\"#%s\"})", n.Name, n.Name)
                        }</span> else<span class="cov0" title="0"> {
                                s += generate(productions, p.Expression)
                        }</span>

                case n.Group != nil:<span class="cov0" title="0">
                        s += generate(productions, n.Group)</span>

                case n.Literal != "":<span class="cov0" title="0">
                        s += fmt.Sprintf("Terminal(%s)", n.Literal)</span>

                case n.Token != "":<span class="cov0" title="0">
                        s += fmt.Sprintf("NonTerminal(%q)", n.Token)</span>

                default:<span class="cov0" title="0">
                        panic(repr.String(n))</span>

                }
                <span class="cov0" title="0">if n.Repetition != "" </span><span class="cov0" title="0">{
                        s += ")"
                }</span>
                <span class="cov0" title="0">if n.Negation </span><span class="cov0" title="0">{
                        s = fmt.Sprintf(`Group(%s, "~")`, s)
                }</span>

        default:<span class="cov0" title="0">
                panic(repr.String(n))</span>
        }
        <span class="cov0" title="0">return</span>
}

func countProductions(productions map[string]*production, n ebnf.Node) (size int) <span class="cov0" title="0">{
        switch n := n.(type) </span>{
        case *ebnf.EBNF:<span class="cov0" title="0">
                for _, p := range n.Productions </span><span class="cov0" title="0">{
                        productions[p.Production] = &amp;production{Production: p}
                }</span>
                <span class="cov0" title="0">for _, p := range n.Productions </span><span class="cov0" title="0">{
                        countProductions(productions, p)
                }</span>
                <span class="cov0" title="0">for _, p := range n.Productions </span><span class="cov0" title="0">{
                        if productions[p.Production].size &lt;= mergeSizeThreshold </span><span class="cov0" title="0">{
                                productions[p.Production].refs = mergeRefThreshold
                        }</span>
                }
        case *ebnf.Production:<span class="cov0" title="0">
                productions[n.Production].size = countProductions(productions, n.Expression)</span>
        case *ebnf.Expression:<span class="cov0" title="0">
                for _, a := range n.Alternatives </span><span class="cov0" title="0">{
                        size += countProductions(productions, a)
                }</span>
        case *ebnf.SubExpression:<span class="cov0" title="0">
                size += countProductions(productions, n.Expr)</span>
        case *ebnf.Sequence:<span class="cov0" title="0">
                for _, t := range n.Terms </span><span class="cov0" title="0">{
                        size += countProductions(productions, t)
                }</span>
        case *ebnf.Term:<span class="cov0" title="0">
                if n.Name != "" </span><span class="cov0" title="0">{
                        productions[n.Name].refs++
                        size++
                }</span> else<span class="cov0" title="0"> if n.Group != nil </span><span class="cov0" title="0">{
                        size += countProductions(productions, n.Group)
                }</span> else<span class="cov0" title="0"> {
                        size++
                }</span>
        default:<span class="cov0" title="0">
                panic(repr.String(n))</span>
        }
        <span class="cov0" title="0">return</span>
}

func main() <span class="cov0" title="0">{
        fmt.Fprintln(os.Stderr, "Generates railroad diagrams from a Participle EBNF grammar on stdin.")
        fmt.Fprintln(os.Stderr, "  (EBNF is available from .String() on your parser)")
        fmt.Fprintln(os.Stderr, "  (Use control-D to end input)")

        help := flag.Bool("h", false, "output help and quit")
        writeAssets := flag.Bool("w", false, "write css and js files")
        outputFile := flag.String("o", "", "file to write html to")

        flag.Parse()
        if *help </span><span class="cov0" title="0">{

                flag.PrintDefaults()
                os.Exit(0)
        }</span>

        <span class="cov0" title="0">ast, err := ebnf.Parse(os.Stdin)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">productions := map[string]*production{}
        countProductions(productions, ast)
        str := generate(productions, ast)

        if *outputFile != "" </span><span class="cov0" title="0">{
                err := os.WriteFile(*outputFile, []byte(str), 0644) // nolint
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }

                <span class="cov0" title="0">if *writeAssets </span><span class="cov0" title="0">{
                        err := writeAssetFiles()
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                } else<span class="cov0" title="0"> {
                        fmt.Fprintln(os.Stderr, "&gt;&gt;&gt; Copy railroad-diagrams.{css,js} from https://github.com/tabatkins/railroad-diagrams")
                }</span>

                <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "&gt;&gt;&gt; File written: %s\n", *outputFile)</span>
        } else<span class="cov0" title="0"> {
                fmt.Println(str)
                fmt.Fprintln(os.Stderr, "&gt;&gt;&gt; Copy railroad-diagrams.{css,js} from https://github.com/tabatkins/railroad-diagrams")
        }</span>
}

func writeAssetFiles() (err error) <span class="cov0" title="0">{
        files, err := assets.ReadDir("assets")
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for _, f := range files </span><span class="cov0" title="0">{
                fileName := f.Name()
                data, err := assets.ReadFile(fmt.Sprintf("assets/%s", fileName))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err = os.WriteFile(fileName, data, 0644) // nolint
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "&gt;&gt;&gt; File written: %s\n", fileName)</span>
        }

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package participle

import (
        "fmt"
        "io"
        "reflect"
        "strings"

        "github.com/alecthomas/participle/v2/lexer"
)

type contextFieldSet struct {
        tokens     []lexer.Token
        strct      reflect.Value
        field      structLexerField
        fieldValue []reflect.Value
}

// Context for a single parse.
type parseContext struct {
        lexer.PeekingLexer
        depth             int
        trace             io.Writer
        deepestError      error
        deepestErrorDepth int
        lookahead         int
        caseInsensitive   map[lexer.TokenType]bool
        apply             []*contextFieldSet
        allowTrailing     bool

        // Error recovery support
        recovery       *recoveryConfig
        recoveryErrors []error
}

func newParseContext(lex *lexer.PeekingLexer, lookahead int, caseInsensitive map[lexer.TokenType]bool) parseContext <span class="cov8" title="1">{
        return parseContext{
                PeekingLexer:    *lex,
                caseInsensitive: caseInsensitive,
                lookahead:       lookahead,
        }
}</span>

func (p *parseContext) DeepestError(err error) error <span class="cov8" title="1">{
        if p.PeekingLexer.Cursor() &gt;= p.deepestErrorDepth </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if p.deepestError != nil </span><span class="cov8" title="1">{
                return p.deepestError
        }</span>
        <span class="cov0" title="0">return err</span>
}

// Defer adds a function to be applied once a branch has been picked.
func (p *parseContext) Defer(tokens []lexer.Token, strct reflect.Value, field structLexerField, fieldValue []reflect.Value) <span class="cov8" title="1">{
        p.apply = append(p.apply, &amp;contextFieldSet{tokens, strct, field, fieldValue})
}</span>

// Apply deferred functions.
func (p *parseContext) Apply() error <span class="cov8" title="1">{
        for _, apply := range p.apply </span><span class="cov8" title="1">{
                if err := setField(apply.tokens, apply.strct, apply.field, apply.fieldValue); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">p.apply = nil
        return nil</span>
}

// Branch accepts the branch as the correct branch.
func (p *parseContext) Accept(branch *parseContext) <span class="cov8" title="1">{
        p.apply = append(p.apply, branch.apply...)
        p.PeekingLexer = branch.PeekingLexer
        if branch.deepestErrorDepth &gt;= p.deepestErrorDepth </span><span class="cov8" title="1">{
                p.deepestErrorDepth = branch.deepestErrorDepth
                p.deepestError = branch.deepestError
        }</span>
        // Merge recovery errors from the branch
        <span class="cov8" title="1">p.recoveryErrors = append(p.recoveryErrors, branch.recoveryErrors...)</span>
}

// Branch starts a new lookahead branch.
func (p *parseContext) Branch() *parseContext <span class="cov8" title="1">{
        branch := &amp;parseContext{}
        *branch = *p
        branch.apply = nil
        branch.recoveryErrors = nil // Don't share slice with parent
        return branch
}</span>

func (p *parseContext) MaybeUpdateError(err error) <span class="cov8" title="1">{
        if p.PeekingLexer.Cursor() &gt;= p.deepestErrorDepth </span><span class="cov8" title="1">{
                p.deepestError = err
                p.deepestErrorDepth = p.PeekingLexer.Cursor()
        }</span>
}

// Stop returns true if parsing should terminate after the given "branch" failed to match.
//
// Additionally, track the deepest error in the branch - the deeper the error, the more useful it usually is.
// It could already be the deepest error in the branch (only if deeper than current parent context deepest),
// or it could be "err", the latest error on the branch (even if same depth; the lexer holds the position).
func (p *parseContext) Stop(err error, branch *parseContext) bool <span class="cov8" title="1">{
        if branch.deepestErrorDepth &gt; p.deepestErrorDepth </span><span class="cov8" title="1">{
                p.deepestError = branch.deepestError
                p.deepestErrorDepth = branch.deepestErrorDepth
        }</span> else<span class="cov8" title="1"> if branch.PeekingLexer.Cursor() &gt;= p.deepestErrorDepth </span><span class="cov8" title="1">{
                p.deepestError = err
                p.deepestErrorDepth = maxInt(branch.PeekingLexer.Cursor(), branch.deepestErrorDepth)
        }</span>
        <span class="cov8" title="1">if !p.hasInfiniteLookahead() &amp;&amp; branch.PeekingLexer.Cursor() &gt; p.PeekingLexer.Cursor()+p.lookahead </span><span class="cov8" title="1">{
                p.Accept(branch)
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (p *parseContext) hasInfiniteLookahead() bool <span class="cov8" title="1">{ return p.lookahead &lt; 0 }</span>

func (p *parseContext) printTrace(n node) func() <span class="cov8" title="1">{
        if p.trace != nil </span><span class="cov8" title="1">{
                tok := p.PeekingLexer.Peek()
                fmt.Fprintf(p.trace, "%s%q %s\n", strings.Repeat(" ", p.depth*2), tok, n.GoString())
                p.depth += 1
                return func() </span><span class="cov8" title="1">{ p.depth -= 1 }</span>
        }
        <span class="cov8" title="1">return func() </span>{<span class="cov8" title="1">}</span>
}

func maxInt(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

// Recovery support methods

// recoveryEnabled returns true if error recovery is enabled.
func (p *parseContext) recoveryEnabled() bool <span class="cov8" title="1">{
        return p.recovery != nil &amp;&amp; len(p.recovery.strategies) &gt; 0
}</span>

// addRecoveryError records an error that occurred during recovery.
func (p *parseContext) addRecoveryError(err error) <span class="cov8" title="1">{
        p.recoveryErrors = append(p.recoveryErrors, err)
}</span>

// tryRecover attempts to recover from a parse error using configured strategies.
// Returns true if recovery was successful.
func (p *parseContext) tryRecover(err error, parent reflect.Value) (bool, []reflect.Value) <span class="cov8" title="1">{
        if !p.recoveryEnabled() </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        // Check if we've exceeded max errors
        <span class="cov8" title="1">if p.recovery.maxErrors &gt; 0 &amp;&amp; len(p.recoveryErrors) &gt;= p.recovery.maxErrors </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // Try each strategy in order
        <span class="cov8" title="1">for _, strategy := range p.recovery.strategies </span><span class="cov8" title="1">{
                checkpoint := p.PeekingLexer.MakeCheckpoint()
                recovered, values, newErr := strategy.Recover(p, err, parent)
                if recovered </span><span class="cov8" title="1">{
                        p.addRecoveryError(newErr)
                        return true, values
                }</span>
                // Restore checkpoint if strategy failed
                <span class="cov8" title="1">p.PeekingLexer.LoadCheckpoint(checkpoint)</span>
        }

        <span class="cov8" title="1">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package participle

import (
        "fmt"
        "strings"
)

// String returns the EBNF for the grammar.
//
// Productions are always upper cased. Lexer tokens are always lower case.
func (p *Parser[G]) String() string <span class="cov8" title="1">{
        return ebnf(p.typeNodes[p.rootType])
}</span>

type ebnfp struct {
        name string
        out  string
}

func ebnf(n node) string <span class="cov8" title="1">{
        outp := []*ebnfp{}
        switch n.(type) </span>{
        case *strct:<span class="cov8" title="1">
                buildEBNF(true, n, map[node]bool{}, nil, &amp;outp)
                out := []string{}
                for _, p := range outp </span><span class="cov8" title="1">{
                        out = append(out, fmt.Sprintf("%s = %s .", p.name, p.out))
                }</span>
                <span class="cov8" title="1">return strings.Join(out, "\n")</span>

        default:<span class="cov8" title="1">
                out := &amp;ebnfp{}
                buildEBNF(true, n, map[node]bool{}, out, &amp;outp)
                return out.out</span>
        }
}

func buildEBNF(root bool, n node, seen map[node]bool, p *ebnfp, outp *[]*ebnfp) <span class="cov8" title="1">{
        switch n := n.(type) </span>{
        case *disjunction:<span class="cov8" title="1">
                if !root </span><span class="cov8" title="1">{
                        p.out += "("
                }</span>
                <span class="cov8" title="1">for i, next := range n.nodes </span><span class="cov8" title="1">{
                        if i &gt; 0 </span><span class="cov8" title="1">{
                                p.out += " | "
                        }</span>
                        <span class="cov8" title="1">buildEBNF(false, next, seen, p, outp)</span>
                }
                <span class="cov8" title="1">if !root </span><span class="cov8" title="1">{
                        p.out += ")"
                }</span>

        case *union:<span class="cov8" title="1">
                name := strings.ToUpper(n.typ.Name()[:1]) + n.typ.Name()[1:]
                if p != nil </span><span class="cov8" title="1">{
                        p.out += name
                }</span>
                <span class="cov8" title="1">if seen[n] </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">p = &amp;ebnfp{name: name}
                *outp = append(*outp, p)
                seen[n] = true
                for i, next := range n.disjunction.nodes </span><span class="cov8" title="1">{
                        if i &gt; 0 </span><span class="cov8" title="1">{
                                p.out += " | "
                        }</span>
                        <span class="cov8" title="1">buildEBNF(false, next, seen, p, outp)</span>
                }

        case *custom:<span class="cov8" title="1">
                name := strings.ToUpper(n.typ.Name()[:1]) + n.typ.Name()[1:]
                p.out += name</span>

        case *strct:<span class="cov8" title="1">
                name := strings.ToUpper(n.typ.Name()[:1]) + n.typ.Name()[1:]
                if p != nil </span><span class="cov8" title="1">{
                        p.out += name
                }</span>
                <span class="cov8" title="1">if seen[n] </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">seen[n] = true
                p = &amp;ebnfp{name: name}
                *outp = append(*outp, p)
                buildEBNF(true, n.expr, seen, p, outp)</span>

        case *sequence:<span class="cov8" title="1">
                group := n.next != nil &amp;&amp; !root
                if group </span><span class="cov8" title="1">{
                        p.out += "("
                }</span>
                <span class="cov8" title="1">for n != nil </span><span class="cov8" title="1">{
                        buildEBNF(false, n.node, seen, p, outp)
                        n = n.next
                        if n != nil </span><span class="cov8" title="1">{
                                p.out += " "
                        }</span>
                }
                <span class="cov8" title="1">if group </span><span class="cov8" title="1">{
                        p.out += ")"
                }</span>

        case *parseable:<span class="cov0" title="0">
                p.out += n.t.Name()</span>

        case *capture:<span class="cov8" title="1">
                buildEBNF(false, n.node, seen, p, outp)</span>

        case *reference:<span class="cov8" title="1">
                p.out += "&lt;" + strings.ToLower(n.identifier) + "&gt;"</span>

        case *negation:<span class="cov8" title="1">
                p.out += "~"
                buildEBNF(false, n.node, seen, p, outp)</span>

        case *literal:<span class="cov8" title="1">
                p.out += fmt.Sprintf("%q", n.s)</span>

        case *group:<span class="cov8" title="1">
                if child, ok := n.expr.(*group); ok &amp;&amp; child.mode == groupMatchOnce </span><span class="cov8" title="1">{
                        buildEBNF(false, child.expr, seen, p, outp)
                }</span> else<span class="cov8" title="1"> if child, ok := n.expr.(*capture); ok </span><span class="cov8" title="1">{
                        if grandchild, ok := child.node.(*group); ok &amp;&amp; grandchild.mode == groupMatchOnce </span><span class="cov0" title="0">{
                                buildEBNF(false, grandchild.expr, seen, p, outp)
                        }</span> else<span class="cov8" title="1"> {
                                buildEBNF(false, n.expr, seen, p, outp)
                        }</span>
                } else<span class="cov8" title="1"> {
                        buildEBNF(false, n.expr, seen, p, outp)
                }</span>
                <span class="cov8" title="1">switch n.mode </span>{
                case groupMatchNonEmpty:<span class="cov8" title="1">
                        p.out += "!"</span>
                case groupMatchZeroOrOne:<span class="cov8" title="1">
                        p.out += "?"</span>
                case groupMatchZeroOrMore:<span class="cov8" title="1">
                        p.out += "*"</span>
                case groupMatchOneOrMore:<span class="cov8" title="1">
                        p.out += "+"</span>
                case groupMatchOnce:<span class="cov8" title="1"></span>
                }

        case *lookaheadGroup:<span class="cov8" title="1">
                if !n.negative </span><span class="cov8" title="1">{
                        p.out += "(?= "
                }</span> else<span class="cov8" title="1"> {
                        p.out += "(?! "
                }</span>
                <span class="cov8" title="1">buildEBNF(true, n.expr, seen, p, outp)
                p.out += ")"</span>

        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("unsupported node type %T", n))</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package ebnf contains the AST and parser for parsing the form of EBNF produced by Participle.
//
// The self-referential EBNF is:
//
//        EBNF = Production* .
//        Production = &lt;ident&gt; "=" Expression "." .
//        Expression = Sequence ("|" Sequence)* .
//        SubExpression = "(" ("?!" | "?=")? Expression ")" .
//        Sequence = Term+ .
//        Term = "~"? (&lt;ident&gt; | &lt;string&gt; | ("&lt;" &lt;ident&gt; "&gt;") | SubExpression) ("*" | "+" | "?" | "!")? .
package ebnf

import (
        "fmt"
        "io"

        "github.com/alecthomas/participle/v2"
)

var parser = participle.MustBuild[EBNF]()

// A Node in the EBNF grammar.
type Node interface {
        sealed()
}

var _ Node = &amp;Term{}

// Term in the EBNF grammar.
type Term struct {
        Negation bool `@("~")?`

        Name    string         `(   @Ident`
        Literal string         `  | @String`
        Token   string         `  | "&lt;" @Ident "&gt;"`
        Group   *SubExpression `  | @@ )`

        Repetition string `@("*" | "+" | "?" | "!")?`
}

func (t *Term) sealed() {<span class="cov0" title="0">}</span>

func (t *Term) String() string <span class="cov8" title="1">{
        switch </span>{
        case t.Name != "":<span class="cov8" title="1">
                return t.Name + t.Repetition</span>
        case t.Literal != "":<span class="cov8" title="1">
                return t.Literal + t.Repetition</span>
        case t.Token != "":<span class="cov8" title="1">
                return "&lt;" + t.Token + "&gt;" + t.Repetition</span>
        case t.Group != nil:<span class="cov8" title="1">
                return t.Group.String() + t.Repetition</span>
        default:<span class="cov0" title="0">
                panic("??")</span>
        }
}

// LookaheadAssertion enum.
type LookaheadAssertion rune

func (l *LookaheadAssertion) sealed() {<span class="cov0" title="0">}</span>

func (l *LookaheadAssertion) Capture(tokens []string) error <span class="cov0" title="0">{ // nolint
        rn := tokens[0][0]
        switch rn </span>{
        case '!', '=':<span class="cov0" title="0">
                *l = LookaheadAssertion(rn)</span>

        default:<span class="cov0" title="0">
                panic(rn)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Lookahead assertion enums.
const (
        LookaheadAssertionNone     LookaheadAssertion = 0
        LookaheadAssertionNegative LookaheadAssertion = '!'
        LookaheadAssertionPositive LookaheadAssertion = '='
)

var _ Node = &amp;SubExpression{}

// SubExpression is an expression inside parentheses ( ... )
type SubExpression struct {
        Lookahead LookaheadAssertion `"(" ("?" @("!" | "="))?`
        Expr      *Expression        `@@ ")"`
}

func (s *SubExpression) sealed() {<span class="cov0" title="0">}</span>

func (s *SubExpression) String() string <span class="cov8" title="1">{
        out := "("
        if s.Lookahead != LookaheadAssertionNone </span><span class="cov0" title="0">{
                out += "?" + string(s.Lookahead)
        }</span>
        <span class="cov8" title="1">out += s.Expr.String() + ")"
        return out</span>
}

var _ Node = &amp;Sequence{}

// A Sequence of terms.
type Sequence struct {
        Terms []*Term `@@+`
}

func (s *Sequence) sealed() {<span class="cov0" title="0">}</span>

func (s *Sequence) String() (out string) <span class="cov8" title="1">{
        for i, term := range s.Terms </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        out += " "
                }</span>
                <span class="cov8" title="1">out += term.String()</span>
        }
        <span class="cov8" title="1">return</span>
}

var _ Node = &amp;Expression{}

// Expression is a set of alternatives separated by "|" in the EBNF.
type Expression struct {
        Alternatives []*Sequence `@@ ( "|" @@ )*`
}

func (e *Expression) sealed() {<span class="cov0" title="0">}</span>

func (e *Expression) String() (out string) <span class="cov8" title="1">{
        for i, seq := range e.Alternatives </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        out += " | "
                }</span>
                <span class="cov8" title="1">out += seq.String()</span>
        }
        <span class="cov8" title="1">return</span>
}

var _ Node = &amp;Production{}

// Production of the grammar.
type Production struct {
        Production string      `@Ident "="`
        Expression *Expression `@@ "."`
}

func (p *Production) sealed() {<span class="cov0" title="0">}</span>

var _ Node = &amp;EBNF{}

// EBNF itself.
type EBNF struct {
        Productions []*Production `@@*`
}

func (e *EBNF) sealed() {<span class="cov0" title="0">}</span>

func (e *EBNF) String() (out string) <span class="cov8" title="1">{
        for i, production := range e.Productions </span><span class="cov8" title="1">{
                out += fmt.Sprintf("%s = %s .", production.Production, production.Expression)
                if i &lt; len(e.Productions)-1 </span><span class="cov8" title="1">{
                        out += "\n"
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// ParseString string into EBNF.
func ParseString(ebnf string) (*EBNF, error) <span class="cov8" title="1">{
        return parser.ParseString("", ebnf)
}</span>

// Parse io.Reader into EBNF.
func Parse(r io.Reader) (*EBNF, error) <span class="cov0" title="0">{
        return parser.Parse("", r)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package participle

import (
        "fmt"

        "github.com/alecthomas/participle/v2/lexer"
)

// Error represents an error while parsing.
//
// The format of an Error is in the form "[&lt;filename&gt;:][&lt;line&gt;:&lt;pos&gt;:] &lt;message&gt;".
//
// The error will contain positional information if available.
type Error interface {
        error
        // Unadorned message.
        Message() string
        // Closest position to error location.
        Position() lexer.Position
}

// FormatError formats an error in the form "[&lt;filename&gt;:][&lt;line&gt;:&lt;pos&gt;:] &lt;message&gt;"
func FormatError(err Error) string <span class="cov8" title="1">{
        msg := ""
        pos := err.Position()
        if pos.Filename != "" </span><span class="cov8" title="1">{
                msg += pos.Filename + ":"
        }</span>
        <span class="cov8" title="1">if pos.Line != 0 || pos.Column != 0 </span><span class="cov8" title="1">{
                msg += fmt.Sprintf("%d:%d:", pos.Line, pos.Column)
        }</span>
        <span class="cov8" title="1">if msg != "" </span><span class="cov8" title="1">{
                msg += " " + err.Message()
        }</span> else<span class="cov8" title="1"> {
                msg = err.Message()
        }</span>
        <span class="cov8" title="1">return msg</span>
}

// UnexpectedTokenError is returned by Parse when an unexpected token is encountered.
//
// This is useful for composing parsers in order to detect when a sub-parser has terminated.
type UnexpectedTokenError struct {
        Unexpected lexer.Token
        Expect     string
        expectNode node // Usable instead of Expect, delays creating the string representation until necessary
}

func (u *UnexpectedTokenError) Error() string <span class="cov8" title="1">{ return FormatError(u) }</span>

func (u *UnexpectedTokenError) Message() string <span class="cov8" title="1">{ // nolint: golint
        var expected string
        if u.expectNode != nil </span><span class="cov8" title="1">{
                expected = fmt.Sprintf(" (expected %s)", u.expectNode)
        }</span> else<span class="cov8" title="1"> if u.Expect != "" </span><span class="cov0" title="0">{
                expected = fmt.Sprintf(" (expected %s)", u.Expect)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("unexpected token %q%s", u.Unexpected, expected)</span>
}
func (u *UnexpectedTokenError) Position() lexer.Position <span class="cov8" title="1">{ return u.Unexpected.Pos }</span> // nolint: golint

// ParseError is returned when a parse error occurs.
//
// It is useful for differentiating between parse errors and other errors such
// as lexing and IO errors.
type ParseError struct {
        Msg string
        Pos lexer.Position
}

func (p *ParseError) Error() string            <span class="cov8" title="1">{ return FormatError(p) }</span>
func (p *ParseError) Message() string          <span class="cov8" title="1">{ return p.Msg }</span>
func (p *ParseError) Position() lexer.Position <span class="cov8" title="1">{ return p.Pos }</span>

// Errorf creates a new Error at the given position.
func Errorf(pos lexer.Position, format string, args ...interface{}) Error <span class="cov8" title="1">{
        return &amp;ParseError{Msg: fmt.Sprintf(format, args...), Pos: pos}
}</span>

type wrappingParseError struct {
        err error
        ParseError
}

func (w *wrappingParseError) Unwrap() error <span class="cov8" title="1">{ return w.err }</span>

// Wrapf attempts to wrap an existing error in a new message.
//
// If "err" is a participle.Error, its positional information will be used and
// "pos" will be ignored.
//
// The returned error implements the Unwrap() method supported by the errors package.
func Wrapf(pos lexer.Position, err error, format string, args ...interface{}) Error <span class="cov8" title="1">{
        var msg string
        if perr, ok := err.(Error); ok </span><span class="cov0" title="0">{
                pos = perr.Position()
                msg = fmt.Sprintf("%s: %s", fmt.Sprintf(format, args...), perr.Message())
        }</span> else<span class="cov8" title="1"> {
                msg = fmt.Sprintf("%s: %s", fmt.Sprintf(format, args...), err.Error())
        }</span>
        <span class="cov8" title="1">return &amp;wrappingParseError{err: err, ParseError: ParseError{Msg: msg, Pos: pos}}</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package participle

import (
        "fmt"
        "reflect"
        "text/scanner"

        "github.com/alecthomas/participle/v2/lexer"
)

type generatorContext struct {
        lexer.Definition
        typeNodes    map[reflect.Type]node
        symbolsToIDs map[lexer.TokenType]string
}

func newGeneratorContext(lex lexer.Definition) *generatorContext <span class="cov8" title="1">{
        return &amp;generatorContext{
                Definition:   lex,
                typeNodes:    map[reflect.Type]node{},
                symbolsToIDs: lexer.SymbolsByRune(lex),
        }
}</span>

func (g *generatorContext) addUnionDefs(defs []unionDef) error <span class="cov8" title="1">{
        unionNodes := make([]*union, len(defs))
        for i, def := range defs </span><span class="cov8" title="1">{
                if _, exists := g.typeNodes[def.typ]; exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("duplicate definition for interface or union type %s", def.typ)
                }</span>
                <span class="cov8" title="1">unionNode := &amp;union{
                        unionDef:    def,
                        disjunction: disjunction{nodes: make([]node, 0, len(def.members))},
                }
                g.typeNodes[def.typ], unionNodes[i] = unionNode, unionNode</span>
        }
        <span class="cov8" title="1">for i, def := range defs </span><span class="cov8" title="1">{
                unionNode := unionNodes[i]
                for _, memberType := range def.members </span><span class="cov8" title="1">{
                        memberNode, err := g.parseType(memberType)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">unionNode.disjunction.nodes = append(unionNode.disjunction.nodes, memberNode)</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (g *generatorContext) addCustomDefs(defs []customDef) error <span class="cov8" title="1">{
        for _, def := range defs </span><span class="cov8" title="1">{
                if _, exists := g.typeNodes[def.typ]; exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("duplicate definition for interface or union type %s", def.typ)
                }</span>
                <span class="cov8" title="1">g.typeNodes[def.typ] = &amp;custom{typ: def.typ, parseFn: def.parseFn}</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Takes a type and builds a tree of nodes out of it.
func (g *generatorContext) parseType(t reflect.Type) (_ node, returnedError error) <span class="cov8" title="1">{
        t = indirectType(t)
        if n, ok := g.typeNodes[t]; ok </span><span class="cov8" title="1">{
                if s, ok := n.(*strct); ok </span><span class="cov8" title="1">{
                        s.usages++
                }</span>
                <span class="cov8" title="1">return n, nil</span>
        }
        <span class="cov8" title="1">if t.Implements(parseableType) </span><span class="cov0" title="0">{
                return &amp;parseable{t.Elem()}, nil
        }</span>
        <span class="cov8" title="1">if reflect.PtrTo(t).Implements(parseableType) </span><span class="cov8" title="1">{
                return &amp;parseable{t}, nil
        }</span>
        <span class="cov8" title="1">switch t.Kind() </span>{ // nolint: exhaustive
        case reflect.Slice, reflect.Ptr:<span class="cov0" title="0">
                t = indirectType(t.Elem())
                if t.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expected a struct but got %T", t)
                }</span>
                <span class="cov0" title="0">fallthrough</span>

        case reflect.Struct:<span class="cov8" title="1">
                slexer, err := lexStruct(t)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">out := newStrct(t)
                g.typeNodes[t] = out // Ensure we avoid infinite recursion.
                if slexer.NumField() == 0 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("can not parse into empty struct %s", t)
                }</span>
                <span class="cov8" title="1">defer decorate(&amp;returnedError, func() string </span><span class="cov8" title="1">{ return slexer.Field().Name }</span>)
                <span class="cov8" title="1">e, err := g.parseDisjunction(slexer)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if e == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no grammar found in %s", t)
                }</span>
                <span class="cov8" title="1">if token, _ := slexer.Peek(); !token.EOF() </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected input %q", token.Value)
                }</span>
                <span class="cov8" title="1">out.expr = e
                return out, nil</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("%s should be a struct or should implement the Parseable interface", t)</span>
}

func (g *generatorContext) parseDisjunction(slexer *structLexer) (node, error) <span class="cov8" title="1">{
        out := &amp;disjunction{}
        for </span><span class="cov8" title="1">{
                n, err := g.parseSequence(slexer)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if n == nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("alternative expression %d cannot be empty", len(out.nodes)+1)
                }</span>
                <span class="cov8" title="1">out.nodes = append(out.nodes, n)
                if token, _ := slexer.Peek(); token.Type != '|' </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">_, err = slexer.Next() // |
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">if len(out.nodes) == 1 </span><span class="cov8" title="1">{
                return out.nodes[0], nil
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (g *generatorContext) parseSequence(slexer *structLexer) (node, error) <span class="cov8" title="1">{
        head := &amp;sequence{}
        cursor := head
loop:
        for </span><span class="cov8" title="1">{
                if token, err := slexer.Peek(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span> else<span class="cov8" title="1"> if token.Type == lexer.EOF </span><span class="cov8" title="1">{
                        break loop</span>
                }
                <span class="cov8" title="1">term, err := g.parseTerm(slexer, true)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if term == nil </span><span class="cov8" title="1">{
                        break loop</span>
                }
                <span class="cov8" title="1">if cursor.node == nil </span><span class="cov8" title="1">{
                        cursor.head = true
                        cursor.node = term
                }</span> else<span class="cov8" title="1"> {
                        cursor.next = &amp;sequence{node: term}
                        cursor = cursor.next
                }</span>
        }
        <span class="cov8" title="1">if head.node == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">if head.next == nil </span><span class="cov8" title="1">{
                return head.node, nil
        }</span>
        <span class="cov8" title="1">return head, nil</span>
}

func (g *generatorContext) parseTermNoModifiers(slexer *structLexer, allowUnknown bool) (node, error) <span class="cov8" title="1">{
        t, err := slexer.Peek()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">switch t.Type </span>{
        case '@':<span class="cov8" title="1">
                return g.parseCapture(slexer)</span>
        case scanner.String, scanner.RawString, scanner.Char:<span class="cov8" title="1">
                return g.parseLiteral(slexer)</span>
        case '!', '~':<span class="cov8" title="1">
                return g.parseNegation(slexer)</span>
        case '[':<span class="cov8" title="1">
                return g.parseOptional(slexer)</span>
        case '{':<span class="cov8" title="1">
                return g.parseRepetition(slexer)</span>
        case '(':<span class="cov8" title="1">
                // Also handles (? used for lookahead groups
                return g.parseGroup(slexer)</span>
        case scanner.Ident:<span class="cov8" title="1">
                return g.parseReference(slexer)</span>
        case lexer.EOF:<span class="cov0" title="0">
                _, _ = slexer.Next()
                return nil, nil</span>
        default:<span class="cov8" title="1">
                if allowUnknown </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("unexpected token %v", t)</span>
        }
}

func (g *generatorContext) parseTerm(slexer *structLexer, allowUnknown bool) (node, error) <span class="cov8" title="1">{
        out, err := g.parseTermNoModifiers(slexer, allowUnknown)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return g.parseModifier(slexer, out)</span>
}

// Parse modifiers: ?, *, + and/or !
func (g *generatorContext) parseModifier(slexer *structLexer, expr node) (node, error) <span class="cov8" title="1">{
        out := &amp;group{expr: expr}
        t, err := slexer.Peek()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">switch t.Type </span>{
        case '!':<span class="cov8" title="1">
                out.mode = groupMatchNonEmpty</span>
        case '+':<span class="cov8" title="1">
                out.mode = groupMatchOneOrMore</span>
        case '*':<span class="cov8" title="1">
                out.mode = groupMatchZeroOrMore</span>
        case '?':<span class="cov8" title="1">
                out.mode = groupMatchZeroOrOne</span>
        default:<span class="cov8" title="1">
                return expr, nil</span>
        }
        <span class="cov8" title="1">_, _ = slexer.Next()
        return out, nil</span>
}

// @&lt;expression&gt; captures &lt;expression&gt; into the current field.
func (g *generatorContext) parseCapture(slexer *structLexer) (node, error) <span class="cov8" title="1">{
        _, _ = slexer.Next()
        token, err := slexer.Peek()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">field := slexer.Field()
        if token.Type == '@' </span><span class="cov8" title="1">{
                _, _ = slexer.Next()
                n, err := g.parseType(field.Type)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return &amp;capture{field, n}, nil</span>
        }
        <span class="cov8" title="1">ft := indirectType(field.Type)
        if ft.Kind() == reflect.Struct &amp;&amp; ft != tokenType &amp;&amp; ft != tokensType &amp;&amp; !implements(ft, captureType) &amp;&amp; !implements(ft, textUnmarshalerType) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: structs can only be parsed with @@ or by implementing the Capture or encoding.TextUnmarshaler interfaces", ft)
        }</span>
        <span class="cov8" title="1">n, err := g.parseTermNoModifiers(slexer, false)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;capture{field, n}, nil</span>
}

// A reference in the form &lt;identifier&gt; refers to a named token from the lexer.
func (g *generatorContext) parseReference(slexer *structLexer) (node, error) <span class="cov8" title="1">{ // nolint: interfacer
        token, err := slexer.Next()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if token.Type != scanner.Ident </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected identifier but got %q", token)
        }</span>
        <span class="cov8" title="1">typ, ok := g.Symbols()[token.Value]
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("unknown token type %q", token)
        }</span>
        <span class="cov8" title="1">return &amp;reference{typ: typ, identifier: token.Value}, nil</span>
}

// [ &lt;expression&gt; ] optionally matches &lt;expression&gt;.
func (g *generatorContext) parseOptional(slexer *structLexer) (node, error) <span class="cov8" title="1">{
        _, _ = slexer.Next() // [
        disj, err := g.parseDisjunction(slexer)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">n := &amp;group{expr: disj, mode: groupMatchZeroOrOne}
        next, err := slexer.Next()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if next.Type != ']' </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected ] but got %q", next)
        }</span>
        <span class="cov8" title="1">return n, nil</span>
}

// { &lt;expression&gt; } matches 0 or more repititions of &lt;expression&gt;
func (g *generatorContext) parseRepetition(slexer *structLexer) (node, error) <span class="cov8" title="1">{
        _, _ = slexer.Next() // {
        disj, err := g.parseDisjunction(slexer)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">n := &amp;group{expr: disj, mode: groupMatchZeroOrMore}
        next, err := slexer.Next()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if next.Type != '}' </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected } but got %q", next)
        }</span>
        <span class="cov8" title="1">return n, nil</span>
}

// ( &lt;expression&gt; ) groups a sub-expression
func (g *generatorContext) parseGroup(slexer *structLexer) (node, error) <span class="cov8" title="1">{
        _, _ = slexer.Next() // (
        peek, err := slexer.Peek()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if peek.Type == '?' </span><span class="cov8" title="1">{
                return g.subparseLookaheadGroup(slexer) // If there was an error peeking, code below will handle it
        }</span>
        <span class="cov8" title="1">expr, err := g.subparseGroup(slexer)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;group{expr: expr}, nil</span>
}

// (?[!=] &lt;expression&gt; ) requires a grouped sub-expression either matches or doesn't match, without consuming it
func (g *generatorContext) subparseLookaheadGroup(slexer *structLexer) (node, error) <span class="cov8" title="1">{
        _, _ = slexer.Next() // ? - the opening ( was already consumed in parseGroup
        var negative bool
        next, err := slexer.Next()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">switch next.Type </span>{
        case '=':<span class="cov8" title="1">
                negative = false</span>
        case '!':<span class="cov8" title="1">
                negative = true</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("expected = or ! but got %q", next)</span>
        }
        <span class="cov8" title="1">expr, err := g.subparseGroup(slexer)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;lookaheadGroup{expr: expr, negative: negative}, nil</span>
}

// helper parsing &lt;expression&gt; ) to finish parsing groups or lookahead groups
func (g *generatorContext) subparseGroup(slexer *structLexer) (node, error) <span class="cov8" title="1">{
        disj, err := g.parseDisjunction(slexer)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">next, err := slexer.Next() // )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if next.Type != ')' </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("expected ) but got %q", next)
        }</span>
        <span class="cov8" title="1">return disj, nil</span>
}

// A token negation
//
// Accepts both the form !"some-literal" and !SomeNamedToken
func (g *generatorContext) parseNegation(slexer *structLexer) (node, error) <span class="cov8" title="1">{
        _, _ = slexer.Next() // advance the parser since we have '!' right now.
        next, err := g.parseTermNoModifiers(slexer, false)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;negation{next}, nil</span>
}

// A literal string.
//
// Note that for this to match, the tokeniser must be able to produce this string. For example,
// if the tokeniser only produces individual characters but the literal is "hello", or vice versa.
func (g *generatorContext) parseLiteral(lex *structLexer) (node, error) <span class="cov8" title="1">{ // nolint: interfacer
        token, err := lex.Next()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">s := token.Value
        t := lexer.TokenType(-1)
        token, err = lex.Peek()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if token.Type == ':' </span><span class="cov8" title="1">{
                _, _ = lex.Next()
                token, err = lex.Next()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if token.Type != scanner.Ident </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("expected identifier for literal type constraint but got %q", token)
                }</span>
                <span class="cov8" title="1">var ok bool
                t, ok = g.Symbols()[token.Value]
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unknown token type %q in literal type constraint", token)
                }</span>
        }
        <span class="cov8" title="1">return &amp;literal{s: s, t: t, tt: g.symbolsToIDs[t]}, nil</span>
}

func indirectType(t reflect.Type) reflect.Type <span class="cov8" title="1">{
        if t.Kind() == reflect.Ptr || t.Kind() == reflect.Slice </span><span class="cov8" title="1">{
                return indirectType(t.Elem())
        }</span>
        <span class="cov8" title="1">return t</span>
}

func implements(t, i reflect.Type) bool <span class="cov8" title="1">{
        return t.Implements(i) || reflect.PtrTo(t).Implements(i)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package lexer

import (
        "fmt"
        "io"
        "strings"
        "unicode/utf8"
)

type TokenType int

const (
        // EOF represents an end of file.
        EOF TokenType = -(iota + 1)
)

// EOFToken creates a new EOF token at the given position.
func EOFToken(pos Position) Token <span class="cov8" title="1">{
        return Token{Type: EOF, Pos: pos}
}</span>

// Definition is the main entry point for lexing.
type Definition interface {
        // Symbols returns a map of symbolic names to the corresponding pseudo-runes for those symbols.
        // This is the same approach as used by text/scanner. For example, "EOF" might have the rune
        // value of -1, "Ident" might be -2, and so on.
        Symbols() map[string]TokenType
        // Lex an io.Reader.
        Lex(filename string, r io.Reader) (Lexer, error)
}

// StringDefinition is an optional interface lexer Definition's can implement
// to offer a fast path for lexing strings.
type StringDefinition interface {
        LexString(filename string, input string) (Lexer, error)
}

// BytesDefinition is an optional interface lexer Definition's can implement
// to offer a fast path for lexing byte slices.
type BytesDefinition interface {
        LexBytes(filename string, input []byte) (Lexer, error)
}

// A Lexer returns tokens from a source.
type Lexer interface {
        // Next consumes and returns the next token.
        Next() (Token, error)
}

// SymbolsByRune returns a map of lexer symbol names keyed by rune.
func SymbolsByRune(def Definition) map[TokenType]string <span class="cov8" title="1">{
        symbols := def.Symbols()
        out := make(map[TokenType]string, len(symbols))
        for s, r := range symbols </span><span class="cov8" title="1">{
                out[r] = s
        }</span>
        <span class="cov8" title="1">return out</span>
}

// NameOfReader attempts to retrieve the filename of a reader.
func NameOfReader(r interface{}) string <span class="cov0" title="0">{
        if nr, ok := r.(interface{ Name() string }); ok </span><span class="cov0" title="0">{
                return nr.Name()
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Must takes the result of a Definition constructor call and returns the definition, but panics if
// it errors
//
// eg.
//
//        lex = lexer.Must(lexer.Build(`Symbol = "symbol" .`))
func Must(def Definition, err error) Definition <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return def</span>
}

// ConsumeAll reads all tokens from a Lexer.
func ConsumeAll(lexer Lexer) ([]Token, error) <span class="cov8" title="1">{
        tokens := make([]Token, 0, 1024)
        for </span><span class="cov8" title="1">{
                token, err := lexer.Next()
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">tokens = append(tokens, token)
                if token.Type == EOF </span><span class="cov8" title="1">{
                        return tokens, nil
                }</span>
        }
}

// Position of a token.
type Position struct {
        Filename string
        Offset   int
        Line     int
        Column   int
}

// Advance the Position based on the number of characters and newlines in "span".
func (p *Position) Advance(span string) <span class="cov8" title="1">{
        p.Offset += len(span)
        lines := strings.Count(span, "\n")
        p.Line += lines
        // Update column.
        if lines == 0 </span><span class="cov8" title="1">{
                p.Column += utf8.RuneCountInString(span)
        }</span> else<span class="cov8" title="1"> {
                p.Column = utf8.RuneCountInString(span[strings.LastIndex(span, "\n"):])
        }</span>
}

// Add returns a new Position that is the sum of this position and "pos".
//
// This is useful when parsing values from a parent grammar.
func (p Position) Add(pos Position) Position <span class="cov0" title="0">{
        p.Line += pos.Line - 1
        if pos.Line &gt; 1 </span><span class="cov0" title="0">{
                p.Column = pos.Column
        }</span> else<span class="cov0" title="0"> {
                p.Column += pos.Column - 1
        }</span>
        <span class="cov0" title="0">p.Offset += pos.Offset
        return p</span>
}

func (p Position) GoString() string <span class="cov0" title="0">{
        return fmt.Sprintf("Position{Filename: %q, Offset: %d, Line: %d, Column: %d}",
                p.Filename, p.Offset, p.Line, p.Column)
}</span>

func (p Position) String() string <span class="cov8" title="1">{
        filename := p.Filename
        if filename == "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("%d:%d", p.Line, p.Column)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s:%d:%d", filename, p.Line, p.Column)</span>
}

// A Token returned by a Lexer.
type Token struct {
        // Type of token. This is the value keyed by symbol as returned by Definition.Symbols().
        Type  TokenType
        Value string
        Pos   Position
}

// EOF returns true if this Token is an EOF token.
func (t Token) EOF() bool <span class="cov8" title="1">{
        return t.Type == EOF
}</span>

func (t Token) String() string <span class="cov0" title="0">{
        if t.EOF() </span><span class="cov0" title="0">{
                return "&lt;EOF&gt;"
        }</span>
        <span class="cov0" title="0">return t.Value</span>
}

func (t Token) GoString() string <span class="cov8" title="1">{
        if t.Pos == (Position{}) </span><span class="cov8" title="1">{
                return fmt.Sprintf("Token{%d, %q}", t.Type, t.Value)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("Token@%s{%d, %q}", t.Pos.String(), t.Type, t.Value)</span>
}

// MakeSymbolTable builds a lookup table for checking token ID existence.
//
// For each symbolic name in "types", the returned map will contain the corresponding token ID as a key.
func MakeSymbolTable(def Definition, types ...string) (map[TokenType]bool, error) <span class="cov0" title="0">{
        symbols := def.Symbols()
        table := make(map[TokenType]bool, len(types))
        for _, symbol := range types </span><span class="cov0" title="0">{
                rn, ok := symbols[symbol]
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("lexer does not support symbol %q", symbol)
                }</span>
                <span class="cov0" title="0">table[rn] = true</span>
        }
        <span class="cov0" title="0">return table, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package lexer

import "fmt"

// This file exists to break circular imports. The types and functions in here
// mirror those in the participle package.

type errorInterface interface {
        error
        Message() string
        Position() Position
}

// Error represents an error while lexing.
//
// It complies with the participle.Error interface.
type Error struct {
        Msg string
        Pos Position
}

var _ errorInterface = &amp;Error{}

// Creates a new Error at the given position.
func errorf(pos Position, format string, args ...interface{}) *Error <span class="cov8" title="1">{
        return &amp;Error{Msg: fmt.Sprintf(format, args...), Pos: pos}
}</span>

func (e *Error) Message() string    <span class="cov0" title="0">{ return e.Msg }</span> // nolint: golint
func (e *Error) Position() Position <span class="cov0" title="0">{ return e.Pos }</span> // nolint: golint

// Error formats the error with FormatError.
func (e *Error) Error() string <span class="cov8" title="1">{ return formatError(e.Pos, e.Msg) }</span>

// An error in the form "[&lt;filename&gt;:][&lt;line&gt;:&lt;pos&gt;:] &lt;message&gt;"
func formatError(pos Position, message string) string <span class="cov8" title="1">{
        msg := ""
        if pos.Filename != "" </span><span class="cov0" title="0">{
                msg += pos.Filename + ":"
        }</span>
        <span class="cov8" title="1">if pos.Line != 0 || pos.Column != 0 </span><span class="cov8" title="1">{
                msg += fmt.Sprintf("%d:%d:", pos.Line, pos.Column)
        }</span>
        <span class="cov8" title="1">if msg != "" </span><span class="cov8" title="1">{
                msg += " " + message
        }</span> else<span class="cov0" title="0"> {
                msg = message
        }</span>
        <span class="cov8" title="1">return msg</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by Participle. DO NOT EDIT.
package internal

import (
        "fmt"
        "io"
        "regexp/syntax"
        "strings"
        "sync"
        "unicode/utf8"

        "github.com/alecthomas/participle/v2"
        "github.com/alecthomas/participle/v2/lexer"
)

var _ syntax.Op
var _ fmt.State

const _ = utf8.RuneError

var GeneratedBasicBackRefCache sync.Map
var GeneratedBasicLexer lexer.Definition = lexerGeneratedBasicDefinitionImpl{}

type lexerGeneratedBasicDefinitionImpl struct{}

func (lexerGeneratedBasicDefinitionImpl) Symbols() map[string]lexer.TokenType <span class="cov0" title="0">{
        return map[string]lexer.TokenType{
                "Comment":    -7,
                "EOF":        -1,
                "EOL":        -6,
                "Ident":      -4,
                "Number":     -3,
                "Punct":      -5,
                "String":     -2,
                "Whitespace": -8,
        }
}</span>

func (lexerGeneratedBasicDefinitionImpl) LexString(filename string, s string) (lexer.Lexer, error) <span class="cov0" title="0">{
        return &amp;lexerGeneratedBasicImpl{
                s: s,
                pos: lexer.Position{
                        Filename: filename,
                        Line:     1,
                        Column:   1,
                },
                states: []lexerGeneratedBasicState{{name: "Root"}},
        }, nil
}</span>

func (d lexerGeneratedBasicDefinitionImpl) LexBytes(filename string, b []byte) (lexer.Lexer, error) <span class="cov0" title="0">{
        return d.LexString(filename, string(b))
}</span>

func (d lexerGeneratedBasicDefinitionImpl) Lex(filename string, r io.Reader) (lexer.Lexer, error) <span class="cov0" title="0">{
        s := &amp;strings.Builder{}
        _, err := io.Copy(s, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return d.LexString(filename, s.String())</span>
}

type lexerGeneratedBasicState struct {
        name   string
        groups []string
}

type lexerGeneratedBasicImpl struct {
        s      string
        p      int
        pos    lexer.Position
        states []lexerGeneratedBasicState
}

func (l *lexerGeneratedBasicImpl) Next() (lexer.Token, error) <span class="cov0" title="0">{
        if l.p == len(l.s) </span><span class="cov0" title="0">{
                return lexer.EOFToken(l.pos), nil
        }</span>
        <span class="cov0" title="0">var (
                state  = l.states[len(l.states)-1]
                groups []int
                sym    lexer.TokenType
        )
        switch state.name </span>{
        case "Root":<span class="cov0" title="0">
                if match := matchGeneratedBasicString(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 </span><span class="cov0" title="0">{
                        sym = -2
                        groups = match[:]
                }</span> else<span class="cov0" title="0"> if match := matchGeneratedBasicNumber(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 </span><span class="cov0" title="0">{
                        sym = -3
                        groups = match[:]
                }</span> else<span class="cov0" title="0"> if match := matchGeneratedBasicIdent(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 </span><span class="cov0" title="0">{
                        sym = -4
                        groups = match[:]
                }</span> else<span class="cov0" title="0"> if match := matchGeneratedBasicPunct(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 </span><span class="cov0" title="0">{
                        sym = -5
                        groups = match[:]
                }</span> else<span class="cov0" title="0"> if match := matchGeneratedBasicEOL(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 </span><span class="cov0" title="0">{
                        sym = -6
                        groups = match[:]
                }</span> else<span class="cov0" title="0"> if match := matchGeneratedBasicComment(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 </span><span class="cov0" title="0">{
                        sym = -7
                        groups = match[:]
                }</span> else<span class="cov0" title="0"> if match := matchGeneratedBasicWhitespace(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 </span><span class="cov0" title="0">{
                        sym = -8
                        groups = match[:]
                }</span>
        }
        <span class="cov0" title="0">if groups == nil </span><span class="cov0" title="0">{
                sample := []rune(l.s[l.p:])
                if len(sample) &gt; 16 </span><span class="cov0" title="0">{
                        sample = append(sample[:16], []rune("...")...)
                }</span>
                <span class="cov0" title="0">return lexer.Token{}, participle.Errorf(l.pos, "invalid input text %q", string(sample))</span>
        }
        <span class="cov0" title="0">pos := l.pos
        span := l.s[groups[0]:groups[1]]
        l.p = groups[1]
        l.pos.Advance(span)
        return lexer.Token{
                Type:  sym,
                Value: span,
                Pos:   pos,
        }, nil</span>
}

func (l *lexerGeneratedBasicImpl) sgroups(match []int) []string <span class="cov0" title="0">{
        sgroups := make([]string, len(match)/2)
        for i := 0; i &lt; len(match)-1; i += 2 </span><span class="cov0" title="0">{
                sgroups[i/2] = l.s[l.p+match[i] : l.p+match[i+1]]
        }</span>
        <span class="cov0" title="0">return sgroups</span>
}

// "(\\"|[^"])*"
func matchGeneratedBasicString(s string, p int, backrefs []string) (groups [4]int) <span class="cov0" title="0">{
        // " (Literal)
        l0 := func(s string, p int) int </span><span class="cov0" title="0">{
                if p &lt; len(s) &amp;&amp; s[p] == '"' </span><span class="cov0" title="0">{
                        return p + 1
                }</span>
                <span class="cov0" title="0">return -1</span>
        }
        // \\" (Literal)
        <span class="cov0" title="0">l1 := func(s string, p int) int </span><span class="cov0" title="0">{
                if p+2 &lt;= len(s) &amp;&amp; s[p:p+2] == "\\\"" </span><span class="cov0" title="0">{
                        return p + 2
                }</span>
                <span class="cov0" title="0">return -1</span>
        }
        // [^"] (CharClass)
        <span class="cov0" title="0">l2 := func(s string, p int) int </span><span class="cov0" title="0">{
                if len(s) &lt;= p </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">var (
                        rn rune
                        n  int
                )
                if s[p] &lt; utf8.RuneSelf </span><span class="cov0" title="0">{
                        rn, n = rune(s[p]), 1
                }</span> else<span class="cov0" title="0"> {
                        rn, n = utf8.DecodeRuneInString(s[p:])
                }</span>
                <span class="cov0" title="0">switch </span>{
                case rn &gt;= '\x00' &amp;&amp; rn &lt;= '!':<span class="cov0" title="0">
                        return p + 1</span>
                case rn &gt;= '#' &amp;&amp; rn &lt;= '\U0010ffff':<span class="cov0" title="0">
                        return p + n</span>
                }
                <span class="cov0" title="0">return -1</span>
        }
        // \\"|[^"] (Alternate)
        <span class="cov0" title="0">l3 := func(s string, p int) int </span><span class="cov0" title="0">{
                if np := l1(s, p); np != -1 </span><span class="cov0" title="0">{
                        return np
                }</span>
                <span class="cov0" title="0">if np := l2(s, p); np != -1 </span><span class="cov0" title="0">{
                        return np
                }</span>
                <span class="cov0" title="0">return -1</span>
        }
        // (\\"|[^"]) (Capture)
        <span class="cov0" title="0">l4 := func(s string, p int) int </span><span class="cov0" title="0">{
                np := l3(s, p)
                if np != -1 </span><span class="cov0" title="0">{
                        groups[2] = p
                        groups[3] = np
                }</span>
                <span class="cov0" title="0">return np</span>
        }
        // (\\"|[^"])* (Star)
        <span class="cov0" title="0">l5 := func(s string, p int) int </span><span class="cov0" title="0">{
                for len(s) &gt; p </span><span class="cov0" title="0">{
                        if np := l4(s, p); np == -1 </span><span class="cov0" title="0">{
                                return p
                        }</span> else<span class="cov0" title="0"> {
                                p = np
                        }</span>
                }
                <span class="cov0" title="0">return p</span>
        }
        // "(\\"|[^"])*" (Concat)
        <span class="cov0" title="0">l6 := func(s string, p int) int </span><span class="cov0" title="0">{
                if p = l0(s, p); p == -1 </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">if p = l5(s, p); p == -1 </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">if p = l0(s, p); p == -1 </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">return p</span>
        }
        <span class="cov0" title="0">np := l6(s, p)
        if np == -1 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">groups[0] = p
        groups[1] = np
        return</span>
}

// [\+\-]?([0-9]*\.)?[0-9]+
func matchGeneratedBasicNumber(s string, p int, backrefs []string) (groups [4]int) <span class="cov0" title="0">{
        // [\+\-] (CharClass)
        l0 := func(s string, p int) int </span><span class="cov0" title="0">{
                if len(s) &lt;= p </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">rn := s[p]
                if rn == '+' || rn == '-' </span><span class="cov0" title="0">{
                        return p + 1
                }</span>
                <span class="cov0" title="0">return -1</span>
        }
        // [\+\-]? (Quest)
        <span class="cov0" title="0">l1 := func(s string, p int) int </span><span class="cov0" title="0">{
                if np := l0(s, p); np != -1 </span><span class="cov0" title="0">{
                        return np
                }</span>
                <span class="cov0" title="0">return p</span>
        }
        // [0-9] (CharClass)
        <span class="cov0" title="0">l2 := func(s string, p int) int </span><span class="cov0" title="0">{
                if len(s) &lt;= p </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">rn := s[p]
                switch </span>{
                case rn &gt;= '0' &amp;&amp; rn &lt;= '9':<span class="cov0" title="0">
                        return p + 1</span>
                }
                <span class="cov0" title="0">return -1</span>
        }
        // [0-9]* (Star)
        <span class="cov0" title="0">l3 := func(s string, p int) int </span><span class="cov0" title="0">{
                for len(s) &gt; p </span><span class="cov0" title="0">{
                        if np := l2(s, p); np == -1 </span><span class="cov0" title="0">{
                                return p
                        }</span> else<span class="cov0" title="0"> {
                                p = np
                        }</span>
                }
                <span class="cov0" title="0">return p</span>
        }
        // \. (Literal)
        <span class="cov0" title="0">l4 := func(s string, p int) int </span><span class="cov0" title="0">{
                if p &lt; len(s) &amp;&amp; s[p] == '.' </span><span class="cov0" title="0">{
                        return p + 1
                }</span>
                <span class="cov0" title="0">return -1</span>
        }
        // [0-9]*\. (Concat)
        <span class="cov0" title="0">l5 := func(s string, p int) int </span><span class="cov0" title="0">{
                if p = l3(s, p); p == -1 </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">if p = l4(s, p); p == -1 </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">return p</span>
        }
        // ([0-9]*\.) (Capture)
        <span class="cov0" title="0">l6 := func(s string, p int) int </span><span class="cov0" title="0">{
                np := l5(s, p)
                if np != -1 </span><span class="cov0" title="0">{
                        groups[2] = p
                        groups[3] = np
                }</span>
                <span class="cov0" title="0">return np</span>
        }
        // ([0-9]*\.)? (Quest)
        <span class="cov0" title="0">l7 := func(s string, p int) int </span><span class="cov0" title="0">{
                if np := l6(s, p); np != -1 </span><span class="cov0" title="0">{
                        return np
                }</span>
                <span class="cov0" title="0">return p</span>
        }
        // [0-9]+ (Plus)
        <span class="cov0" title="0">l8 := func(s string, p int) int </span><span class="cov0" title="0">{
                if p = l2(s, p); p == -1 </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">for len(s) &gt; p </span><span class="cov0" title="0">{
                        if np := l2(s, p); np == -1 </span><span class="cov0" title="0">{
                                return p
                        }</span> else<span class="cov0" title="0"> {
                                p = np
                        }</span>
                }
                <span class="cov0" title="0">return p</span>
        }
        // [\+\-]?([0-9]*\.)?[0-9]+ (Concat)
        <span class="cov0" title="0">l9 := func(s string, p int) int </span><span class="cov0" title="0">{
                if p = l1(s, p); p == -1 </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">if p = l7(s, p); p == -1 </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">if p = l8(s, p); p == -1 </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">return p</span>
        }
        <span class="cov0" title="0">np := l9(s, p)
        if np == -1 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">groups[0] = p
        groups[1] = np
        return</span>
}

// [A-Z_a-z][0-9A-Z_a-z]*
func matchGeneratedBasicIdent(s string, p int, backrefs []string) (groups [2]int) <span class="cov0" title="0">{
        // [A-Z_a-z] (CharClass)
        l0 := func(s string, p int) int </span><span class="cov0" title="0">{
                if len(s) &lt;= p </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">rn := s[p]
                switch </span>{
                case rn &gt;= 'A' &amp;&amp; rn &lt;= 'Z':<span class="cov0" title="0">
                        return p + 1</span>
                case rn == '_':<span class="cov0" title="0">
                        return p + 1</span>
                case rn &gt;= 'a' &amp;&amp; rn &lt;= 'z':<span class="cov0" title="0">
                        return p + 1</span>
                }
                <span class="cov0" title="0">return -1</span>
        }
        // [0-9A-Z_a-z] (CharClass)
        <span class="cov0" title="0">l1 := func(s string, p int) int </span><span class="cov0" title="0">{
                if len(s) &lt;= p </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">rn := s[p]
                switch </span>{
                case rn &gt;= '0' &amp;&amp; rn &lt;= '9':<span class="cov0" title="0">
                        return p + 1</span>
                case rn &gt;= 'A' &amp;&amp; rn &lt;= 'Z':<span class="cov0" title="0">
                        return p + 1</span>
                case rn == '_':<span class="cov0" title="0">
                        return p + 1</span>
                case rn &gt;= 'a' &amp;&amp; rn &lt;= 'z':<span class="cov0" title="0">
                        return p + 1</span>
                }
                <span class="cov0" title="0">return -1</span>
        }
        // [0-9A-Z_a-z]* (Star)
        <span class="cov0" title="0">l2 := func(s string, p int) int </span><span class="cov0" title="0">{
                for len(s) &gt; p </span><span class="cov0" title="0">{
                        if np := l1(s, p); np == -1 </span><span class="cov0" title="0">{
                                return p
                        }</span> else<span class="cov0" title="0"> {
                                p = np
                        }</span>
                }
                <span class="cov0" title="0">return p</span>
        }
        // [A-Z_a-z][0-9A-Z_a-z]* (Concat)
        <span class="cov0" title="0">l3 := func(s string, p int) int </span><span class="cov0" title="0">{
                if p = l0(s, p); p == -1 </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">if p = l2(s, p); p == -1 </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">return p</span>
        }
        <span class="cov0" title="0">np := l3(s, p)
        if np == -1 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">groups[0] = p
        groups[1] = np
        return</span>
}

// [!-/:-@\[-`\{-~]+
func matchGeneratedBasicPunct(s string, p int, backrefs []string) (groups [2]int) <span class="cov0" title="0">{
        // [!-/:-@\[-`\{-~] (CharClass)
        l0 := func(s string, p int) int </span><span class="cov0" title="0">{
                if len(s) &lt;= p </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">rn := s[p]
                switch </span>{
                case rn &gt;= '!' &amp;&amp; rn &lt;= '/':<span class="cov0" title="0">
                        return p + 1</span>
                case rn &gt;= ':' &amp;&amp; rn &lt;= '@':<span class="cov0" title="0">
                        return p + 1</span>
                case rn &gt;= '[' &amp;&amp; rn &lt;= '`':<span class="cov0" title="0">
                        return p + 1</span>
                case rn &gt;= '{' &amp;&amp; rn &lt;= '~':<span class="cov0" title="0">
                        return p + 1</span>
                }
                <span class="cov0" title="0">return -1</span>
        }
        // [!-/:-@\[-`\{-~]+ (Plus)
        <span class="cov0" title="0">l1 := func(s string, p int) int </span><span class="cov0" title="0">{
                if p = l0(s, p); p == -1 </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">for len(s) &gt; p </span><span class="cov0" title="0">{
                        if np := l0(s, p); np == -1 </span><span class="cov0" title="0">{
                                return p
                        }</span> else<span class="cov0" title="0"> {
                                p = np
                        }</span>
                }
                <span class="cov0" title="0">return p</span>
        }
        <span class="cov0" title="0">np := l1(s, p)
        if np == -1 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">groups[0] = p
        groups[1] = np
        return</span>
}

// \n
func matchGeneratedBasicEOL(s string, p int, backrefs []string) (groups [2]int) <span class="cov0" title="0">{
        if p &lt; len(s) &amp;&amp; s[p] == '\n' </span><span class="cov0" title="0">{
                groups[0] = p
                groups[1] = p + 1
        }</span>
        <span class="cov0" title="0">return</span>
}

// (?i:REM)[^\n]*(?i:\n)
func matchGeneratedBasicComment(s string, p int, backrefs []string) (groups [2]int) <span class="cov0" title="0">{
        // (?i:REM) (Literal)
        l0 := func(s string, p int) int </span><span class="cov0" title="0">{
                if p+3 &lt;= len(s) &amp;&amp; strings.EqualFold(s[p:p+3], "REM") </span><span class="cov0" title="0">{
                        return p + 3
                }</span>
                <span class="cov0" title="0">return -1</span>
        }
        // [^\n] (CharClass)
        <span class="cov0" title="0">l1 := func(s string, p int) int </span><span class="cov0" title="0">{
                if len(s) &lt;= p </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">var (
                        rn rune
                        n  int
                )
                if s[p] &lt; utf8.RuneSelf </span><span class="cov0" title="0">{
                        rn, n = rune(s[p]), 1
                }</span> else<span class="cov0" title="0"> {
                        rn, n = utf8.DecodeRuneInString(s[p:])
                }</span>
                <span class="cov0" title="0">switch </span>{
                case rn &gt;= '\x00' &amp;&amp; rn &lt;= '\t':<span class="cov0" title="0">
                        return p + 1</span>
                case rn &gt;= '\v' &amp;&amp; rn &lt;= '\U0010ffff':<span class="cov0" title="0">
                        return p + n</span>
                }
                <span class="cov0" title="0">return -1</span>
        }
        // [^\n]* (Star)
        <span class="cov0" title="0">l2 := func(s string, p int) int </span><span class="cov0" title="0">{
                for len(s) &gt; p </span><span class="cov0" title="0">{
                        if np := l1(s, p); np == -1 </span><span class="cov0" title="0">{
                                return p
                        }</span> else<span class="cov0" title="0"> {
                                p = np
                        }</span>
                }
                <span class="cov0" title="0">return p</span>
        }
        // (?i:\n) (Literal)
        <span class="cov0" title="0">l3 := func(s string, p int) int </span><span class="cov0" title="0">{
                if p &lt; len(s) &amp;&amp; s[p] == '\n' </span><span class="cov0" title="0">{
                        return p + 1
                }</span>
                <span class="cov0" title="0">return -1</span>
        }
        // (?i:REM)[^\n]*(?i:\n) (Concat)
        <span class="cov0" title="0">l4 := func(s string, p int) int </span><span class="cov0" title="0">{
                if p = l0(s, p); p == -1 </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">if p = l2(s, p); p == -1 </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">if p = l3(s, p); p == -1 </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">return p</span>
        }
        <span class="cov0" title="0">np := l4(s, p)
        if np == -1 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">groups[0] = p
        groups[1] = np
        return</span>
}

// [\t ]+
func matchGeneratedBasicWhitespace(s string, p int, backrefs []string) (groups [2]int) <span class="cov0" title="0">{
        // [\t ] (CharClass)
        l0 := func(s string, p int) int </span><span class="cov0" title="0">{
                if len(s) &lt;= p </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">rn := s[p]
                if rn == '\t' || rn == ' ' </span><span class="cov0" title="0">{
                        return p + 1
                }</span>
                <span class="cov0" title="0">return -1</span>
        }
        // [\t ]+ (Plus)
        <span class="cov0" title="0">l1 := func(s string, p int) int </span><span class="cov0" title="0">{
                if p = l0(s, p); p == -1 </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">for len(s) &gt; p </span><span class="cov0" title="0">{
                        if np := l0(s, p); np == -1 </span><span class="cov0" title="0">{
                                return p
                        }</span> else<span class="cov0" title="0"> {
                                p = np
                        }</span>
                }
                <span class="cov0" title="0">return p</span>
        }
        <span class="cov0" title="0">np := l1(s, p)
        if np == -1 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">groups[0] = p
        groups[1] = np
        return</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package lexer

// PeekingLexer supports arbitrary lookahead as well as cloning.
type PeekingLexer struct {
        Checkpoint
        tokens []Token
        elide  map[TokenType]bool
}

// RawCursor index in the token stream.
type RawCursor int

// Checkpoint wraps the mutable state of the PeekingLexer.
//
// Copying and restoring just this state is a bit faster than copying the entire PeekingLexer.
type Checkpoint struct {
        rawCursor  RawCursor // The raw position of the next possibly elided token
        nextCursor RawCursor // The raw position of the next non-elided token
        cursor     int       // Index of the next non-elided token among other non-elided tokens
}

// Upgrade a Lexer to a PeekingLexer with arbitrary lookahead.
//
// "elide" is a slice of token types to elide from processing.
func Upgrade(lex Lexer, elide ...TokenType) (*PeekingLexer, error) <span class="cov8" title="1">{
        r := &amp;PeekingLexer{
                elide: make(map[TokenType]bool, len(elide)),
        }
        for _, rn := range elide </span><span class="cov8" title="1">{
                r.elide[rn] = true
        }</span>
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                t, err := lex.Next()
                if err != nil </span><span class="cov0" title="0">{
                        return r, err
                }</span>
                <span class="cov8" title="1">r.tokens = append(r.tokens, t)
                if t.EOF() </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">r.advanceToNonElided()
        return r, nil</span>
}

// Range returns the slice of tokens between the two cursor points.
func (p *PeekingLexer) Range(rawStart, rawEnd RawCursor) []Token <span class="cov8" title="1">{
        return p.tokens[rawStart:rawEnd]
}</span>

// Cursor position in tokens, excluding elided tokens.
func (c Checkpoint) Cursor() int <span class="cov0" title="0">{
        return c.cursor
}</span>

// RawCursor position in tokens, including elided tokens.
func (c Checkpoint) RawCursor() RawCursor <span class="cov8" title="1">{
        return c.rawCursor
}</span>

// Next consumes and returns the next token.
func (p *PeekingLexer) Next() *Token <span class="cov8" title="1">{
        t := &amp;p.tokens[p.nextCursor]
        if t.EOF() </span><span class="cov8" title="1">{
                return t
        }</span>
        <span class="cov8" title="1">p.nextCursor++
        p.rawCursor = p.nextCursor
        p.cursor++
        p.advanceToNonElided()
        return t</span>
}

// Peek ahead at the next non-elided token.
func (p *PeekingLexer) Peek() *Token <span class="cov8" title="1">{
        return &amp;p.tokens[p.nextCursor]
}</span>

// RawPeek peeks ahead at the next raw token.
//
// Unlike Peek, this will include elided tokens.
func (p *PeekingLexer) RawPeek() *Token <span class="cov8" title="1">{
        return &amp;p.tokens[p.rawCursor]
}</span>

// advanceToNonElided advances nextCursor to the closest non-elided token
func (p *PeekingLexer) advanceToNonElided() <span class="cov8" title="1">{
        for ; ; p.nextCursor++ </span><span class="cov8" title="1">{
                t := &amp;p.tokens[p.nextCursor]
                if t.EOF() || !p.elide[t.Type] </span><span class="cov8" title="1">{
                        return
                }</span>
        }
}

// PeekAny peeks forward over elided and non-elided tokens.
//
// Elided tokens will be returned if they match, otherwise the next
// non-elided token will be returned.
//
// The returned RawCursor position is the location of the returned token.
// Use FastForward to move the internal cursors forward.
func (p *PeekingLexer) PeekAny(match func(Token) bool) (t Token, rawCursor RawCursor) <span class="cov8" title="1">{
        for i := p.rawCursor; ; i++ </span><span class="cov8" title="1">{
                t = p.tokens[i]
                if t.EOF() || match(t) || !p.elide[t.Type] </span><span class="cov8" title="1">{
                        return t, i
                }</span>
        }
}

// FastForward the internal cursors to this RawCursor position.
func (p *PeekingLexer) FastForward(rawCursor RawCursor) <span class="cov8" title="1">{
        for ; p.rawCursor &lt;= rawCursor; p.rawCursor++ </span><span class="cov8" title="1">{
                t := &amp;p.tokens[p.rawCursor]
                if t.EOF() </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">if !p.elide[t.Type] </span><span class="cov8" title="1">{
                        p.cursor++
                }</span>
        }
        <span class="cov8" title="1">p.nextCursor = p.rawCursor
        p.advanceToNonElided()</span>
}

func (p *PeekingLexer) MakeCheckpoint() Checkpoint <span class="cov0" title="0">{
        return p.Checkpoint
}</span>

func (p *PeekingLexer) LoadCheckpoint(checkpoint Checkpoint) <span class="cov0" title="0">{
        p.Checkpoint = checkpoint
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package lexer

// SimpleRule is a named regular expression.
type SimpleRule struct {
        Name    string
        Pattern string
}

// MustSimple creates a new Stateful lexer with only a single root state.
// The rules are tried in order.
//
// It panics if there is an error.
func MustSimple(rules []SimpleRule) *StatefulDefinition <span class="cov8" title="1">{
        def, err := NewSimple(rules)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return def</span>
}

// NewSimple creates a new Stateful lexer with only a single root state.
// The rules are tried in order.
func NewSimple(rules []SimpleRule) (*StatefulDefinition, error) <span class="cov8" title="1">{
        fullRules := make([]Rule, len(rules))
        for i, rule := range rules </span><span class="cov8" title="1">{
                fullRules[i] = Rule{Name: rule.Name, Pattern: rule.Pattern}
        }</span>
        <span class="cov8" title="1">return New(Rules{"Root": fullRules})</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package lexer

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "regexp"
        "sort"
        "strconv"
        "strings"
        "sync"
        "unicode"
)

var (
        backrefReplace = regexp.MustCompile(`(\\+)(\d)`)
)

// A Rule matching input and possibly changing state.
type Rule struct {
        Name    string `json:"name"`
        Pattern string `json:"pattern"`
        Action  Action `json:"action"`
}

var _ json.Marshaler = &amp;Rule{}
var _ json.Unmarshaler = &amp;Rule{}

type jsonRule struct {
        Name    string          `json:"name,omitempty"`
        Pattern string          `json:"pattern,omitempty"`
        Action  json.RawMessage `json:"action,omitempty"`
}

func (r *Rule) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        jrule := jsonRule{}
        err := json.Unmarshal(data, &amp;jrule)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.Name = jrule.Name
        r.Pattern = jrule.Pattern
        jaction := struct {
                Kind string `json:"kind"`
        }{}
        if jrule.Action == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(jrule.Action, &amp;jaction)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("lexer: could not unmarshal action %q: %w", string(jrule.Action), err)
        }</span>
        <span class="cov8" title="1">var action Action
        switch jaction.Kind </span>{
        case "push":<span class="cov8" title="1">
                actual := ActionPush{}
                if err := json.Unmarshal(jrule.Action, &amp;actual); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">action = actual</span>
        case "pop":<span class="cov8" title="1">
                actual := ActionPop{}
                if err := json.Unmarshal(jrule.Action, &amp;actual); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">action = actual</span>
        case "include":<span class="cov8" title="1">
                actual := include{}
                if err := json.Unmarshal(jrule.Action, &amp;actual); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">action = actual</span>
        case "":<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("lexer: unknown action %q", jaction.Kind)</span>
        }
        <span class="cov8" title="1">r.Action = action
        return nil</span>
}

func (r *Rule) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        jrule := jsonRule{
                Name:    r.Name,
                Pattern: r.Pattern,
        }
        if r.Action != nil </span><span class="cov8" title="1">{
                actionData, err := json.Marshal(r.Action)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("lexer: failed to map action: %w", err)
                }</span>
                <span class="cov8" title="1">jaction := map[string]interface{}{}
                err = json.Unmarshal(actionData, &amp;jaction)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("lexer: failed to map action: %w", err)
                }</span>
                <span class="cov8" title="1">switch r.Action.(type) </span>{
                case nil:<span class="cov0" title="0"></span>
                case ActionPop:<span class="cov8" title="1">
                        jaction["kind"] = "pop"</span>
                case ActionPush:<span class="cov8" title="1">
                        jaction["kind"] = "push"</span>
                case include:<span class="cov8" title="1">
                        jaction["kind"] = "include"</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("lexer: unsupported action %T", r.Action)</span>
                }
                <span class="cov8" title="1">actionJSON, err := json.Marshal(jaction)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">jrule.Action = actionJSON</span>
        }
        <span class="cov8" title="1">return json.Marshal(&amp;jrule)</span>
}

// Rules grouped by name.
type Rules map[string][]Rule

// compiledRule is a Rule with its pattern compiled.
type compiledRule struct {
        Rule
        ignore bool
        RE     *regexp.Regexp
}

// compiledRules grouped by name.
type compiledRules map[string][]compiledRule

// A Action is applied when a rule matches.
type Action interface {
        // Actions are responsible for validating the match. ie. if they consumed any input.
        applyAction(lexer *StatefulLexer, groups []string) error
}

// RulesAction is an optional interface that Actions can implement.
//
// It is applied during rule construction to mutate the rule map.
type RulesAction interface {
        applyRules(state string, rule int, rules compiledRules) error
}

type validatingRule interface {
        validate(rules Rules) error
}

// ActionPop pops to the previous state when the Rule matches.
type ActionPop struct{}

func (p ActionPop) applyAction(lexer *StatefulLexer, groups []string) error <span class="cov8" title="1">{
        if groups[0] == "" </span><span class="cov0" title="0">{
                return errors.New("did not consume any input")
        }</span>
        <span class="cov8" title="1">lexer.stack = lexer.stack[:len(lexer.stack)-1]
        return nil</span>
}

// Pop to the previous state.
func Pop() Action <span class="cov8" title="1">{
        return ActionPop{}
}</span>

// ReturnRule signals the lexer to return immediately.
var ReturnRule = Rule{"returnToParent", "", nil}

// Return to the parent state.
//
// Useful as the last rule in a sub-state.
func Return() Rule <span class="cov8" title="1">{ return ReturnRule }</span>

// ActionPush pushes the current state and switches to "State" when the Rule matches.
type ActionPush struct {
        State string `json:"state"`
}

func (p ActionPush) applyAction(lexer *StatefulLexer, groups []string) error <span class="cov8" title="1">{
        if groups[0] == "" </span><span class="cov8" title="1">{
                return errors.New("did not consume any input")
        }</span>
        <span class="cov8" title="1">lexer.stack = append(lexer.stack, lexerState{name: p.State, groups: groups})
        return nil</span>
}

func (p ActionPush) validate(rules Rules) error <span class="cov8" title="1">{
        if _, ok := rules[p.State]; !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("lexer: push to unknown state %q", p.State)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Push to the given state.
//
// The target state will then be the set of rules used for matching
// until another Push or Pop is encountered.
func Push(state string) Action <span class="cov8" title="1">{
        return ActionPush{state}
}</span>

type include struct {
        State string `json:"state"`
}

func (i include) applyAction(lexer *StatefulLexer, groups []string) error <span class="cov0" title="0">{
        panic("should not be called")</span>
}

func (i include) applyRules(state string, rule int, rules compiledRules) error <span class="cov8" title="1">{
        includedRules, ok := rules[i.State]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("lexer: invalid include state %q", i.State)
        }</span>
        <span class="cov8" title="1">clone := make([]compiledRule, len(includedRules))
        copy(clone, includedRules)
        rules[state] = append(rules[state][:rule], append(clone, rules[state][rule+1:]...)...) // nolint: makezero
        return nil</span>
}

// Include rules from another state in this one.
func Include(state string) Rule <span class="cov8" title="1">{
        return Rule{Action: include{state}}
}</span>

// StatefulDefinition is the lexer.Definition.
type StatefulDefinition struct {
        rules   compiledRules
        symbols map[string]TokenType
        // Map of key-&gt;*regexp.Regexp
        backrefCache sync.Map
        matchLongest bool
}

// MustStateful creates a new stateful lexer and panics if it is incorrect.
func MustStateful(rules Rules) *StatefulDefinition <span class="cov0" title="0">{
        def, err := New(rules)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return def</span>
}

// New constructs a new stateful lexer from rules.
func New(rules Rules) (*StatefulDefinition, error) <span class="cov8" title="1">{
        compiled := compiledRules{}
        for key, set := range rules </span><span class="cov8" title="1">{
                for i, rule := range set </span><span class="cov8" title="1">{
                        if validate, ok := rule.Action.(validatingRule); ok </span><span class="cov8" title="1">{
                                if err := validate.validate(rules); err != nil </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("lexer: invalid action for rule %q: %w", rule.Name, err)
                                }</span>
                        }
                        <span class="cov8" title="1">pattern := "^(?:" + rule.Pattern + ")"
                        var (
                                re  *regexp.Regexp
                                err error
                        )
                        var match = backrefReplace.FindStringSubmatch(rule.Pattern)
                        if match == nil || len(match[1])%2 == 0 </span><span class="cov8" title="1">{
                                re, err = regexp.Compile(pattern)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("lexer: %s.%d: %s", key, i, err)
                                }</span>
                        }
                        <span class="cov8" title="1">compiled[key] = append(compiled[key], compiledRule{
                                Rule:   rule,
                                ignore: len(rule.Name) &gt; 0 &amp;&amp; unicode.IsLower(rune(rule.Name[0])),
                                RE:     re,
                        })</span>
                }
        }
<span class="cov8" title="1">restart:
        for state, rules := range compiled </span><span class="cov8" title="1">{
                for i, rule := range rules </span><span class="cov8" title="1">{
                        if action, ok := rule.Action.(RulesAction); ok </span><span class="cov8" title="1">{
                                if err := action.applyRules(state, i, compiled); err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("lexer: %s.%d: %s", state, i, err)
                                }</span>
                                <span class="cov8" title="1">goto restart</span>
                        }
                }
        }
        <span class="cov8" title="1">keys := make([]string, 0, len(compiled))
        for key := range compiled </span><span class="cov8" title="1">{
                keys = append(keys, key)
        }</span>
        <span class="cov8" title="1">symbols := map[string]TokenType{
                "EOF": EOF,
        }
        sort.Strings(keys)
        duplicates := map[string]compiledRule{}
        rn := EOF - 1
        for _, key := range keys </span><span class="cov8" title="1">{
                for i, rule := range compiled[key] </span><span class="cov8" title="1">{
                        if dup, ok := duplicates[rule.Name]; ok &amp;&amp; rule.Pattern != dup.Pattern </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("lexer: duplicate key %q with different patterns %q != %q", rule.Name, rule.Pattern, dup.Pattern))</span>
                        }
                        <span class="cov8" title="1">duplicates[rule.Name] = rule
                        compiled[key][i] = rule
                        symbols[rule.Name] = rn
                        rn--</span>
                }
        }
        <span class="cov8" title="1">d := &amp;StatefulDefinition{
                rules:   compiled,
                symbols: symbols,
        }
        return d, nil</span>
}

func (d *StatefulDefinition) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(d.rules)
}</span>

// Rules returns the user-provided Rules used to construct the lexer.
func (d *StatefulDefinition) Rules() Rules <span class="cov0" title="0">{
        out := Rules{}
        for state, rules := range d.rules </span><span class="cov0" title="0">{
                for _, rule := range rules </span><span class="cov0" title="0">{
                        out[state] = append(out[state], rule.Rule)
                }</span>
        }
        <span class="cov0" title="0">return out</span>
}

// LexString is a fast-path implementation for lexing strings.
func (d *StatefulDefinition) LexString(filename string, s string) (Lexer, error) <span class="cov8" title="1">{
        return &amp;StatefulLexer{
                def:   d,
                data:  s,
                stack: []lexerState{{name: "Root"}},
                pos: Position{
                        Filename: filename,
                        Line:     1,
                        Column:   1,
                },
        }, nil
}</span>

func (d *StatefulDefinition) Lex(filename string, r io.Reader) (Lexer, error) <span class="cov8" title="1">{ // nolint: golint
        w := &amp;strings.Builder{}
        _, err := io.Copy(w, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return d.LexString(filename, w.String())</span>
}

func (d *StatefulDefinition) Symbols() map[string]TokenType <span class="cov8" title="1">{ // nolint: golint
        return d.symbols
}</span>

// lexerState stored when switching states in the lexer.
type lexerState struct {
        name   string
        groups []string
}

// StatefulLexer implementation.
type StatefulLexer struct {
        stack []lexerState
        def   *StatefulDefinition
        data  string
        pos   Position
}

func (l *StatefulLexer) Next() (Token, error) <span class="cov8" title="1">{ // nolint: golint
        parent := l.stack[len(l.stack)-1]
        rules := l.def.rules[parent.name]
next:
        for len(l.data) &gt; 0 </span><span class="cov8" title="1">{
                var (
                        rule  *compiledRule
                        m     []int
                        match []int
                )
                for i, candidate := range rules </span><span class="cov8" title="1">{
                        // Special case "Return()".
                        if candidate.Rule == ReturnRule </span><span class="cov8" title="1">{
                                l.stack = l.stack[:len(l.stack)-1]
                                parent = l.stack[len(l.stack)-1]
                                rules = l.def.rules[parent.name]
                                continue next</span>
                        }
                        <span class="cov8" title="1">re, err := l.getPattern(candidate)
                        if err != nil </span><span class="cov8" title="1">{
                                return Token{}, errorf(l.pos, "lexer: rule %q: %s", candidate.Name, err)
                        }</span>
                        <span class="cov8" title="1">m = re.FindStringSubmatchIndex(l.data)
                        if m != nil &amp;&amp; (match == nil || m[1] &gt; match[1]) </span><span class="cov8" title="1">{
                                match = m
                                rule = &amp;rules[i]
                                if !l.def.matchLongest </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">if match == nil || rule == nil </span><span class="cov0" title="0">{
                        sample := []rune(l.data)
                        if len(sample) &gt; 16 </span><span class="cov0" title="0">{
                                sample = append(sample[:16], []rune("...")...)
                        }</span>
                        <span class="cov0" title="0">return Token{}, errorf(l.pos, "lexer: invalid input text %q", string(sample))</span>
                }

                <span class="cov8" title="1">if rule.Action != nil </span><span class="cov8" title="1">{
                        groups := make([]string, 0, len(match)/2)
                        for i := 0; i &lt; len(match); i += 2 </span><span class="cov8" title="1">{
                                groups = append(groups, l.data[match[i]:match[i+1]])
                        }</span>
                        <span class="cov8" title="1">if err := rule.Action.applyAction(l, groups); err != nil </span><span class="cov8" title="1">{
                                return Token{}, errorf(l.pos, "lexer: rule %q: %s", rule.Name, err)
                        }</span>
                } else<span class="cov8" title="1"> if match[0] == match[1] </span><span class="cov8" title="1">{
                        return Token{}, errorf(l.pos, "lexer: rule %q did not match any input", rule.Name)
                }</span>

                <span class="cov8" title="1">span := l.data[match[0]:match[1]]
                l.data = l.data[match[1]:]
                // l.groups = groups

                // Update position.
                pos := l.pos
                l.pos.Advance(span)
                if rule.ignore </span><span class="cov8" title="1">{
                        parent = l.stack[len(l.stack)-1]
                        rules = l.def.rules[parent.name]
                        continue</span>
                }
                <span class="cov8" title="1">return Token{
                        Type:  l.def.symbols[rule.Name],
                        Value: span,
                        Pos:   pos,
                }, nil</span>
        }
        <span class="cov8" title="1">return EOFToken(l.pos), nil</span>
}

func (l *StatefulLexer) getPattern(candidate compiledRule) (*regexp.Regexp, error) <span class="cov8" title="1">{
        if candidate.RE != nil </span><span class="cov8" title="1">{
                return candidate.RE, nil
        }</span>
        // We don't have a compiled RE. This means there are back-references
        // that need to be substituted first.
        <span class="cov8" title="1">return BackrefRegex(&amp;l.def.backrefCache, candidate.Pattern, l.stack[len(l.stack)-1].groups)</span>
}

// BackrefRegex returns a compiled regular expression with backreferences replaced by groups.
func BackrefRegex(backrefCache *sync.Map, input string, groups []string) (*regexp.Regexp, error) <span class="cov8" title="1">{
        key := input + "\000" + strings.Join(groups, "\000")
        cached, ok := backrefCache.Load(key)
        if ok </span><span class="cov8" title="1">{
                return cached.(*regexp.Regexp), nil
        }</span>

        <span class="cov8" title="1">var (
                re  *regexp.Regexp
                err error
        )
        pattern := backrefReplace.ReplaceAllStringFunc(input, func(s string) string </span><span class="cov8" title="1">{
                var rematch = backrefReplace.FindStringSubmatch(s)
                n, nerr := strconv.ParseInt(rematch[2], 10, 64)
                if nerr != nil </span><span class="cov0" title="0">{
                        err = nerr
                        return s
                }</span>
                <span class="cov8" title="1">if len(groups) == 0 || int(n) &gt;= len(groups) </span><span class="cov8" title="1">{
                        err = fmt.Errorf("invalid group %d from parent with %d groups", n, len(groups))
                        return s
                }</span>
                // concatenate the leading \\\\ which are already escaped to the quoted match.
                <span class="cov8" title="1">return rematch[1][:len(rematch[1])-1] + regexp.QuoteMeta(groups[n])</span>
        })
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                re, err = regexp.Compile("^(?:" + pattern + ")")
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid backref expansion: %q: %s", pattern, err)
        }</span>
        <span class="cov8" title="1">backrefCache.Store(key, re)
        return re, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package lexer

import (
        "bytes"
        "io"
        "strings"
        "text/scanner"
)

// TextScannerLexer is a lexer that uses the text/scanner module.
var (
        TextScannerLexer Definition = &amp;textScannerLexerDefinition{}

        // DefaultDefinition defines properties for the default lexer.
        DefaultDefinition = TextScannerLexer
)

// NewTextScannerLexer constructs a Definition that uses an underlying scanner.Scanner
//
// "configure" will be called after the scanner.Scanner.Init(r) is called. If "configure"
// is nil a default scanner.Scanner will be used.
func NewTextScannerLexer(configure func(*scanner.Scanner)) Definition <span class="cov8" title="1">{
        return &amp;textScannerLexerDefinition{configure: configure}
}</span>

type textScannerLexerDefinition struct {
        configure func(*scanner.Scanner)
}

func (d *textScannerLexerDefinition) Lex(filename string, r io.Reader) (Lexer, error) <span class="cov8" title="1">{
        l := Lex(filename, r)
        if d.configure != nil </span><span class="cov8" title="1">{
                d.configure(l.(*textScannerLexer).scanner)
        }</span>
        <span class="cov8" title="1">return l, nil</span>
}

func (d *textScannerLexerDefinition) Symbols() map[string]TokenType <span class="cov8" title="1">{
        return map[string]TokenType{
                "EOF":       EOF,
                "Char":      scanner.Char,
                "Ident":     scanner.Ident,
                "Int":       scanner.Int,
                "Float":     scanner.Float,
                "String":    scanner.String,
                "RawString": scanner.RawString,
                "Comment":   scanner.Comment,
        }
}</span>

// textScannerLexer is a Lexer based on text/scanner.Scanner
type textScannerLexer struct {
        scanner  *scanner.Scanner
        filename string
        err      error
}

// Lex an io.Reader with text/scanner.Scanner.
//
// This provides very fast lexing of source code compatible with Go tokens.
//
// Note that this differs from text/scanner.Scanner in that string tokens will be unquoted.
func Lex(filename string, r io.Reader) Lexer <span class="cov8" title="1">{
        s := &amp;scanner.Scanner{}
        s.Init(r)
        lexer := lexWithScanner(filename, s)
        lexer.scanner.Error = func(s *scanner.Scanner, msg string) </span><span class="cov0" title="0">{
                lexer.err = errorf(Position(lexer.scanner.Pos()), "%s", msg)
        }</span>
        <span class="cov8" title="1">return lexer</span>
}

// LexWithScanner creates a Lexer from a user-provided scanner.Scanner.
//
// Useful if you need to customise the Scanner.
func LexWithScanner(filename string, scan *scanner.Scanner) Lexer <span class="cov0" title="0">{
        return lexWithScanner(filename, scan)
}</span>

func lexWithScanner(filename string, scan *scanner.Scanner) *textScannerLexer <span class="cov8" title="1">{
        scan.Filename = filename
        lexer := &amp;textScannerLexer{
                filename: filename,
                scanner:  scan,
        }
        return lexer
}</span>

// LexBytes returns a new default lexer over bytes.
func LexBytes(filename string, b []byte) Lexer <span class="cov0" title="0">{
        return Lex(filename, bytes.NewReader(b))
}</span>

// LexString returns a new default lexer over a string.
func LexString(filename, s string) Lexer <span class="cov8" title="1">{
        return Lex(filename, strings.NewReader(s))
}</span>

func (t *textScannerLexer) Next() (Token, error) <span class="cov8" title="1">{
        typ := t.scanner.Scan()
        text := t.scanner.TokenText()
        pos := Position(t.scanner.Position)
        pos.Filename = t.filename
        if t.err != nil </span><span class="cov0" title="0">{
                return Token{}, t.err
        }</span>
        <span class="cov8" title="1">return Token{
                Type:  TokenType(typ),
                Value: text,
                Pos:   pos,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package participle

import (
        "io"
        "strconv"
        "strings"

        "github.com/alecthomas/participle/v2/lexer"
)

type mapperByToken struct {
        symbols []string
        mapper  Mapper
}

// Mapper function for mutating tokens before being applied to the AST.
type Mapper func(token lexer.Token) (lexer.Token, error)

// Map is an Option that configures the Parser to apply a mapping function to each Token from the lexer.
//
// This can be useful to eg. upper-case all tokens of a certain type, or dequote strings.
//
// "symbols" specifies the token symbols that the Mapper will be applied to. If empty, all tokens will be mapped.
func Map(mapper Mapper, symbols ...string) Option <span class="cov8" title="1">{
        return func(p *parserOptions) error </span><span class="cov8" title="1">{
                p.mappers = append(p.mappers, mapperByToken{
                        mapper:  mapper,
                        symbols: symbols,
                })
                return nil
        }</span>
}

// Unquote applies strconv.Unquote() to tokens of the given types.
//
// Tokens of type "String" will be unquoted if no other types are provided.
func Unquote(types ...string) Option <span class="cov8" title="1">{
        if len(types) == 0 </span><span class="cov8" title="1">{
                types = []string{"String"}
        }</span>
        <span class="cov8" title="1">return Map(func(t lexer.Token) (lexer.Token, error) </span><span class="cov8" title="1">{
                value, err := unquote(t.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return t, Errorf(t.Pos, "invalid quoted string %q: %s", t.Value, err.Error())
                }</span>
                <span class="cov8" title="1">t.Value = value
                return t, nil</span>
        }, types...)
}

func unquote(s string) (string, error) <span class="cov8" title="1">{
        quote := s[0]
        s = s[1 : len(s)-1]
        out := ""
        for s != "" </span><span class="cov8" title="1">{
                value, _, tail, err := strconv.UnquoteChar(s, quote)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">s = tail
                out += string(value)</span>
        }
        <span class="cov8" title="1">return out, nil</span>
}

// Upper is an Option that upper-cases all tokens of the given type. Useful for case normalisation.
func Upper(types ...string) Option <span class="cov8" title="1">{
        return Map(func(token lexer.Token) (lexer.Token, error) </span><span class="cov8" title="1">{
                token.Value = strings.ToUpper(token.Value)
                return token, nil
        }</span>, types...)
}

// Elide drops tokens of the specified types.
func Elide(types ...string) Option <span class="cov8" title="1">{
        return func(p *parserOptions) error </span><span class="cov8" title="1">{
                p.elide = append(p.elide, types...)
                return nil
        }</span>
}

// Apply a Mapping to all tokens coming out of a Lexer.
type mappingLexerDef struct {
        l      lexer.Definition
        mapper Mapper
}

var _ lexer.Definition = &amp;mappingLexerDef{}

func (m *mappingLexerDef) Symbols() map[string]lexer.TokenType <span class="cov8" title="1">{ return m.l.Symbols() }</span>

func (m *mappingLexerDef) Lex(filename string, r io.Reader) (lexer.Lexer, error) <span class="cov8" title="1">{
        l, err := m.l.Lex(filename, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;mappingLexer{l, m.mapper}, nil</span>
}

type mappingLexer struct {
        lexer.Lexer
        mapper Mapper
}

func (m *mappingLexer) Next() (lexer.Token, error) <span class="cov8" title="1">{
        t, err := m.Lexer.Next()
        if err != nil </span><span class="cov0" title="0">{
                return t, err
        }</span>
        <span class="cov8" title="1">return m.mapper(t)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package participle

import (
        "encoding"
        "errors"
        "fmt"
        "reflect"
        "strconv"
        "strings"

        "github.com/alecthomas/participle/v2/lexer"
)

var (
        // MaxIterations limits the number of elements capturable by {}.
        MaxIterations = 1000000

        positionType        = reflect.TypeOf(lexer.Position{})
        tokenType           = reflect.TypeOf(lexer.Token{})
        tokensType          = reflect.TypeOf([]lexer.Token{})
        captureType         = reflect.TypeOf((*Capture)(nil)).Elem()
        textUnmarshalerType = reflect.TypeOf((*encoding.TextUnmarshaler)(nil)).Elem()
        parseableType       = reflect.TypeOf((*Parseable)(nil)).Elem()

        // NextMatch should be returned by Parseable.Parse() method implementations to indicate
        // that the node did not match and that other matches should be attempted, if appropriate.
        NextMatch = errors.New("no match") // nolint: golint
)

// A node in the grammar.
type node interface {
        // Parse from scanner into value.
        //
        // Returned slice will be nil if the node does not match.
        Parse(ctx *parseContext, parent reflect.Value) ([]reflect.Value, error)

        // Return a decent string representation of the Node.
        fmt.Stringer

        fmt.GoStringer
}

func decorate(err *error, name func() string) <span class="cov8" title="1">{
        if *err == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if perr, ok := (*err).(Error); ok </span><span class="cov0" title="0">{
                *err = Errorf(perr.Position(), "%s: %s", name(), perr.Message())
        }</span> else<span class="cov8" title="1"> {
                *err = &amp;ParseError{Msg: fmt.Sprintf("%s: %s", name(), *err)}
        }</span>
}

// A node that proxies to an implementation that implements the Parseable interface.
type parseable struct {
        t reflect.Type
}

func (p *parseable) String() string   <span class="cov0" title="0">{ return ebnf(p) }</span>
func (p *parseable) GoString() string <span class="cov0" title="0">{ return p.t.String() }</span>

func (p *parseable) Parse(ctx *parseContext, parent reflect.Value) (out []reflect.Value, err error) <span class="cov8" title="1">{
        defer ctx.printTrace(p)()
        rv := reflect.New(p.t)
        v := rv.Interface().(Parseable)
        err = v.Parse(&amp;ctx.PeekingLexer)
        if err != nil </span><span class="cov8" title="1">{
                if err == NextMatch </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return []reflect.Value{rv.Elem()}, nil</span>
}

// @@ (but for a custom production)
type custom struct {
        typ     reflect.Type
        parseFn reflect.Value
}

func (c *custom) String() string   <span class="cov0" title="0">{ return ebnf(c) }</span>
func (c *custom) GoString() string <span class="cov0" title="0">{ return c.typ.Name() }</span>

func (c *custom) Parse(ctx *parseContext, parent reflect.Value) (out []reflect.Value, err error) <span class="cov8" title="1">{
        defer ctx.printTrace(c)()
        results := c.parseFn.Call([]reflect.Value{reflect.ValueOf(&amp;ctx.PeekingLexer)})
        if err, _ := results[1].Interface().(error); err != nil </span><span class="cov0" title="0">{
                if err == NextMatch </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return []reflect.Value{results[0]}, nil</span>
}

// @@ (for a union)
type union struct {
        unionDef
        disjunction disjunction
}

func (u *union) String() string   <span class="cov0" title="0">{ return ebnf(u) }</span>
func (u *union) GoString() string <span class="cov8" title="1">{ return u.typ.Name() }</span>

func (u *union) Parse(ctx *parseContext, parent reflect.Value) (out []reflect.Value, err error) <span class="cov8" title="1">{
        defer ctx.printTrace(u)()
        vals, err := u.disjunction.Parse(ctx, parent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for i := range vals </span><span class="cov8" title="1">{
                vals[i] = maybeRef(u.members[i], vals[i]).Convert(u.typ)
        }</span>
        <span class="cov8" title="1">return vals, nil</span>
}

// @@
type strct struct {
        typ              reflect.Type
        expr             node
        tokensFieldIndex []int
        posFieldIndex    []int
        endPosFieldIndex []int
        usages           int
}

func newStrct(typ reflect.Type) *strct <span class="cov8" title="1">{
        s := &amp;strct{
                typ:    typ,
                usages: 1,
        }
        field, ok := typ.FieldByName("Pos")
        if ok &amp;&amp; positionType.ConvertibleTo(field.Type) </span><span class="cov8" title="1">{
                s.posFieldIndex = field.Index
        }</span>
        <span class="cov8" title="1">field, ok = typ.FieldByName("EndPos")
        if ok &amp;&amp; positionType.ConvertibleTo(field.Type) </span><span class="cov8" title="1">{
                s.endPosFieldIndex = field.Index
        }</span>
        <span class="cov8" title="1">field, ok = typ.FieldByName("Tokens")
        if ok &amp;&amp; field.Type == tokensType </span><span class="cov8" title="1">{
                s.tokensFieldIndex = field.Index
        }</span>
        <span class="cov8" title="1">return s</span>
}

func (s *strct) String() string   <span class="cov8" title="1">{ return ebnf(s) }</span>
func (s *strct) GoString() string <span class="cov8" title="1">{ return s.typ.Name() }</span>

func (s *strct) Parse(ctx *parseContext, parent reflect.Value) (out []reflect.Value, err error) <span class="cov8" title="1">{
        defer ctx.printTrace(s)()
        sv := reflect.New(s.typ).Elem()
        start := ctx.RawCursor()
        t := ctx.Peek()
        s.maybeInjectStartToken(t, sv)
        if out, err = s.expr.Parse(ctx, sv); err != nil </span><span class="cov8" title="1">{
                // Try to recover from the error
                if recovered, _ := ctx.tryRecover(err, sv); recovered </span><span class="cov8" title="1">{
                        // Recovery succeeded - continue with partial result
                        _ = ctx.Apply()
                        end := ctx.RawCursor()
                        t = ctx.RawPeek()
                        s.maybeInjectEndToken(t, sv)
                        s.maybeInjectTokens(ctx.Range(start, end), sv)
                        return []reflect.Value{sv}, nil
                }</span>
                <span class="cov8" title="1">_ = ctx.Apply() // Best effort to give partial AST.
                ctx.MaybeUpdateError(err)
                return []reflect.Value{sv}, err</span>
        } else<span class="cov8" title="1"> if out == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">end := ctx.RawCursor()
        t = ctx.RawPeek()
        s.maybeInjectEndToken(t, sv)
        s.maybeInjectTokens(ctx.Range(start, end), sv)
        return []reflect.Value{sv}, ctx.Apply()</span>
}

func (s *strct) maybeInjectStartToken(token *lexer.Token, v reflect.Value) <span class="cov8" title="1">{
        if s.posFieldIndex == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">f := v.FieldByIndex(s.posFieldIndex)
        f.Set(reflect.ValueOf(token.Pos).Convert(f.Type()))</span>
}

func (s *strct) maybeInjectEndToken(token *lexer.Token, v reflect.Value) <span class="cov8" title="1">{
        if s.endPosFieldIndex == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">f := v.FieldByIndex(s.endPosFieldIndex)
        f.Set(reflect.ValueOf(token.Pos).Convert(f.Type()))</span>
}

func (s *strct) maybeInjectTokens(tokens []lexer.Token, v reflect.Value) <span class="cov8" title="1">{
        if s.tokensFieldIndex == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">v.FieldByIndex(s.tokensFieldIndex).Set(reflect.ValueOf(tokens))</span>
}

type groupMatchMode int

func (g groupMatchMode) String() string <span class="cov0" title="0">{
        switch g </span>{
        case groupMatchOnce:<span class="cov0" title="0">
                return "n"</span>
        case groupMatchZeroOrOne:<span class="cov0" title="0">
                return "n?"</span>
        case groupMatchZeroOrMore:<span class="cov0" title="0">
                return "n*"</span>
        case groupMatchOneOrMore:<span class="cov0" title="0">
                return "n+"</span>
        case groupMatchNonEmpty:<span class="cov0" title="0">
                return "n!"</span>
        }
        <span class="cov0" title="0">panic("??")</span>
}

const (
        groupMatchOnce       groupMatchMode = iota
        groupMatchZeroOrOne                 = iota
        groupMatchZeroOrMore                = iota
        groupMatchOneOrMore                 = iota
        groupMatchNonEmpty                  = iota
)

// ( &lt;expr&gt; ) - match once
// ( &lt;expr&gt; )* - match zero or more times
// ( &lt;expr&gt; )+ - match one or more times
// ( &lt;expr&gt; )? - match zero or once
// ( &lt;expr&gt; )! - must be a non-empty match
//
// The additional modifier "!" forces the content of the group to be non-empty if it does match.
type group struct {
        expr node
        mode groupMatchMode
}

func (g *group) String() string   <span class="cov8" title="1">{ return ebnf(g) }</span>
func (g *group) GoString() string <span class="cov0" title="0">{ return fmt.Sprintf("group{%s}", g.mode) }</span>
func (g *group) Parse(ctx *parseContext, parent reflect.Value) (out []reflect.Value, err error) <span class="cov8" title="1">{
        defer ctx.printTrace(g)()
        // Configure min/max matches.
        min := 1
        max := 1
        switch g.mode </span>{
        case groupMatchNonEmpty:<span class="cov8" title="1">
                out, err = g.expr.Parse(ctx, parent)
                if err != nil </span><span class="cov0" title="0">{
                        return out, err
                }</span>
                <span class="cov8" title="1">if len(out) == 0 </span><span class="cov8" title="1">{
                        t := ctx.Peek()
                        return out, Errorf(t.Pos, "sub-expression %s cannot be empty", g)
                }</span>
                <span class="cov8" title="1">return out, nil</span>
        case groupMatchOnce:<span class="cov8" title="1">
                return g.expr.Parse(ctx, parent)</span>
        case groupMatchZeroOrOne:<span class="cov8" title="1">
                min = 0</span>
        case groupMatchZeroOrMore:<span class="cov8" title="1">
                min = 0
                max = MaxIterations</span>
        case groupMatchOneOrMore:<span class="cov8" title="1">
                min = 1
                max = MaxIterations</span>
        }
        <span class="cov8" title="1">matches := 0
        for ; matches &lt; max; matches++ </span><span class="cov8" title="1">{
                branch := ctx.Branch()
                v, err := g.expr.Parse(branch, parent)
                if err != nil </span><span class="cov8" title="1">{
                        ctx.MaybeUpdateError(err)
                        // Try to recover from the error
                        if recovered, recoveredValues := ctx.tryRecover(err, parent); recovered </span><span class="cov8" title="1">{
                                // Recovery succeeded - accept what we have and continue
                                out = append(out, v...)
                                if len(recoveredValues) &gt; 0 </span><span class="cov0" title="0">{
                                        out = append(out, recoveredValues...)
                                }</span>
                                <span class="cov8" title="1">ctx.Accept(branch)
                                continue</span> // Try to parse more iterations after recovery
                        }
                        // Optional part failed to match.
                        <span class="cov8" title="1">if ctx.Stop(err, branch) </span><span class="cov8" title="1">{
                                out = append(out, v...) // Try to return as much of the parse tree as possible
                                return out, err
                        }</span>
                        <span class="cov8" title="1">break</span>
                }
                <span class="cov8" title="1">out = append(out, v...)
                ctx.Accept(branch)
                if v == nil </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        // fmt.Printf("%d &lt; %d &lt; %d: out == nil? %v\n", min, matches, max, out == nil)
        <span class="cov8" title="1">t := ctx.Peek()
        if matches &gt;= MaxIterations </span><span class="cov0" title="0">{
                return nil, Errorf(t.Pos, "too many iterations of %s (&gt; %d)", g, MaxIterations)
        }</span>
        // avoid returning errors in parent nodes if the group is optional
        <span class="cov8" title="1">if matches &gt; 0 &amp;&amp; matches &lt; min </span><span class="cov0" title="0">{
                return out, Errorf(t.Pos, "sub-expression %s must match at least once", g)
        }</span>
        // The idea here is that something like "a"? is a successful match and that parsing should proceed.
        <span class="cov8" title="1">if min == 0 &amp;&amp; out == nil </span><span class="cov8" title="1">{
                out = []reflect.Value{}
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// (?= &lt;expr&gt; ) for positive lookahead, (?! &lt;expr&gt; ) for negative lookahead; neither consumes input
type lookaheadGroup struct {
        expr     node
        negative bool
}

func (l *lookaheadGroup) String() string   <span class="cov0" title="0">{ return ebnf(l) }</span>
func (l *lookaheadGroup) GoString() string <span class="cov0" title="0">{ return "lookaheadGroup{}" }</span>

func (l *lookaheadGroup) Parse(ctx *parseContext, parent reflect.Value) (out []reflect.Value, err error) <span class="cov8" title="1">{
        defer ctx.printTrace(l)()
        // Create a branch to avoid advancing the parser as any match will be discarded
        branch := ctx.Branch()
        out, err = l.expr.Parse(branch, parent)
        matchedLookahead := err == nil &amp;&amp; out != nil
        expectingMatch := !l.negative
        if matchedLookahead != expectingMatch </span><span class="cov8" title="1">{
                return nil, &amp;UnexpectedTokenError{Unexpected: *ctx.Peek()}
        }</span>
        <span class="cov8" title="1">return []reflect.Value{}, nil</span> // Empty match slice means a match, unlike nil
}

// &lt;expr&gt; {"|" &lt;expr&gt;}
type disjunction struct {
        nodes []node
}

func (d *disjunction) String() string   <span class="cov0" title="0">{ return ebnf(d) }</span>
func (d *disjunction) GoString() string <span class="cov8" title="1">{ return "disjunction{}" }</span>

func (d *disjunction) Parse(ctx *parseContext, parent reflect.Value) (out []reflect.Value, err error) <span class="cov8" title="1">{
        defer ctx.printTrace(d)()
        var (
                deepestError = 0
                firstError   error
                firstValues  []reflect.Value
        )
        for _, a := range d.nodes </span><span class="cov8" title="1">{
                branch := ctx.Branch()
                if value, err := a.Parse(branch, parent); err != nil </span><span class="cov8" title="1">{
                        // If this branch progressed too far and still didn't match, error out.
                        if ctx.Stop(err, branch) </span><span class="cov0" title="0">{
                                return value, err
                        }</span>
                        // Show the closest error returned. The idea here is that the further the parser progresses
                        // without error, the more difficult it is to trace the error back to its root.
                        <span class="cov8" title="1">if branch.Cursor() &gt;= deepestError </span><span class="cov8" title="1">{
                                firstError = err
                                firstValues = value
                                deepestError = branch.Cursor()
                        }</span>
                } else<span class="cov8" title="1"> if value != nil </span><span class="cov8" title="1">{
                        bt := branch.RawPeek()
                        ct := ctx.RawPeek()
                        if bt == ct &amp;&amp; bt.Type != lexer.EOF </span><span class="cov0" title="0">{
                                panic(Errorf(bt.Pos, "branch %s was accepted but did not progress the lexer at %s (%q)", a, bt.Pos, bt.Value))</span>
                        }
                        <span class="cov8" title="1">ctx.Accept(branch)
                        return value, nil</span>
                }
        }
        <span class="cov8" title="1">if firstError != nil </span><span class="cov8" title="1">{
                ctx.MaybeUpdateError(firstError)
                return firstValues, firstError
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

// &lt;node&gt; ...
type sequence struct {
        head bool // True if this is the head node.
        node node
        next *sequence
}

func (s *sequence) String() string   <span class="cov8" title="1">{ return ebnf(s) }</span>
func (s *sequence) GoString() string <span class="cov8" title="1">{ return "sequence{}" }</span>

func (s *sequence) Parse(ctx *parseContext, parent reflect.Value) (out []reflect.Value, err error) <span class="cov8" title="1">{
        defer ctx.printTrace(s)()
        for n := s; n != nil; n = n.next </span><span class="cov8" title="1">{
                child, err := n.node.Parse(ctx, parent)
                out = append(out, child...)
                if err != nil </span><span class="cov8" title="1">{
                        return out, err
                }</span>
                <span class="cov8" title="1">if child == nil </span><span class="cov8" title="1">{
                        // Early exit if first value doesn't match, otherwise all values must match.
                        if n == s </span><span class="cov8" title="1">{
                                return nil, nil
                        }</span>
                        <span class="cov8" title="1">token := ctx.Peek()
                        return out, &amp;UnexpectedTokenError{Unexpected: *token, expectNode: n}</span>
                }
                // Special-case for when children return an empty match.
                // Appending an empty, non-nil slice to a nil slice returns a nil slice.
                // https://go.dev/play/p/lV1Xk-IP6Ta
                <span class="cov8" title="1">if out == nil </span><span class="cov8" title="1">{
                        out = []reflect.Value{}
                }</span>
        }
        <span class="cov8" title="1">return out, nil</span>
}

// @&lt;expr&gt;
type capture struct {
        field structLexerField
        node  node
}

func (c *capture) String() string   <span class="cov0" title="0">{ return ebnf(c) }</span>
func (c *capture) GoString() string <span class="cov8" title="1">{ return "capture{}" }</span>

func (c *capture) Parse(ctx *parseContext, parent reflect.Value) (out []reflect.Value, err error) <span class="cov8" title="1">{
        defer ctx.printTrace(c)()
        start := ctx.RawCursor()
        v, err := c.node.Parse(ctx, parent)
        if v != nil </span><span class="cov8" title="1">{
                ctx.Defer(ctx.Range(start, ctx.RawCursor()), parent, c.field, v)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return []reflect.Value{parent}, err
        }</span>
        <span class="cov8" title="1">if v == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return []reflect.Value{parent}, nil</span>
}

// &lt;identifier&gt; - named lexer token reference
type reference struct {
        typ        lexer.TokenType
        identifier string // Used for informational purposes.
}

func (r *reference) String() string   <span class="cov0" title="0">{ return ebnf(r) }</span>
func (r *reference) GoString() string <span class="cov8" title="1">{ return fmt.Sprintf("reference{%s}", r.identifier) }</span>

func (r *reference) Parse(ctx *parseContext, parent reflect.Value) (out []reflect.Value, err error) <span class="cov8" title="1">{
        defer ctx.printTrace(r)()
        token, cursor := ctx.PeekAny(func(t lexer.Token) bool </span><span class="cov8" title="1">{
                return t.Type == r.typ
        }</span>)
        <span class="cov8" title="1">if token.Type != r.typ </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">ctx.FastForward(cursor)
        return []reflect.Value{reflect.ValueOf(token.Value)}, nil</span>
}

// Match a token literal exactly "..."[:&lt;type&gt;].
type literal struct {
        s  string
        t  lexer.TokenType
        tt string // Used for display purposes - symbolic name of t.
}

func (l *literal) String() string   <span class="cov0" title="0">{ return ebnf(l) }</span>
func (l *literal) GoString() string <span class="cov8" title="1">{ return fmt.Sprintf("literal{%q, %q}", l.s, l.tt) }</span>

func (l *literal) Parse(ctx *parseContext, parent reflect.Value) (out []reflect.Value, err error) <span class="cov8" title="1">{
        defer ctx.printTrace(l)()
        match := func(t lexer.Token) bool </span><span class="cov8" title="1">{
                var equal bool
                if ctx.caseInsensitive[t.Type] </span><span class="cov8" title="1">{
                        equal = l.s == "" || strings.EqualFold(t.Value, l.s)
                }</span> else<span class="cov8" title="1"> {
                        equal = l.s == "" || t.Value == l.s
                }</span>
                <span class="cov8" title="1">return (l.t == lexer.EOF || l.t == t.Type) &amp;&amp; equal</span>
        }
        <span class="cov8" title="1">token, cursor := ctx.PeekAny(match)
        if match(token) </span><span class="cov8" title="1">{
                ctx.FastForward(cursor)
                return []reflect.Value{reflect.ValueOf(token.Value)}, nil
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

type negation struct {
        node node
}

func (n *negation) String() string   <span class="cov0" title="0">{ return ebnf(n) }</span>
func (n *negation) GoString() string <span class="cov0" title="0">{ return "negation{}" }</span>

func (n *negation) Parse(ctx *parseContext, parent reflect.Value) (out []reflect.Value, err error) <span class="cov8" title="1">{
        defer ctx.printTrace(n)()
        // Create a branch to avoid advancing the parser, but call neither Stop nor Accept on it
        // since we will discard a match.
        branch := ctx.Branch()
        notEOF := ctx.Peek()
        if notEOF.EOF() </span><span class="cov8" title="1">{
                // EOF cannot match a negation, which expects something
                return nil, nil
        }</span>

        <span class="cov8" title="1">out, err = n.node.Parse(branch, parent)
        if out != nil &amp;&amp; err == nil </span><span class="cov8" title="1">{
                // out being non-nil means that what we don't want is actually here, so we report nomatch
                return nil, &amp;UnexpectedTokenError{Unexpected: *notEOF}
        }</span>

        // Just give the next token
        <span class="cov8" title="1">next := ctx.Next()
        return []reflect.Value{reflect.ValueOf(next.Value)}, nil</span>
}

// Attempt to transform values to given type.
//
// This will dereference pointers, and attempt to parse strings into integer values, floats, etc.
func conform(t reflect.Type, values []reflect.Value) (out []reflect.Value, err error) <span class="cov8" title="1">{
        for _, v := range values </span><span class="cov8" title="1">{
                for t != v.Type() &amp;&amp; t.Kind() == reflect.Ptr &amp;&amp; v.Kind() != reflect.Ptr </span><span class="cov8" title="1">{
                        // This can occur during partial failure.
                        if !v.CanAddr() </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">v = v.Addr()</span>
                }

                // Already of the right kind, don't bother converting.
                <span class="cov8" title="1">if v.Kind() == t.Kind() </span><span class="cov8" title="1">{
                        if v.Type() != t </span><span class="cov8" title="1">{
                                v = v.Convert(t)
                        }</span>
                        <span class="cov8" title="1">out = append(out, v)
                        continue</span>
                }

                <span class="cov8" title="1">kind := t.Kind()
                switch kind </span>{ // nolint: exhaustive
                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                        n, err := strconv.ParseInt(v.String(), 0, sizeOfKind(kind))
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">v = reflect.New(t).Elem()
                        v.SetInt(n)</span>

                case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov8" title="1">
                        n, err := strconv.ParseUint(v.String(), 0, sizeOfKind(kind))
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">v = reflect.New(t).Elem()
                        v.SetUint(n)</span>

                case reflect.Bool:<span class="cov8" title="1">
                        v = reflect.ValueOf(true)</span>

                case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                        n, err := strconv.ParseFloat(v.String(), sizeOfKind(kind))
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">v = reflect.New(t).Elem()
                        v.SetFloat(n)</span>
                }

                <span class="cov8" title="1">out = append(out, v)</span>
        }
        <span class="cov8" title="1">return out, nil</span>
}

func sizeOfKind(kind reflect.Kind) int <span class="cov8" title="1">{
        switch kind </span>{ // nolint: exhaustive
        case reflect.Int8, reflect.Uint8:<span class="cov8" title="1">
                return 8</span>
        case reflect.Int16, reflect.Uint16:<span class="cov8" title="1">
                return 16</span>
        case reflect.Int32, reflect.Uint32, reflect.Float32:<span class="cov8" title="1">
                return 32</span>
        case reflect.Int64, reflect.Uint64, reflect.Float64:<span class="cov8" title="1">
                return 64</span>
        case reflect.Int, reflect.Uint:<span class="cov8" title="1">
                return strconv.IntSize</span>
        }
        <span class="cov0" title="0">panic("unsupported kind " + kind.String())</span>
}

func maybeRef(tmpl reflect.Type, strct reflect.Value) reflect.Value <span class="cov8" title="1">{
        if strct.Type() == tmpl </span><span class="cov8" title="1">{
                return strct
        }</span>
        <span class="cov8" title="1">if tmpl.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                if strct.CanAddr() </span><span class="cov8" title="1">{
                        return strct.Addr()
                }</span>
                <span class="cov0" title="0">ptr := reflect.New(tmpl)
                ptr.Set(strct)
                return ptr</span>
        }
        <span class="cov8" title="1">return strct</span>
}

// Set field.
//
// If field is a pointer the pointer will be set to the value. If field is a string, value will be
// appended. If field is a slice, value will be appended to slice.
//
// For all other types, an attempt will be made to convert the string to the corresponding
// type (int, float32, etc.).
func setField(tokens []lexer.Token, strct reflect.Value, field structLexerField, fieldValue []reflect.Value) (err error) <span class="cov8" title="1">{ // nolint: gocognit
        f := strct.FieldByIndex(field.Index)

        // Any kind of pointer, hydrate it first.
        if f.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                if f.IsNil() </span><span class="cov8" title="1">{
                        fv := reflect.New(f.Type().Elem()).Elem()
                        f.Set(fv.Addr())
                        f = fv
                }</span> else<span class="cov8" title="1"> {
                        f = f.Elem()
                }</span>
        }

        <span class="cov8" title="1">var pos lexer.Position
        if len(tokens) &gt; 0 </span><span class="cov8" title="1">{
                pos = tokens[0].Pos
        }</span>

        <span class="cov8" title="1">if f.Type() == tokenType </span><span class="cov8" title="1">{
                f.Set(reflect.ValueOf(tokens[0]))
                return nil
        }</span>

        <span class="cov8" title="1">if f.Type() == tokensType </span><span class="cov8" title="1">{
                f.Set(reflect.ValueOf(tokens))
                return nil
        }</span>

        <span class="cov8" title="1">if f.CanAddr() </span><span class="cov8" title="1">{
                if d, ok := f.Addr().Interface().(Capture); ok </span><span class="cov8" title="1">{
                        ifv := make([]string, 0, len(fieldValue))
                        for _, v := range fieldValue </span><span class="cov8" title="1">{
                                ifv = append(ifv, v.Interface().(string))
                        }</span>
                        <span class="cov8" title="1">err = d.Capture(ifv)
                        if err != nil </span><span class="cov0" title="0">{
                                return Wrapf(pos, err, "failed to capture")
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                } else<span class="cov8" title="1"> if d, ok := f.Addr().Interface().(encoding.TextUnmarshaler); ok </span><span class="cov8" title="1">{
                        for _, v := range fieldValue </span><span class="cov8" title="1">{
                                if err := d.UnmarshalText([]byte(v.Interface().(string))); err != nil </span><span class="cov0" title="0">{
                                        return Wrapf(pos, err, "failed to unmarshal text")
                                }</span>
                        }
                        <span class="cov8" title="1">return nil</span>
                }
        }

        <span class="cov8" title="1">if f.Kind() == reflect.Slice </span><span class="cov8" title="1">{
                sliceElemType := f.Type().Elem()
                if sliceElemType.Implements(captureType) || reflect.PtrTo(sliceElemType).Implements(captureType) </span><span class="cov8" title="1">{
                        if sliceElemType.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                                sliceElemType = sliceElemType.Elem()
                        }</span>
                        <span class="cov8" title="1">for _, v := range fieldValue </span><span class="cov8" title="1">{
                                d := reflect.New(sliceElemType).Interface().(Capture)
                                if err := d.Capture([]string{v.Interface().(string)}); err != nil </span><span class="cov0" title="0">{
                                        return Wrapf(pos, err, "failed to capture")
                                }</span>
                                <span class="cov8" title="1">eltValue := reflect.ValueOf(d)
                                if f.Type().Elem().Kind() != reflect.Ptr </span><span class="cov8" title="1">{
                                        eltValue = eltValue.Elem()
                                }</span>
                                <span class="cov8" title="1">f.Set(reflect.Append(f, eltValue))</span>
                        }
                } else<span class="cov8" title="1"> {
                        fieldValue, err = conform(sliceElemType, fieldValue)
                        if err != nil </span><span class="cov0" title="0">{
                                return Wrapf(pos, err, "failed to conform")
                        }</span>
                        <span class="cov8" title="1">f.Set(reflect.Append(f, fieldValue...))</span>
                }
                <span class="cov8" title="1">return nil</span>
        }

        // Strings concatenate all captured tokens.
        <span class="cov8" title="1">if f.Kind() == reflect.String </span><span class="cov8" title="1">{
                fieldValue, err = conform(f.Type(), fieldValue)
                if err != nil </span><span class="cov0" title="0">{
                        return Wrapf(pos, err, "failed to conform")
                }</span>
                <span class="cov8" title="1">if len(fieldValue) == 0 </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">accumulated := f.String()
                for _, v := range fieldValue </span><span class="cov8" title="1">{
                        accumulated += v.String()
                }</span>
                <span class="cov8" title="1">f.SetString(accumulated)
                return nil</span>
        }

        // Coalesce multiple tokens into one. This allows eg. ["-", "10"] to be captured as separate tokens but
        // parsed as a single string "-10".
        <span class="cov8" title="1">if len(fieldValue) &gt; 1 </span><span class="cov8" title="1">{
                out := []string{}
                for _, v := range fieldValue </span><span class="cov8" title="1">{
                        out = append(out, v.String())
                }</span>
                <span class="cov8" title="1">fieldValue = []reflect.Value{reflect.ValueOf(strings.Join(out, ""))}</span>
        }

        <span class="cov8" title="1">fieldValue, err = conform(f.Type(), fieldValue)
        if err != nil </span><span class="cov8" title="1">{
                return Wrapf(pos, err, "failed to conform")
        }</span>
        <span class="cov8" title="1">if len(fieldValue) == 0 </span><span class="cov8" title="1">{
                return nil // Nothing to capture, can happen when trying to get a partial parse tree
        }</span>

        <span class="cov8" title="1">fv := fieldValue[0]

        switch f.Kind() </span>{ // nolint: exhaustive
        // Numeric types will increment if the token can not be coerced.
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                if fv.Type() != f.Type() </span><span class="cov0" title="0">{
                        f.SetInt(f.Int() + 1)
                }</span> else<span class="cov8" title="1"> {
                        f.Set(fv)
                }</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov8" title="1">
                if fv.Type() != f.Type() </span><span class="cov0" title="0">{
                        f.SetUint(f.Uint() + 1)
                }</span> else<span class="cov8" title="1"> {
                        f.Set(fv)
                }</span>

        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                if fv.Type() != f.Type() </span><span class="cov0" title="0">{
                        f.SetFloat(f.Float() + 1)
                }</span> else<span class="cov8" title="1"> {
                        f.Set(fv)
                }</span>

        case reflect.Bool, reflect.Struct, reflect.Interface:<span class="cov8" title="1">
                if f.Kind() == reflect.Bool &amp;&amp; fv.Kind() == reflect.Bool </span><span class="cov8" title="1">{
                        f.SetBool(fv.Bool())
                        break</span>
                }
                <span class="cov8" title="1">if fv.Type() != f.Type() </span><span class="cov0" title="0">{
                        return Errorf(pos, "value %q is not correct type %s", fv, f.Type())
                }</span>
                <span class="cov8" title="1">f.Set(fv)</span>

        default:<span class="cov0" title="0">
                return Errorf(pos, "unsupported field type %s for field %s", f.Type(), field.Name)</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package participle

import (
        "fmt"
        "io"
        "reflect"

        "github.com/alecthomas/participle/v2/lexer"
)

// MaxLookahead can be used with UseLookahead to get pseudo-infinite
// lookahead without the risk of pathological cases causing a stack
// overflow.
const MaxLookahead = 99999

// An Option to modify the behaviour of the Parser.
type Option func(p *parserOptions) error

// Lexer is an Option that sets the lexer to use with the given grammar.
func Lexer(def lexer.Definition) Option <span class="cov8" title="1">{
        return func(p *parserOptions) error </span><span class="cov8" title="1">{
                p.lex = def
                return nil
        }</span>
}

// UseLookahead allows branch lookahead up to "n" tokens.
//
// If parsing cannot be disambiguated before "n" tokens of lookahead, parsing will fail.
//
// Note that increasing lookahead has a minor performance impact, but also
// reduces the accuracy of error reporting.
//
// If "n" is negative, it will be treated as "infinite" lookahead.
// This can have a large impact on performance, and does not provide any
// protection against stack overflow during parsing.
// In most cases, using MaxLookahead will achieve the same results in practice,
// but with a concrete upper bound to prevent pathological behavior in the parser.
// Using infinite lookahead can be useful for testing, or for parsing especially
// ambiguous grammars. Use at your own risk!
func UseLookahead(n int) Option <span class="cov8" title="1">{
        return func(p *parserOptions) error </span><span class="cov8" title="1">{
                p.useLookahead = n
                return nil
        }</span>
}

// CaseInsensitive allows the specified token types to be matched case-insensitively.
//
// Note that the lexer itself will also have to be case-insensitive; this option
// just controls whether literals in the grammar are matched case insensitively.
func CaseInsensitive(tokens ...string) Option <span class="cov8" title="1">{
        return func(p *parserOptions) error </span><span class="cov8" title="1">{
                for _, token := range tokens </span><span class="cov8" title="1">{
                        p.caseInsensitive[token] = true
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

// ParseTypeWith associates a custom parsing function with some interface type T.
// When the parser encounters a value of type T, it will use the given parse function to
// parse a value from the input.
//
// The parse function may return anything it wishes as long as that value satisfies the interface T.
// However, only a single function can be defined for any type T.
// If you want to have multiple parse functions returning types that satisfy the same interface, you'll
// need to define new wrapper types for each one.
//
// This can be useful if you want to parse a DSL within the larger grammar, or if you want
// to implement an optimized parsing scheme for some portion of the grammar.
func ParseTypeWith[T any](parseFn func(*lexer.PeekingLexer) (T, error)) Option <span class="cov8" title="1">{
        return func(p *parserOptions) error </span><span class="cov8" title="1">{
                parseFnVal := reflect.ValueOf(parseFn)
                parseFnType := parseFnVal.Type()
                if parseFnType.Out(0).Kind() != reflect.Interface </span><span class="cov0" title="0">{
                        return fmt.Errorf("ParseTypeWith: T must be an interface type (got %s)", parseFnType.Out(0))
                }</span>
                <span class="cov8" title="1">prodType := parseFnType.Out(0)
                p.customDefs = append(p.customDefs, customDef{prodType, parseFnVal})
                return nil</span>
        }
}

// Union associates several member productions with some interface type T.
// Given members X, Y, Z, and W for a union type U, then the EBNF rule is:
//
//        U = X | Y | Z | W .
//
// When the parser encounters a field of type T, it will attempt to parse each member
// in sequence and take the first match. Because of this, the order in which the
// members are defined is important. You must be careful to order your members appropriately.
//
// An example of a bad parse that can happen if members are out of order:
//
// If the first member matches A, and the second member matches A B,
// and the source string is "AB", then the parser will only match A, and will not
// try to parse the second member at all.
func Union[T any](members ...T) Option <span class="cov8" title="1">{
        return func(p *parserOptions) error </span><span class="cov8" title="1">{
                var t T
                unionType := reflect.TypeOf(&amp;t).Elem()
                if unionType.Kind() != reflect.Interface </span><span class="cov0" title="0">{
                        return fmt.Errorf("union: union type must be an interface (got %s)", unionType)
                }</span>
                <span class="cov8" title="1">memberTypes := make([]reflect.Type, 0, len(members))
                for _, m := range members </span><span class="cov8" title="1">{
                        memberTypes = append(memberTypes, reflect.TypeOf(m))
                }</span>
                <span class="cov8" title="1">p.unionDefs = append(p.unionDefs, unionDef{unionType, memberTypes})
                return nil</span>
        }
}

// ParseOption modifies how an individual parse is applied.
type ParseOption func(p *parseContext)

// Trace the parse to "w".
func Trace(w io.Writer) ParseOption <span class="cov8" title="1">{
        return func(p *parseContext) </span><span class="cov8" title="1">{
                p.trace = w
        }</span>
}

// AllowTrailing tokens without erroring.
//
// That is, do not error if a full parse completes but additional tokens remain.
func AllowTrailing(ok bool) ParseOption <span class="cov8" title="1">{
        return func(p *parseContext) </span><span class="cov8" title="1">{
                p.allowTrailing = ok
        }</span>
}

// Recover enables error recovery during parsing using the given strategies.
//
// When parsing encounters an error, the parser will attempt each recovery
// strategy in order. If a strategy succeeds, the error is recorded and parsing
// continues. This allows the parser to report multiple errors and produce a
// partial AST even when the input contains errors.
//
// Example usage:
//
//        ast, err := parser.ParseString("", input,
//            participle.Recover(
//                participle.SkipUntil(";", "}"),
//                participle.NestedDelimiters("(", ")", [2]string{"[", "]"}),
//            ))
//
// If parsing succeeds with recovered errors, the returned error will be a
// *RecoveryError containing all accumulated errors.
func Recover(strategies ...RecoveryStrategy) ParseOption <span class="cov8" title="1">{
        return func(p *parseContext) </span><span class="cov8" title="1">{
                if p.recovery == nil </span><span class="cov8" title="1">{
                        p.recovery = &amp;recoveryConfig{
                                maxErrors: 100, // Default max errors
                        }
                }</span>
                <span class="cov8" title="1">p.recovery.strategies = append(p.recovery.strategies, strategies...)</span>
        }
}

// MaxRecoveryErrors sets the maximum number of errors to collect during recovery.
// Once this limit is reached, parsing will stop. Use 0 for unlimited errors.
func MaxRecoveryErrors(max int) ParseOption <span class="cov8" title="1">{
        return func(p *parseContext) </span><span class="cov8" title="1">{
                if p.recovery == nil </span><span class="cov0" title="0">{
                        p.recovery = &amp;recoveryConfig{}
                }</span>
                <span class="cov8" title="1">p.recovery.maxErrors = max</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package participle

import (
        "bytes"
        "fmt"
        "io"
        "reflect"
        "strings"

        "github.com/alecthomas/participle/v2/lexer"
)

type unionDef struct {
        typ     reflect.Type
        members []reflect.Type
}

type customDef struct {
        typ     reflect.Type
        parseFn reflect.Value
}

type parserOptions struct {
        lex                   lexer.Definition
        rootType              reflect.Type
        typeNodes             map[reflect.Type]node
        useLookahead          int
        caseInsensitive       map[string]bool
        caseInsensitiveTokens map[lexer.TokenType]bool
        mappers               []mapperByToken
        unionDefs             []unionDef
        customDefs            []customDef
        elide                 []string
}

// A Parser for a particular grammar and lexer.
type Parser[G any] struct {
        parserOptions
}

// ParserForProduction returns a new parser for the given production in grammar G.
func ParserForProduction[P, G any](parser *Parser[G]) (*Parser[P], error) <span class="cov8" title="1">{
        t := reflect.TypeOf(*new(P))
        _, ok := parser.typeNodes[t]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parser does not contain a production of type %s", t)
        }</span>
        <span class="cov8" title="1">return (*Parser[P])(parser), nil</span>
}

// MustBuild calls Build[G](options...) and panics if an error occurs.
func MustBuild[G any](options ...Option) *Parser[G] <span class="cov8" title="1">{
        parser, err := Build[G](options...)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return parser</span>
}

// Build constructs a parser for the given grammar.
//
// If "Lexer()" is not provided as an option, a default lexer based on text/scanner will be used. This scans typical Go-
// like tokens.
//
// See documentation for details.
func Build[G any](options ...Option) (parser *Parser[G], err error) <span class="cov8" title="1">{
        // Configure Parser[G] struct with defaults + options.
        p := &amp;Parser[G]{
                parserOptions: parserOptions{
                        lex:             lexer.TextScannerLexer,
                        caseInsensitive: map[string]bool{},
                        useLookahead:    1,
                },
        }
        for _, option := range options </span><span class="cov8" title="1">{
                if err = option(&amp;p.parserOptions); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">symbols := p.lex.Symbols()
        if len(p.mappers) &gt; 0 </span><span class="cov8" title="1">{
                mappers := map[lexer.TokenType][]Mapper{}
                for _, mapper := range p.mappers </span><span class="cov8" title="1">{
                        if len(mapper.symbols) == 0 </span><span class="cov0" title="0">{
                                mappers[lexer.EOF] = append(mappers[lexer.EOF], mapper.mapper)
                        }</span> else<span class="cov8" title="1"> {
                                for _, symbol := range mapper.symbols </span><span class="cov8" title="1">{
                                        if rn, ok := symbols[symbol]; !ok </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("mapper %#v uses unknown token %q", mapper, symbol)
                                        }</span> else<span class="cov8" title="1"> { // nolint: golint
                                                mappers[rn] = append(mappers[rn], mapper.mapper)
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">p.lex = &amp;mappingLexerDef{p.lex, func(t lexer.Token) (lexer.Token, error) </span><span class="cov8" title="1">{
                        combined := make([]Mapper, 0, len(mappers[t.Type])+len(mappers[lexer.EOF]))
                        combined = append(combined, mappers[lexer.EOF]...)
                        combined = append(combined, mappers[t.Type]...)

                        var err error
                        for _, m := range combined </span><span class="cov8" title="1">{
                                t, err = m(t)
                                if err != nil </span><span class="cov0" title="0">{
                                        return t, err
                                }</span>
                        }
                        <span class="cov8" title="1">return t, nil</span>
                }}
        }

        <span class="cov8" title="1">context := newGeneratorContext(p.lex)
        if err := context.addCustomDefs(p.customDefs); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := context.addUnionDefs(p.unionDefs); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var grammar G
        v := reflect.ValueOf(&amp;grammar)
        if v.Kind() == reflect.Interface </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>
        <span class="cov8" title="1">p.rootType = v.Type()
        rootNode, err := context.parseType(p.rootType)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := validate(rootNode); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">p.typeNodes = context.typeNodes
        p.typeNodes[p.rootType] = rootNode
        p.setCaseInsensitiveTokens()
        return p, nil</span>
}

// Lexer returns the parser's builtin lexer.
func (p *Parser[G]) Lexer() lexer.Definition <span class="cov0" title="0">{
        return p.lex
}</span>

// Lex uses the parser's lexer to tokenise input.
// Parameter filename is used as an opaque prefix in error messages.
func (p *Parser[G]) Lex(filename string, r io.Reader) ([]lexer.Token, error) <span class="cov8" title="1">{
        lex, err := p.lex.Lex(filename, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">tokens, err := lexer.ConsumeAll(lex)
        return tokens, err</span>
}

// ParseFromLexer into grammar v which must be of the same type as the grammar passed to
// Build().
//
// This may return a Error.
func (p *Parser[G]) ParseFromLexer(lex *lexer.PeekingLexer, options ...ParseOption) (*G, error) <span class="cov8" title="1">{
        v := new(G)
        rv := reflect.ValueOf(v)
        parseNode, err := p.parseNodeFor(rv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ctx := newParseContext(lex, p.useLookahead, p.caseInsensitiveTokens)
        defer func() </span><span class="cov8" title="1">{ *lex = ctx.PeekingLexer }</span>()
        <span class="cov8" title="1">for _, option := range options </span><span class="cov8" title="1">{
                option(&amp;ctx)
        }</span>
        // If the grammar implements Parseable, use it.
        <span class="cov8" title="1">if parseable, ok := any(v).(Parseable); ok </span><span class="cov8" title="1">{
                return v, p.rootParseable(&amp;ctx, parseable)
        }</span>
        <span class="cov8" title="1">return v, p.parseOne(&amp;ctx, parseNode, rv)</span>
}

func (p *Parser[G]) setCaseInsensitiveTokens() <span class="cov8" title="1">{
        p.caseInsensitiveTokens = map[lexer.TokenType]bool{}
        for sym, tt := range p.lex.Symbols() </span><span class="cov8" title="1">{
                if p.caseInsensitive[sym] </span><span class="cov8" title="1">{
                        p.caseInsensitiveTokens[tt] = true
                }</span>
        }
}

func (p *Parser[G]) parse(lex lexer.Lexer, options ...ParseOption) (v *G, err error) <span class="cov8" title="1">{
        peeker, err := lexer.Upgrade(lex, p.getElidedTypes()...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return p.ParseFromLexer(peeker, options...)</span>
}

// Parse from r into grammar v which must be of the same type as the grammar passed to
// Build(). Parameter filename is used as an opaque prefix in error messages.
//
// This may return an Error.
func (p *Parser[G]) Parse(filename string, r io.Reader, options ...ParseOption) (v *G, err error) <span class="cov8" title="1">{
        if filename == "" </span><span class="cov8" title="1">{
                filename = lexer.NameOfReader(r)
        }</span>
        <span class="cov8" title="1">lex, err := p.lex.Lex(filename, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return p.parse(lex, options...)</span>
}

// ParseString from s into grammar v which must be of the same type as the grammar passed to
// Build(). Parameter filename is used as an opaque prefix in error messages.
//
// This may return an Error.
func (p *Parser[G]) ParseString(filename string, s string, options ...ParseOption) (v *G, err error) <span class="cov8" title="1">{
        var lex lexer.Lexer
        if sl, ok := p.lex.(lexer.StringDefinition); ok </span><span class="cov8" title="1">{
                lex, err = sl.LexString(filename, s)
        }</span> else<span class="cov8" title="1"> {
                lex, err = p.lex.Lex(filename, strings.NewReader(s))
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return p.parse(lex, options...)</span>
}

// ParseBytes from b into grammar v which must be of the same type as the grammar passed to
// Build(). Parameter filename is used as an opaque prefix in error messages.
//
// This may return an Error.
func (p *Parser[G]) ParseBytes(filename string, b []byte, options ...ParseOption) (v *G, err error) <span class="cov0" title="0">{
        var lex lexer.Lexer
        if sl, ok := p.lex.(lexer.BytesDefinition); ok </span><span class="cov0" title="0">{
                lex, err = sl.LexBytes(filename, b)
        }</span> else<span class="cov0" title="0"> {
                lex, err = p.lex.Lex(filename, bytes.NewReader(b))
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return p.parse(lex, options...)</span>
}

func (p *Parser[G]) parseOne(ctx *parseContext, parseNode node, rv reflect.Value) error <span class="cov8" title="1">{
        err := p.parseInto(ctx, parseNode, rv)
        if err != nil </span><span class="cov8" title="1">{
                // If we had recovery errors but no final error, return the recovery errors
                if len(ctx.recoveryErrors) &gt; 0 </span><span class="cov0" title="0">{
                        ctx.recoveryErrors = append(ctx.recoveryErrors, err)
                        return &amp;RecoveryError{Errors: ctx.recoveryErrors}
                }</span>
                <span class="cov8" title="1">return err</span>
        }
        <span class="cov8" title="1">token := ctx.Peek()
        if !token.EOF() &amp;&amp; !ctx.allowTrailing </span><span class="cov8" title="1">{
                err = ctx.DeepestError(&amp;UnexpectedTokenError{Unexpected: *token})
                if len(ctx.recoveryErrors) &gt; 0 </span><span class="cov8" title="1">{
                        ctx.recoveryErrors = append(ctx.recoveryErrors, err)
                        return &amp;RecoveryError{Errors: ctx.recoveryErrors}
                }</span>
                <span class="cov8" title="1">return err</span>
        }
        // Return accumulated recovery errors if any
        <span class="cov8" title="1">if len(ctx.recoveryErrors) &gt; 0 </span><span class="cov8" title="1">{
                return &amp;RecoveryError{Errors: ctx.recoveryErrors}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (p *Parser[G]) parseInto(ctx *parseContext, parseNode node, rv reflect.Value) error <span class="cov8" title="1">{
        if rv.IsNil() </span><span class="cov0" title="0">{
                return fmt.Errorf("target must be a non-nil pointer to a struct or interface, but is a nil %s", rv.Type())
        }</span>
        <span class="cov8" title="1">pv, err := p.typeNodes[rv.Type().Elem()].Parse(ctx, rv.Elem())
        if len(pv) &gt; 0 &amp;&amp; pv[0].Type() == rv.Elem().Type() </span><span class="cov8" title="1">{
                rv.Elem().Set(reflect.Indirect(pv[0]))
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if pv == nil </span><span class="cov8" title="1">{
                token := ctx.Peek()
                return ctx.DeepestError(&amp;UnexpectedTokenError{Unexpected: *token})
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (p *Parser[G]) rootParseable(ctx *parseContext, parseable Parseable) error <span class="cov8" title="1">{
        if err := parseable.Parse(&amp;ctx.PeekingLexer); err != nil </span><span class="cov8" title="1">{
                if err == NextMatch </span><span class="cov0" title="0">{
                        err = &amp;UnexpectedTokenError{Unexpected: *ctx.Peek()}
                }</span> else<span class="cov8" title="1"> {
                        err = &amp;ParseError{Msg: err.Error(), Pos: ctx.Peek().Pos}
                }</span>
                <span class="cov8" title="1">return ctx.DeepestError(err)</span>
        }
        <span class="cov0" title="0">peek := ctx.Peek()
        if !peek.EOF() &amp;&amp; !ctx.allowTrailing </span><span class="cov0" title="0">{
                return ctx.DeepestError(&amp;UnexpectedTokenError{Unexpected: *peek})
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (p *Parser[G]) getElidedTypes() []lexer.TokenType <span class="cov8" title="1">{
        symbols := p.lex.Symbols()
        elideTypes := make([]lexer.TokenType, 0, len(p.elide))
        for _, elide := range p.elide </span><span class="cov8" title="1">{
                rn, ok := symbols[elide]
                if !ok </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("Elide() uses unknown token %q", elide))</span>
                }
                <span class="cov8" title="1">elideTypes = append(elideTypes, rn)</span>
        }
        <span class="cov8" title="1">return elideTypes</span>
}

func (p *Parser[G]) parseNodeFor(v reflect.Value) (node, error) <span class="cov8" title="1">{
        t := v.Type()
        if t.Kind() == reflect.Interface </span><span class="cov0" title="0">{
                t = t.Elem()
        }</span>
        <span class="cov8" title="1">if t.Kind() != reflect.Ptr || (t.Elem().Kind() != reflect.Struct &amp;&amp; t.Elem().Kind() != reflect.Interface) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected a pointer to a struct or interface, but got %s", t)
        }</span>
        <span class="cov8" title="1">parseNode := p.typeNodes[t]
        if parseNode == nil </span><span class="cov8" title="1">{
                t = t.Elem()
                parseNode = p.typeNodes[t]
        }</span>
        <span class="cov8" title="1">if parseNode == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parser does not know how to parse values of type %s", t)
        }</span>
        <span class="cov8" title="1">return parseNode, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package participle

import (
        "reflect"

        "github.com/alecthomas/participle/v2/lexer"
)

// RecoveryStrategy defines a strategy for recovering from parse errors.
//
// Error recovery allows the parser to continue parsing after encountering an error,
// collecting multiple errors and producing a partial AST. This is inspired by
// Chumsky's recovery system in Rust and classic compiler panic-mode recovery.
//
// There is no silver bullet strategy for error recovery. By definition, if the input
// to a parser is invalid then the parser can only make educated guesses as to the
// meaning of the input. Different recovery strategies will work better for different
// languages, and for different patterns within those languages.
type RecoveryStrategy interface {
        // Recover attempts to recover from a parse error.
        //
        // Parameters:
        //   - ctx: The parse context (positioned after the failed parse attempt)
        //   - err: The error that triggered recovery
        //   - parent: The parent value being parsed into
        //
        // Returns:
        //   - recovered: true if recovery was successful
        //   - values: any values recovered (may be nil/fallback for skip strategies)
        //   - newErr: the error to report (may be modified/wrapped)
        Recover(ctx *parseContext, err error, parent reflect.Value) (recovered bool, values []reflect.Value, newErr error)
}

// recoveryConfig holds recovery configuration for a parse context.
type recoveryConfig struct {
        strategies []RecoveryStrategy
        errors     []error
        maxErrors  int
}

// RecoveryError wraps multiple errors that occurred during parsing with recovery.
type RecoveryError struct {
        Errors []error
}

func (r *RecoveryError) Error() string <span class="cov8" title="1">{
        if len(r.Errors) == 0 </span><span class="cov8" title="1">{
                return "no errors"
        }</span>
        <span class="cov8" title="1">if len(r.Errors) == 1 </span><span class="cov8" title="1">{
                return r.Errors[0].Error()
        }</span>
        <span class="cov8" title="1">msg := r.Errors[0].Error()
        for i := 1; i &lt; len(r.Errors); i++ </span><span class="cov8" title="1">{
                msg += "\n" + r.Errors[i].Error()
        }</span>
        <span class="cov8" title="1">return msg</span>
}

// Unwrap returns the first error for compatibility with errors.Is/As.
func (r *RecoveryError) Unwrap() error <span class="cov8" title="1">{
        if len(r.Errors) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return r.Errors[0]</span>
}

// SkipUntilStrategy skips tokens until one of the synchronization tokens is found.
//
// This is the classic "panic mode" recovery strategy from compiler theory.
// It's simple but effective for languages with clear statement terminators
// (like semicolons) or block delimiters.
//
// Example usage:
//
//        parser.ParseString("", input, participle.Recover(SkipUntil(";", "}", ")")))
type SkipUntilStrategy struct {
        // Tokens to synchronize on (the parser will stop before these tokens)
        SyncTokens []string
        // If true, consume the sync token; if false, leave it for the next parse
        ConsumeSyncToken bool
        // Fallback returns a fallback value when recovery succeeds.
        // If nil, an empty/zero value is used.
        Fallback func() interface{}
}

// SkipUntil creates a recovery strategy that skips tokens until a sync token is found.
//
// The sync tokens are typically statement terminators (";"), block delimiters ("}", ")"),
// or keywords that start new constructs ("if", "while", "func", etc.).
func SkipUntil(tokens ...string) *SkipUntilStrategy <span class="cov8" title="1">{
        return &amp;SkipUntilStrategy{
                SyncTokens:       tokens,
                ConsumeSyncToken: false,
        }
}</span>

// SkipPast creates a recovery strategy that skips tokens until a sync token is found,
// then consumes the sync token.
func SkipPast(tokens ...string) *SkipUntilStrategy <span class="cov8" title="1">{
        return &amp;SkipUntilStrategy{
                SyncTokens:       tokens,
                ConsumeSyncToken: true,
        }
}</span>

// WithFallback sets a fallback value generator for the skip strategy.
func (s *SkipUntilStrategy) WithFallback(f func() interface{}) *SkipUntilStrategy <span class="cov8" title="1">{
        s.Fallback = f
        return s
}</span>

func (s *SkipUntilStrategy) Recover(ctx *parseContext, err error, parent reflect.Value) (bool, []reflect.Value, error) <span class="cov8" title="1">{
        syncSet := make(map[string]bool)
        for _, t := range s.SyncTokens </span><span class="cov8" title="1">{
                syncSet[t] = true
        }</span>

        // Skip tokens until we find a sync token or EOF
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                token := ctx.Peek()
                if token.EOF() </span><span class="cov8" title="1">{
                        return false, nil, err
                }</span>
                <span class="cov8" title="1">if syncSet[token.Value] </span><span class="cov8" title="1">{
                        if s.ConsumeSyncToken </span><span class="cov8" title="1">{
                                ctx.Next()
                        }</span>
                        // Recovery successful
                        <span class="cov8" title="1">var values []reflect.Value
                        if s.Fallback != nil </span><span class="cov8" title="1">{
                                values = []reflect.Value{reflect.ValueOf(s.Fallback())}
                        }</span>
                        <span class="cov8" title="1">return true, values, err</span>
                }
                <span class="cov8" title="1">ctx.Next()</span>
        }
}

// SkipThenRetryUntilStrategy skips tokens and retries parsing until successful
// or a termination condition is met.
//
// This is more sophisticated than SkipUntil - it repeatedly:
// 1. Skips one token
// 2. Tries to parse again
// 3. If parsing succeeds without new errors, returns success
// 4. If parsing fails, repeats from step 1
//
// This continues until a termination token is found or EOF is reached.
type SkipThenRetryUntilStrategy struct {
        // Tokens that terminate the recovery attempt (stop trying)
        UntilTokens []string
        // Maximum tokens to skip before giving up (0 = unlimited)
        MaxSkip int
}

// SkipThenRetryUntil creates a strategy that skips tokens and retries parsing.
func SkipThenRetryUntil(untilTokens ...string) *SkipThenRetryUntilStrategy <span class="cov8" title="1">{
        return &amp;SkipThenRetryUntilStrategy{
                UntilTokens: untilTokens,
                MaxSkip:     100, // Reasonable default to prevent infinite loops
        }
}</span>

// WithMaxSkip sets the maximum number of tokens to skip.
func (s *SkipThenRetryUntilStrategy) WithMaxSkip(max int) *SkipThenRetryUntilStrategy <span class="cov8" title="1">{
        s.MaxSkip = max
        return s
}</span>

func (s *SkipThenRetryUntilStrategy) Recover(ctx *parseContext, err error, parent reflect.Value) (bool, []reflect.Value, error) <span class="cov8" title="1">{
        untilSet := make(map[string]bool)
        for _, t := range s.UntilTokens </span><span class="cov8" title="1">{
                untilSet[t] = true
        }</span>

        <span class="cov8" title="1">skipped := 0
        for </span><span class="cov8" title="1">{
                token := ctx.Peek()
                if token.EOF() || untilSet[token.Value] </span><span class="cov8" title="1">{
                        return false, nil, err
                }</span>
                <span class="cov8" title="1">if s.MaxSkip &gt; 0 &amp;&amp; skipped &gt;= s.MaxSkip </span><span class="cov0" title="0">{
                        return false, nil, err
                }</span>
                // Skip one token
                <span class="cov8" title="1">ctx.Next()
                skipped++
                // Note: The actual retry logic needs to be handled by the caller
                // since we don't have access to the parser node here.
                // This strategy just advances the cursor; the parseContext integration
                // handles the retry.
                return true, nil, err</span>
        }
}

// NestedDelimitersStrategy recovers by finding balanced delimiters.
//
// This is particularly useful for recovering from errors inside parenthesized
// expressions, function arguments, array indices, etc. It respects nesting,
// so it will correctly handle nested brackets.
//
// Example: If parsing `foo(bar(1, 2, err!@#), baz)` fails on `err!@#`,
// this strategy can skip to the closing `)` of `bar(...)` while respecting
// the nested parentheses.
type NestedDelimitersStrategy struct {
        // Start delimiter (e.g., "(", "[", "{")
        Start string
        // End delimiter (e.g., ")", "]", "}")
        End string
        // Additional delimiter pairs to respect for nesting
        Others [][2]string
        // Fallback returns a fallback value when recovery succeeds.
        Fallback func() interface{}
}

// NestedDelimiters creates a strategy that skips to balanced delimiters.
func NestedDelimiters(start, end string, others ...[2]string) *NestedDelimitersStrategy <span class="cov8" title="1">{
        return &amp;NestedDelimitersStrategy{
                Start:  start,
                End:    end,
                Others: others,
        }
}</span>

// WithFallback sets a fallback value generator for the nested delimiters strategy.
func (n *NestedDelimitersStrategy) WithFallback(f func() interface{}) *NestedDelimitersStrategy <span class="cov8" title="1">{
        n.Fallback = f
        return n
}</span>

func (n *NestedDelimitersStrategy) Recover(ctx *parseContext, err error, parent reflect.Value) (bool, []reflect.Value, error) <span class="cov8" title="1">{
        // Build delimiter maps
        openers := map[string]string{n.Start: n.End}
        closers := map[string]bool{n.End: true}
        for _, pair := range n.Others </span><span class="cov8" title="1">{
                openers[pair[0]] = pair[1]
                closers[pair[1]] = true
        }</span>

        // Track nesting depth for each delimiter type
        <span class="cov8" title="1">depths := make(map[string]int)

        // We start inside the delimited region, so we're looking for the closing delimiter
        // at depth 0 (or the matching closer for our opener)
        targetClose := n.End
        depth := 1 // We're inside one level of our target delimiters

        for </span><span class="cov8" title="1">{
                token := ctx.Peek()
                if token.EOF() </span><span class="cov8" title="1">{
                        return false, nil, err
                }</span>

                // Check if this opens a nested delimiter
                <span class="cov8" title="1">if closer, isOpener := openers[token.Value]; isOpener </span><span class="cov8" title="1">{
                        if token.Value == n.Start </span><span class="cov8" title="1">{
                                depth++
                        }</span> else<span class="cov0" title="0"> {
                                depths[closer]++
                        }</span>
                }

                // Check if this closes a delimiter
                <span class="cov8" title="1">if closers[token.Value] </span><span class="cov8" title="1">{
                        if token.Value == targetClose </span><span class="cov8" title="1">{
                                depth--
                                if depth == 0 </span><span class="cov8" title="1">{
                                        // Found our balanced closer - don't consume it
                                        var values []reflect.Value
                                        if n.Fallback != nil </span><span class="cov8" title="1">{
                                                values = []reflect.Value{reflect.ValueOf(n.Fallback())}
                                        }</span>
                                        <span class="cov8" title="1">return true, values, err</span>
                                }
                        } else<span class="cov8" title="1"> if depths[token.Value] &gt; 0 </span><span class="cov0" title="0">{
                                depths[token.Value]--
                        }</span> else<span class="cov8" title="1"> {
                                // Mismatched closer - this is an error, but we can try to continue
                                // by treating it as the end of our recovery region
                                return false, nil, err
                        }</span>
                }

                <span class="cov8" title="1">ctx.Next()</span>
        }
}

// TokenSyncStrategy synchronizes on specific token types rather than values.
//
// This is useful when you want to recover to any identifier, any string literal,
// or other token categories defined by your lexer.
type TokenSyncStrategy struct {
        // Token types to synchronize on (use lexer symbol names)
        SyncTypes []lexer.TokenType
        // If true, consume the sync token
        ConsumeSyncToken bool
        // Fallback value generator
        Fallback func() interface{}
}

// SyncToTokenType creates a strategy that syncs on token types.
func SyncToTokenType(types ...lexer.TokenType) *TokenSyncStrategy <span class="cov8" title="1">{
        return &amp;TokenSyncStrategy{
                SyncTypes:        types,
                ConsumeSyncToken: false,
        }
}</span>

func (t *TokenSyncStrategy) Recover(ctx *parseContext, err error, parent reflect.Value) (bool, []reflect.Value, error) <span class="cov0" title="0">{
        syncSet := make(map[lexer.TokenType]bool)
        for _, tt := range t.SyncTypes </span><span class="cov0" title="0">{
                syncSet[tt] = true
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                token := ctx.Peek()
                if token.EOF() </span><span class="cov0" title="0">{
                        return false, nil, err
                }</span>
                <span class="cov0" title="0">if syncSet[token.Type] </span><span class="cov0" title="0">{
                        if t.ConsumeSyncToken </span><span class="cov0" title="0">{
                                ctx.Next()
                        }</span>
                        <span class="cov0" title="0">var values []reflect.Value
                        if t.Fallback != nil </span><span class="cov0" title="0">{
                                values = []reflect.Value{reflect.ValueOf(t.Fallback())}
                        }</span>
                        <span class="cov0" title="0">return true, values, err</span>
                }
                <span class="cov0" title="0">ctx.Next()</span>
        }
}

// CompositeStrategy tries multiple strategies in order until one succeeds.
type CompositeStrategy struct {
        Strategies []RecoveryStrategy
}

// TryStrategies creates a composite strategy that tries each strategy in order.
func TryStrategies(strategies ...RecoveryStrategy) *CompositeStrategy <span class="cov8" title="1">{
        return &amp;CompositeStrategy{Strategies: strategies}
}</span>

func (c *CompositeStrategy) Recover(ctx *parseContext, err error, parent reflect.Value) (bool, []reflect.Value, error) <span class="cov8" title="1">{
        checkpoint := ctx.saveCheckpoint()

        for _, strategy := range c.Strategies </span><span class="cov8" title="1">{
                recovered, values, newErr := strategy.Recover(ctx, err, parent)
                if recovered </span><span class="cov8" title="1">{
                        return true, values, newErr
                }</span>
                // Reset cursor for next strategy attempt
                <span class="cov8" title="1">ctx.restoreCheckpoint(checkpoint)</span>
        }
        <span class="cov8" title="1">return false, nil, err</span>
}

// Helper functions for checkpoint-based recovery

// saveCheckpoint saves the current lexer position for potential restoration.
func (p *parseContext) saveCheckpoint() lexer.Checkpoint <span class="cov8" title="1">{
        return p.PeekingLexer.MakeCheckpoint()
}</span>

// restoreCheckpoint restores the lexer to a previously saved position.
func (p *parseContext) restoreCheckpoint(cp lexer.Checkpoint) <span class="cov8" title="1">{
        p.PeekingLexer.LoadCheckpoint(cp)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package participle

import (
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "text/scanner"
        "unicode/utf8"

        "github.com/alecthomas/participle/v2/lexer"
)

// A structLexer lexes over the tags of struct fields while tracking the current field.
type structLexer struct {
        s       reflect.Type
        field   int
        indexes [][]int
        lexer   *lexer.PeekingLexer
}

func lexStruct(s reflect.Type) (*structLexer, error) <span class="cov8" title="1">{
        indexes, err := collectFieldIndexes(s)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">slex := &amp;structLexer{
                s:       s,
                indexes: indexes,
        }
        if len(slex.indexes) &gt; 0 </span><span class="cov8" title="1">{
                tag := fieldLexerTag(slex.Field().StructField)
                slex.lexer, err = lexer.Upgrade(newTagLexer(s.Name(), tag))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return slex, nil</span>
}

// NumField returns the number of fields in the struct associated with this structLexer.
func (s *structLexer) NumField() int <span class="cov8" title="1">{
        return len(s.indexes)
}</span>

type structLexerField struct {
        reflect.StructField
        Index []int
}

// Field returns the field associated with the current token.
func (s *structLexer) Field() structLexerField <span class="cov8" title="1">{
        return s.GetField(s.field)
}</span>

func (s *structLexer) GetField(field int) structLexerField <span class="cov8" title="1">{
        if field &gt;= len(s.indexes) </span><span class="cov0" title="0">{
                field = len(s.indexes) - 1
        }</span>
        <span class="cov8" title="1">return structLexerField{
                StructField: s.s.FieldByIndex(s.indexes[field]),
                Index:       s.indexes[field],
        }</span>
}

func (s *structLexer) Peek() (*lexer.Token, error) <span class="cov8" title="1">{
        field := s.field
        lex := s.lexer
        for </span><span class="cov8" title="1">{
                token := lex.Peek()
                if !token.EOF() </span><span class="cov8" title="1">{
                        token.Pos.Line = field + 1
                        return token, nil
                }</span>
                <span class="cov8" title="1">field++
                if field &gt;= s.NumField() </span><span class="cov8" title="1">{
                        t := lexer.EOFToken(token.Pos)
                        return &amp;t, nil
                }</span>
                <span class="cov8" title="1">ft := s.GetField(field).StructField
                tag := fieldLexerTag(ft)
                var err error
                lex, err = lexer.Upgrade(newTagLexer(ft.Name, tag))
                if err != nil </span><span class="cov0" title="0">{
                        return token, err
                }</span>
        }
}

func (s *structLexer) Next() (*lexer.Token, error) <span class="cov8" title="1">{
        token := s.lexer.Next()
        if !token.EOF() </span><span class="cov8" title="1">{
                token.Pos.Line = s.field + 1
                return token, nil
        }</span>
        <span class="cov8" title="1">if s.field+1 &gt;= s.NumField() </span><span class="cov8" title="1">{
                t := lexer.EOFToken(token.Pos)
                return &amp;t, nil
        }</span>
        <span class="cov8" title="1">s.field++
        ft := s.Field().StructField
        tag := fieldLexerTag(ft)
        var err error
        s.lexer, err = lexer.Upgrade(newTagLexer(ft.Name, tag))
        if err != nil </span><span class="cov0" title="0">{
                return token, err
        }</span>
        <span class="cov8" title="1">return s.Next()</span>
}

func fieldLexerTag(field reflect.StructField) string <span class="cov8" title="1">{
        if tag, ok := field.Tag.Lookup("parser"); ok </span><span class="cov8" title="1">{
                return tag
        }</span>
        <span class="cov8" title="1">return string(field.Tag)</span>
}

// Recursively collect flattened indices for top-level fields and embedded fields.
func collectFieldIndexes(s reflect.Type) (out [][]int, err error) <span class="cov8" title="1">{
        if s.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected a struct but got %q", s)
        }</span>
        <span class="cov8" title="1">defer decorate(&amp;err, s.String)
        for i := 0; i &lt; s.NumField(); i++ </span><span class="cov8" title="1">{
                f := s.Field(i)
                switch </span>{
                case f.Anonymous &amp;&amp; f.Type.Kind() == reflect.Struct:<span class="cov8" title="1"> // Embedded struct.
                        children, err := collectFieldIndexes(f.Type)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">for _, idx := range children </span><span class="cov8" title="1">{
                                out = append(out, append(f.Index, idx...))
                        }</span>

                case f.PkgPath != "":<span class="cov8" title="1">
                        continue</span>

                case fieldLexerTag(f) != "":<span class="cov8" title="1">
                        out = append(out, f.Index)</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

// tagLexer is a Lexer based on text/scanner.Scanner
type tagLexer struct {
        scanner  *scanner.Scanner
        filename string
        err      error
}

func newTagLexer(filename string, tag string) *tagLexer <span class="cov8" title="1">{
        s := &amp;scanner.Scanner{}
        s.Init(strings.NewReader(tag))
        lexer := &amp;tagLexer{
                filename: filename,
                scanner:  s,
        }
        lexer.scanner.Error = func(s *scanner.Scanner, msg string) </span><span class="cov8" title="1">{
                // This is to support single quoted strings. Hacky.
                if !strings.HasSuffix(msg, "char literal") </span><span class="cov0" title="0">{
                        lexer.err = fmt.Errorf("%s: %s", lexer.scanner.Pos(), msg)
                }</span>
        }
        <span class="cov8" title="1">return lexer</span>
}

func (t *tagLexer) Next() (lexer.Token, error) <span class="cov8" title="1">{
        typ := t.scanner.Scan()
        text := t.scanner.TokenText()
        pos := lexer.Position(t.scanner.Position)
        pos.Filename = t.filename
        if t.err != nil </span><span class="cov0" title="0">{
                return lexer.Token{}, t.err
        }</span>
        <span class="cov8" title="1">return textScannerTransform(lexer.Token{
                Type:  lexer.TokenType(typ),
                Value: text,
                Pos:   pos,
        })</span>
}

func textScannerTransform(token lexer.Token) (lexer.Token, error) <span class="cov8" title="1">{
        // Unquote strings.
        switch token.Type </span>{
        case scanner.Char:<span class="cov8" title="1">
                // FIXME(alec): This is pretty hacky...we convert a single quoted char into a double
                // quoted string in order to support single quoted strings.
                token.Value = fmt.Sprintf("\"%s\"", token.Value[1:len(token.Value)-1])
                fallthrough</span>
        case scanner.String:<span class="cov8" title="1">
                s, err := strconv.Unquote(token.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return lexer.Token{}, Errorf(token.Pos, "%s: %q", err.Error(), token.Value)
                }</span>
                <span class="cov8" title="1">token.Value = s
                if token.Type == scanner.Char &amp;&amp; utf8.RuneCountInString(s) &gt; 1 </span><span class="cov8" title="1">{
                        token.Type = scanner.String
                }</span>
        case scanner.RawString:<span class="cov0" title="0">
                token.Value = token.Value[1 : len(token.Value)-1]</span>

        default:<span class="cov8" title="1"></span>
        }
        <span class="cov8" title="1">return token, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package participle

import (
        "fmt"
        "strings"
)

// Perform some post-construction validation. This currently does:
//
// Checks for left recursion.
func validate(n node) error <span class="cov8" title="1">{
        checked := map[*strct]bool{}
        seen := map[node]bool{}

        return visit(n, func(n node, next func() error) error </span><span class="cov8" title="1">{
                if n, ok := n.(*strct); ok </span><span class="cov8" title="1">{
                        if !checked[n] &amp;&amp; isLeftRecursive(n) </span><span class="cov8" title="1">{
                                return fmt.Errorf("left recursion detected on\n\n%s", indent(n.String()))
                        }</span>
                        <span class="cov8" title="1">checked[n] = true
                        if seen[n] </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                }
                <span class="cov8" title="1">seen[n] = true
                return next()</span>
        })
}

func isLeftRecursive(root *strct) (found bool) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{ _ = recover() }</span>()
        <span class="cov8" title="1">seen := map[node]bool{}
        _ = visit(root.expr, func(n node, next func() error) error </span><span class="cov8" title="1">{
                if found </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">switch n := n.(type) </span>{
                case *strct:<span class="cov8" title="1">
                        if root.typ == n.typ </span><span class="cov8" title="1">{
                                found = true
                        }</span>

                case *sequence:<span class="cov8" title="1">
                        if !n.head </span><span class="cov8" title="1">{
                                panic("done")</span>
                        }
                }
                <span class="cov8" title="1">if seen[n] </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">seen[n] = true
                return next()</span>
        })
        <span class="cov8" title="1">return</span>
}

func indent(s string) string <span class="cov8" title="1">{
        return "  " + strings.Join(strings.Split(s, "\n"), "\n  ")
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package participle

import "fmt"

// Visit all nodes.
//
// Cycles are deliberately not detected, it is up to the visitor function to handle this.
func visit(n node, visitor func(n node, next func() error) error) error <span class="cov8" title="1">{
        return visitor(n, func() error </span><span class="cov8" title="1">{
                switch n := n.(type) </span>{
                case *disjunction:<span class="cov8" title="1">
                        for _, child := range n.nodes </span><span class="cov8" title="1">{
                                if err := visit(child, visitor); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">return nil</span>
                case *strct:<span class="cov8" title="1">
                        return visit(n.expr, visitor)</span>
                case *custom:<span class="cov8" title="1">
                        return nil</span>
                case *union:<span class="cov8" title="1">
                        for _, member := range n.disjunction.nodes </span><span class="cov8" title="1">{
                                if err := visit(member, visitor); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">return nil</span>
                case *sequence:<span class="cov8" title="1">
                        if err := visit(n.node, visitor); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if n.next != nil </span><span class="cov8" title="1">{
                                return visit(n.next, visitor)
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                case *parseable:<span class="cov8" title="1">
                        return nil</span>
                case *capture:<span class="cov8" title="1">
                        return visit(n.node, visitor)</span>
                case *reference:<span class="cov8" title="1">
                        return nil</span>
                case *negation:<span class="cov8" title="1">
                        return visit(n.node, visitor)</span>
                case *literal:<span class="cov8" title="1">
                        return nil</span>
                case *group:<span class="cov8" title="1">
                        return visit(n.expr, visitor)</span>
                case *lookaheadGroup:<span class="cov8" title="1">
                        return visit(n.expr, visitor)</span>
                default:<span class="cov0" title="0">
                        panic(fmt.Sprintf("%T", n))</span>
                }
        })
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
